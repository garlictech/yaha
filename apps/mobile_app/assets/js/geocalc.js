"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/geojson-rbush/node_modules/rbush/rbush.min.js
  var require_rbush_min = __commonJS({
    "node_modules/geojson-rbush/node_modules/rbush/rbush.min.js"(exports, module) {
      !function(t, i) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = i() : "function" == typeof define && define.amd ? define(i) : (t = t || self).RBush = i();
      }(exports, function() {
        "use strict";
        function t(t2, r2, e3, a2, h2) {
          !function t3(n2, r3, e4, a3, h3) {
            for (; a3 > e4; ) {
              if (a3 - e4 > 600) {
                var o2 = a3 - e4 + 1, s2 = r3 - e4 + 1, l2 = Math.log(o2), f2 = 0.5 * Math.exp(2 * l2 / 3), u2 = 0.5 * Math.sqrt(l2 * f2 * (o2 - f2) / o2) * (s2 - o2 / 2 < 0 ? -1 : 1), m2 = Math.max(e4, Math.floor(r3 - s2 * f2 / o2 + u2)), c2 = Math.min(a3, Math.floor(r3 + (o2 - s2) * f2 / o2 + u2));
                t3(n2, r3, m2, c2, h3);
              }
              var p2 = n2[r3], d2 = e4, x2 = a3;
              for (i(n2, e4, r3), h3(n2[a3], p2) > 0 && i(n2, e4, a3); d2 < x2; ) {
                for (i(n2, d2, x2), d2++, x2--; h3(n2[d2], p2) < 0; )
                  d2++;
                for (; h3(n2[x2], p2) > 0; )
                  x2--;
              }
              0 === h3(n2[e4], p2) ? i(n2, e4, x2) : i(n2, ++x2, a3), x2 <= r3 && (e4 = x2 + 1), r3 <= x2 && (a3 = x2 - 1);
            }
          }(t2, r2, e3 || 0, a2 || t2.length - 1, h2 || n);
        }
        function i(t2, i2, n2) {
          var r2 = t2[i2];
          t2[i2] = t2[n2], t2[n2] = r2;
        }
        function n(t2, i2) {
          return t2 < i2 ? -1 : t2 > i2 ? 1 : 0;
        }
        var r = function(t2) {
          void 0 === t2 && (t2 = 9), this._maxEntries = Math.max(4, t2), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
        };
        function e(t2, i2, n2) {
          if (!n2)
            return i2.indexOf(t2);
          for (var r2 = 0; r2 < i2.length; r2++)
            if (n2(t2, i2[r2]))
              return r2;
          return -1;
        }
        function a(t2, i2) {
          h(t2, 0, t2.children.length, i2, t2);
        }
        function h(t2, i2, n2, r2, e3) {
          e3 || (e3 = p(null)), e3.minX = 1 / 0, e3.minY = 1 / 0, e3.maxX = -1 / 0, e3.maxY = -1 / 0;
          for (var a2 = i2; a2 < n2; a2++) {
            var h2 = t2.children[a2];
            o(e3, t2.leaf ? r2(h2) : h2);
          }
          return e3;
        }
        function o(t2, i2) {
          return t2.minX = Math.min(t2.minX, i2.minX), t2.minY = Math.min(t2.minY, i2.minY), t2.maxX = Math.max(t2.maxX, i2.maxX), t2.maxY = Math.max(t2.maxY, i2.maxY), t2;
        }
        function s(t2, i2) {
          return t2.minX - i2.minX;
        }
        function l(t2, i2) {
          return t2.minY - i2.minY;
        }
        function f(t2) {
          return (t2.maxX - t2.minX) * (t2.maxY - t2.minY);
        }
        function u(t2) {
          return t2.maxX - t2.minX + (t2.maxY - t2.minY);
        }
        function m(t2, i2) {
          return t2.minX <= i2.minX && t2.minY <= i2.minY && i2.maxX <= t2.maxX && i2.maxY <= t2.maxY;
        }
        function c(t2, i2) {
          return i2.minX <= t2.maxX && i2.minY <= t2.maxY && i2.maxX >= t2.minX && i2.maxY >= t2.minY;
        }
        function p(t2) {
          return { children: t2, height: 1, leaf: true, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
        }
        function d(i2, n2, r2, e3, a2) {
          for (var h2 = [n2, r2]; h2.length; )
            if (!((r2 = h2.pop()) - (n2 = h2.pop()) <= e3)) {
              var o2 = n2 + Math.ceil((r2 - n2) / e3 / 2) * e3;
              t(i2, o2, n2, r2, a2), h2.push(n2, o2, o2, r2);
            }
        }
        return r.prototype.all = function() {
          return this._all(this.data, []);
        }, r.prototype.search = function(t2) {
          var i2 = this.data, n2 = [];
          if (!c(t2, i2))
            return n2;
          for (var r2 = this.toBBox, e3 = []; i2; ) {
            for (var a2 = 0; a2 < i2.children.length; a2++) {
              var h2 = i2.children[a2], o2 = i2.leaf ? r2(h2) : h2;
              c(t2, o2) && (i2.leaf ? n2.push(h2) : m(t2, o2) ? this._all(h2, n2) : e3.push(h2));
            }
            i2 = e3.pop();
          }
          return n2;
        }, r.prototype.collides = function(t2) {
          var i2 = this.data;
          if (!c(t2, i2))
            return false;
          for (var n2 = []; i2; ) {
            for (var r2 = 0; r2 < i2.children.length; r2++) {
              var e3 = i2.children[r2], a2 = i2.leaf ? this.toBBox(e3) : e3;
              if (c(t2, a2)) {
                if (i2.leaf || m(t2, a2))
                  return true;
                n2.push(e3);
              }
            }
            i2 = n2.pop();
          }
          return false;
        }, r.prototype.load = function(t2) {
          if (!t2 || !t2.length)
            return this;
          if (t2.length < this._minEntries) {
            for (var i2 = 0; i2 < t2.length; i2++)
              this.insert(t2[i2]);
            return this;
          }
          var n2 = this._build(t2.slice(), 0, t2.length - 1, 0);
          if (this.data.children.length)
            if (this.data.height === n2.height)
              this._splitRoot(this.data, n2);
            else {
              if (this.data.height < n2.height) {
                var r2 = this.data;
                this.data = n2, n2 = r2;
              }
              this._insert(n2, this.data.height - n2.height - 1, true);
            }
          else
            this.data = n2;
          return this;
        }, r.prototype.insert = function(t2) {
          return t2 && this._insert(t2, this.data.height - 1), this;
        }, r.prototype.clear = function() {
          return this.data = p([]), this;
        }, r.prototype.remove = function(t2, i2) {
          if (!t2)
            return this;
          for (var n2, r2, a2, h2 = this.data, o2 = this.toBBox(t2), s2 = [], l2 = []; h2 || s2.length; ) {
            if (h2 || (h2 = s2.pop(), r2 = s2[s2.length - 1], n2 = l2.pop(), a2 = true), h2.leaf) {
              var f2 = e(t2, h2.children, i2);
              if (-1 !== f2)
                return h2.children.splice(f2, 1), s2.push(h2), this._condense(s2), this;
            }
            a2 || h2.leaf || !m(h2, o2) ? r2 ? (n2++, h2 = r2.children[n2], a2 = false) : h2 = null : (s2.push(h2), l2.push(n2), n2 = 0, r2 = h2, h2 = h2.children[0]);
          }
          return this;
        }, r.prototype.toBBox = function(t2) {
          return t2;
        }, r.prototype.compareMinX = function(t2, i2) {
          return t2.minX - i2.minX;
        }, r.prototype.compareMinY = function(t2, i2) {
          return t2.minY - i2.minY;
        }, r.prototype.toJSON = function() {
          return this.data;
        }, r.prototype.fromJSON = function(t2) {
          return this.data = t2, this;
        }, r.prototype._all = function(t2, i2) {
          for (var n2 = []; t2; )
            t2.leaf ? i2.push.apply(i2, t2.children) : n2.push.apply(n2, t2.children), t2 = n2.pop();
          return i2;
        }, r.prototype._build = function(t2, i2, n2, r2) {
          var e3, h2 = n2 - i2 + 1, o2 = this._maxEntries;
          if (h2 <= o2)
            return a(e3 = p(t2.slice(i2, n2 + 1)), this.toBBox), e3;
          r2 || (r2 = Math.ceil(Math.log(h2) / Math.log(o2)), o2 = Math.ceil(h2 / Math.pow(o2, r2 - 1))), (e3 = p([])).leaf = false, e3.height = r2;
          var s2 = Math.ceil(h2 / o2), l2 = s2 * Math.ceil(Math.sqrt(o2));
          d(t2, i2, n2, l2, this.compareMinX);
          for (var f2 = i2; f2 <= n2; f2 += l2) {
            var u2 = Math.min(f2 + l2 - 1, n2);
            d(t2, f2, u2, s2, this.compareMinY);
            for (var m2 = f2; m2 <= u2; m2 += s2) {
              var c2 = Math.min(m2 + s2 - 1, u2);
              e3.children.push(this._build(t2, m2, c2, r2 - 1));
            }
          }
          return a(e3, this.toBBox), e3;
        }, r.prototype._chooseSubtree = function(t2, i2, n2, r2) {
          for (; r2.push(i2), !i2.leaf && r2.length - 1 !== n2; ) {
            for (var e3 = 1 / 0, a2 = 1 / 0, h2 = void 0, o2 = 0; o2 < i2.children.length; o2++) {
              var s2 = i2.children[o2], l2 = f(s2), u2 = (m2 = t2, c2 = s2, (Math.max(c2.maxX, m2.maxX) - Math.min(c2.minX, m2.minX)) * (Math.max(c2.maxY, m2.maxY) - Math.min(c2.minY, m2.minY)) - l2);
              u2 < a2 ? (a2 = u2, e3 = l2 < e3 ? l2 : e3, h2 = s2) : u2 === a2 && l2 < e3 && (e3 = l2, h2 = s2);
            }
            i2 = h2 || i2.children[0];
          }
          var m2, c2;
          return i2;
        }, r.prototype._insert = function(t2, i2, n2) {
          var r2 = n2 ? t2 : this.toBBox(t2), e3 = [], a2 = this._chooseSubtree(r2, this.data, i2, e3);
          for (a2.children.push(t2), o(a2, r2); i2 >= 0 && e3[i2].children.length > this._maxEntries; )
            this._split(e3, i2), i2--;
          this._adjustParentBBoxes(r2, e3, i2);
        }, r.prototype._split = function(t2, i2) {
          var n2 = t2[i2], r2 = n2.children.length, e3 = this._minEntries;
          this._chooseSplitAxis(n2, e3, r2);
          var h2 = this._chooseSplitIndex(n2, e3, r2), o2 = p(n2.children.splice(h2, n2.children.length - h2));
          o2.height = n2.height, o2.leaf = n2.leaf, a(n2, this.toBBox), a(o2, this.toBBox), i2 ? t2[i2 - 1].children.push(o2) : this._splitRoot(n2, o2);
        }, r.prototype._splitRoot = function(t2, i2) {
          this.data = p([t2, i2]), this.data.height = t2.height + 1, this.data.leaf = false, a(this.data, this.toBBox);
        }, r.prototype._chooseSplitIndex = function(t2, i2, n2) {
          for (var r2, e3, a2, o2, s2, l2, u2, m2 = 1 / 0, c2 = 1 / 0, p2 = i2; p2 <= n2 - i2; p2++) {
            var d2 = h(t2, 0, p2, this.toBBox), x2 = h(t2, p2, n2, this.toBBox), v = (e3 = d2, a2 = x2, o2 = void 0, s2 = void 0, l2 = void 0, u2 = void 0, o2 = Math.max(e3.minX, a2.minX), s2 = Math.max(e3.minY, a2.minY), l2 = Math.min(e3.maxX, a2.maxX), u2 = Math.min(e3.maxY, a2.maxY), Math.max(0, l2 - o2) * Math.max(0, u2 - s2)), M = f(d2) + f(x2);
            v < m2 ? (m2 = v, r2 = p2, c2 = M < c2 ? M : c2) : v === m2 && M < c2 && (c2 = M, r2 = p2);
          }
          return r2 || n2 - i2;
        }, r.prototype._chooseSplitAxis = function(t2, i2, n2) {
          var r2 = t2.leaf ? this.compareMinX : s, e3 = t2.leaf ? this.compareMinY : l;
          this._allDistMargin(t2, i2, n2, r2) < this._allDistMargin(t2, i2, n2, e3) && t2.children.sort(r2);
        }, r.prototype._allDistMargin = function(t2, i2, n2, r2) {
          t2.children.sort(r2);
          for (var e3 = this.toBBox, a2 = h(t2, 0, i2, e3), s2 = h(t2, n2 - i2, n2, e3), l2 = u(a2) + u(s2), f2 = i2; f2 < n2 - i2; f2++) {
            var m2 = t2.children[f2];
            o(a2, t2.leaf ? e3(m2) : m2), l2 += u(a2);
          }
          for (var c2 = n2 - i2 - 1; c2 >= i2; c2--) {
            var p2 = t2.children[c2];
            o(s2, t2.leaf ? e3(p2) : p2), l2 += u(s2);
          }
          return l2;
        }, r.prototype._adjustParentBBoxes = function(t2, i2, n2) {
          for (var r2 = n2; r2 >= 0; r2--)
            o(i2[r2], t2);
        }, r.prototype._condense = function(t2) {
          for (var i2 = t2.length - 1, n2 = void 0; i2 >= 0; i2--)
            0 === t2[i2].children.length ? i2 > 0 ? (n2 = t2[i2 - 1].children).splice(n2.indexOf(t2[i2]), 1) : this.clear() : a(t2[i2], this.toBBox);
        }, r;
      });
    }
  });

  // node_modules/@turf/helpers/dist/js/index.js
  var require_js = __commonJS({
    "node_modules/@turf/helpers/dist/js/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.earthRadius = 63710088e-1;
      exports.factors = {
        centimeters: exports.earthRadius * 100,
        centimetres: exports.earthRadius * 100,
        degrees: exports.earthRadius / 111325,
        feet: exports.earthRadius * 3.28084,
        inches: exports.earthRadius * 39.37,
        kilometers: exports.earthRadius / 1e3,
        kilometres: exports.earthRadius / 1e3,
        meters: exports.earthRadius,
        metres: exports.earthRadius,
        miles: exports.earthRadius / 1609.344,
        millimeters: exports.earthRadius * 1e3,
        millimetres: exports.earthRadius * 1e3,
        nauticalmiles: exports.earthRadius / 1852,
        radians: 1,
        yards: exports.earthRadius * 1.0936
      };
      exports.unitsFactors = {
        centimeters: 100,
        centimetres: 100,
        degrees: 1 / 111325,
        feet: 3.28084,
        inches: 39.37,
        kilometers: 1 / 1e3,
        kilometres: 1 / 1e3,
        meters: 1,
        metres: 1,
        miles: 1 / 1609.344,
        millimeters: 1e3,
        millimetres: 1e3,
        nauticalmiles: 1 / 1852,
        radians: 1 / exports.earthRadius,
        yards: 1.0936133
      };
      exports.areaFactors = {
        acres: 247105e-9,
        centimeters: 1e4,
        centimetres: 1e4,
        feet: 10.763910417,
        hectares: 1e-4,
        inches: 1550.003100006,
        kilometers: 1e-6,
        kilometres: 1e-6,
        meters: 1,
        metres: 1,
        miles: 386e-9,
        millimeters: 1e6,
        millimetres: 1e6,
        yards: 1.195990046
      };
      function feature2(geom, properties, options) {
        if (options === void 0) {
          options = {};
        }
        var feat = { type: "Feature" };
        if (options.id === 0 || options.id) {
          feat.id = options.id;
        }
        if (options.bbox) {
          feat.bbox = options.bbox;
        }
        feat.properties = properties || {};
        feat.geometry = geom;
        return feat;
      }
      exports.feature = feature2;
      function geometry(type, coordinates, _options) {
        if (_options === void 0) {
          _options = {};
        }
        switch (type) {
          case "Point":
            return point2(coordinates).geometry;
          case "LineString":
            return lineString2(coordinates).geometry;
          case "Polygon":
            return polygon2(coordinates).geometry;
          case "MultiPoint":
            return multiPoint2(coordinates).geometry;
          case "MultiLineString":
            return multiLineString2(coordinates).geometry;
          case "MultiPolygon":
            return multiPolygon2(coordinates).geometry;
          default:
            throw new Error(type + " is invalid");
        }
      }
      exports.geometry = geometry;
      function point2(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        if (!coordinates) {
          throw new Error("coordinates is required");
        }
        if (!Array.isArray(coordinates)) {
          throw new Error("coordinates must be an Array");
        }
        if (coordinates.length < 2) {
          throw new Error("coordinates must be at least 2 numbers long");
        }
        if (!isNumber2(coordinates[0]) || !isNumber2(coordinates[1])) {
          throw new Error("coordinates must contain numbers");
        }
        var geom = {
          type: "Point",
          coordinates
        };
        return feature2(geom, properties, options);
      }
      exports.point = point2;
      function points(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        return featureCollection2(coordinates.map(function(coords) {
          return point2(coords, properties);
        }), options);
      }
      exports.points = points;
      function polygon2(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {
          var ring = coordinates_1[_i];
          if (ring.length < 4) {
            throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
          }
          for (var j = 0; j < ring[ring.length - 1].length; j++) {
            if (ring[ring.length - 1][j] !== ring[0][j]) {
              throw new Error("First and last Position are not equivalent.");
            }
          }
        }
        var geom = {
          type: "Polygon",
          coordinates
        };
        return feature2(geom, properties, options);
      }
      exports.polygon = polygon2;
      function polygons(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        return featureCollection2(coordinates.map(function(coords) {
          return polygon2(coords, properties);
        }), options);
      }
      exports.polygons = polygons;
      function lineString2(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        if (coordinates.length < 2) {
          throw new Error("coordinates must be an array of two or more positions");
        }
        var geom = {
          type: "LineString",
          coordinates
        };
        return feature2(geom, properties, options);
      }
      exports.lineString = lineString2;
      function lineStrings(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        return featureCollection2(coordinates.map(function(coords) {
          return lineString2(coords, properties);
        }), options);
      }
      exports.lineStrings = lineStrings;
      function featureCollection2(features, options) {
        if (options === void 0) {
          options = {};
        }
        var fc = { type: "FeatureCollection" };
        if (options.id) {
          fc.id = options.id;
        }
        if (options.bbox) {
          fc.bbox = options.bbox;
        }
        fc.features = features;
        return fc;
      }
      exports.featureCollection = featureCollection2;
      function multiLineString2(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        var geom = {
          type: "MultiLineString",
          coordinates
        };
        return feature2(geom, properties, options);
      }
      exports.multiLineString = multiLineString2;
      function multiPoint2(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        var geom = {
          type: "MultiPoint",
          coordinates
        };
        return feature2(geom, properties, options);
      }
      exports.multiPoint = multiPoint2;
      function multiPolygon2(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        var geom = {
          type: "MultiPolygon",
          coordinates
        };
        return feature2(geom, properties, options);
      }
      exports.multiPolygon = multiPolygon2;
      function geometryCollection2(geometries, properties, options) {
        if (options === void 0) {
          options = {};
        }
        var geom = {
          type: "GeometryCollection",
          geometries
        };
        return feature2(geom, properties, options);
      }
      exports.geometryCollection = geometryCollection2;
      function round(num, precision) {
        if (precision === void 0) {
          precision = 0;
        }
        if (precision && !(precision >= 0)) {
          throw new Error("precision must be a positive number");
        }
        var multiplier = Math.pow(10, precision || 0);
        return Math.round(num * multiplier) / multiplier;
      }
      exports.round = round;
      function radiansToLength2(radians3, units) {
        if (units === void 0) {
          units = "kilometers";
        }
        var factor = exports.factors[units];
        if (!factor) {
          throw new Error(units + " units is invalid");
        }
        return radians3 * factor;
      }
      exports.radiansToLength = radiansToLength2;
      function lengthToRadians2(distance2, units) {
        if (units === void 0) {
          units = "kilometers";
        }
        var factor = exports.factors[units];
        if (!factor) {
          throw new Error(units + " units is invalid");
        }
        return distance2 / factor;
      }
      exports.lengthToRadians = lengthToRadians2;
      function lengthToDegrees2(distance2, units) {
        return radiansToDegrees2(lengthToRadians2(distance2, units));
      }
      exports.lengthToDegrees = lengthToDegrees2;
      function bearingToAzimuth2(bearing2) {
        var angle2 = bearing2 % 360;
        if (angle2 < 0) {
          angle2 += 360;
        }
        return angle2;
      }
      exports.bearingToAzimuth = bearingToAzimuth2;
      function radiansToDegrees2(radians3) {
        var degrees3 = radians3 % (2 * Math.PI);
        return degrees3 * 180 / Math.PI;
      }
      exports.radiansToDegrees = radiansToDegrees2;
      function degreesToRadians2(degrees3) {
        var radians3 = degrees3 % 360;
        return radians3 * Math.PI / 180;
      }
      exports.degreesToRadians = degreesToRadians2;
      function convertLength2(length2, originalUnit, finalUnit) {
        if (originalUnit === void 0) {
          originalUnit = "kilometers";
        }
        if (finalUnit === void 0) {
          finalUnit = "kilometers";
        }
        if (!(length2 >= 0)) {
          throw new Error("length must be a positive number");
        }
        return radiansToLength2(lengthToRadians2(length2, originalUnit), finalUnit);
      }
      exports.convertLength = convertLength2;
      function convertArea(area2, originalUnit, finalUnit) {
        if (originalUnit === void 0) {
          originalUnit = "meters";
        }
        if (finalUnit === void 0) {
          finalUnit = "kilometers";
        }
        if (!(area2 >= 0)) {
          throw new Error("area must be a positive number");
        }
        var startFactor = exports.areaFactors[originalUnit];
        if (!startFactor) {
          throw new Error("invalid original units");
        }
        var finalFactor = exports.areaFactors[finalUnit];
        if (!finalFactor) {
          throw new Error("invalid final units");
        }
        return area2 / startFactor * finalFactor;
      }
      exports.convertArea = convertArea;
      function isNumber2(num) {
        return !isNaN(num) && num !== null && !Array.isArray(num);
      }
      exports.isNumber = isNumber2;
      function isObject2(input) {
        return !!input && input.constructor === Object;
      }
      exports.isObject = isObject2;
      function validateBBox(bbox3) {
        if (!bbox3) {
          throw new Error("bbox is required");
        }
        if (!Array.isArray(bbox3)) {
          throw new Error("bbox must be an Array");
        }
        if (bbox3.length !== 4 && bbox3.length !== 6) {
          throw new Error("bbox must be an Array of 4 or 6 numbers");
        }
        bbox3.forEach(function(num) {
          if (!isNumber2(num)) {
            throw new Error("bbox must only contain numbers");
          }
        });
      }
      exports.validateBBox = validateBBox;
      function validateId(id) {
        if (!id) {
          throw new Error("id is required");
        }
        if (["string", "number"].indexOf(typeof id) === -1) {
          throw new Error("id must be a number or a string");
        }
      }
      exports.validateId = validateId;
    }
  });

  // node_modules/@turf/meta/dist/js/index.js
  var require_js2 = __commonJS({
    "node_modules/@turf/meta/dist/js/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var helpers = require_js();
      function coordEach2(geojson, callback, excludeWrapCoord) {
        if (geojson === null)
          return;
        var j, k, l, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === "FeatureCollection", isFeature = type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
        for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
          geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;
          isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
          stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
          for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
            var multiFeatureIndex = 0;
            var geometryIndex = 0;
            geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;
            if (geometry === null)
              continue;
            coords = geometry.coordinates;
            var geomType = geometry.type;
            wrapShrink = excludeWrapCoord && (geomType === "Polygon" || geomType === "MultiPolygon") ? 1 : 0;
            switch (geomType) {
              case null:
                break;
              case "Point":
                if (callback(
                  coords,
                  coordIndex,
                  featureIndex,
                  multiFeatureIndex,
                  geometryIndex
                ) === false)
                  return false;
                coordIndex++;
                multiFeatureIndex++;
                break;
              case "LineString":
              case "MultiPoint":
                for (j = 0; j < coords.length; j++) {
                  if (callback(
                    coords[j],
                    coordIndex,
                    featureIndex,
                    multiFeatureIndex,
                    geometryIndex
                  ) === false)
                    return false;
                  coordIndex++;
                  if (geomType === "MultiPoint")
                    multiFeatureIndex++;
                }
                if (geomType === "LineString")
                  multiFeatureIndex++;
                break;
              case "Polygon":
              case "MultiLineString":
                for (j = 0; j < coords.length; j++) {
                  for (k = 0; k < coords[j].length - wrapShrink; k++) {
                    if (callback(
                      coords[j][k],
                      coordIndex,
                      featureIndex,
                      multiFeatureIndex,
                      geometryIndex
                    ) === false)
                      return false;
                    coordIndex++;
                  }
                  if (geomType === "MultiLineString")
                    multiFeatureIndex++;
                  if (geomType === "Polygon")
                    geometryIndex++;
                }
                if (geomType === "Polygon")
                  multiFeatureIndex++;
                break;
              case "MultiPolygon":
                for (j = 0; j < coords.length; j++) {
                  geometryIndex = 0;
                  for (k = 0; k < coords[j].length; k++) {
                    for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                      if (callback(
                        coords[j][k][l],
                        coordIndex,
                        featureIndex,
                        multiFeatureIndex,
                        geometryIndex
                      ) === false)
                        return false;
                      coordIndex++;
                    }
                    geometryIndex++;
                  }
                  multiFeatureIndex++;
                }
                break;
              case "GeometryCollection":
                for (j = 0; j < geometry.geometries.length; j++)
                  if (coordEach2(geometry.geometries[j], callback, excludeWrapCoord) === false)
                    return false;
                break;
              default:
                throw new Error("Unknown Geometry Type");
            }
          }
        }
      }
      function coordReduce2(geojson, callback, initialValue, excludeWrapCoord) {
        var previousValue = initialValue;
        coordEach2(
          geojson,
          function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
            if (coordIndex === 0 && initialValue === void 0)
              previousValue = currentCoord;
            else
              previousValue = callback(
                previousValue,
                currentCoord,
                coordIndex,
                featureIndex,
                multiFeatureIndex,
                geometryIndex
              );
          },
          excludeWrapCoord
        );
        return previousValue;
      }
      function propEach(geojson, callback) {
        var i;
        switch (geojson.type) {
          case "FeatureCollection":
            for (i = 0; i < geojson.features.length; i++) {
              if (callback(geojson.features[i].properties, i) === false)
                break;
            }
            break;
          case "Feature":
            callback(geojson.properties, 0);
            break;
        }
      }
      function propReduce(geojson, callback, initialValue) {
        var previousValue = initialValue;
        propEach(geojson, function(currentProperties, featureIndex) {
          if (featureIndex === 0 && initialValue === void 0)
            previousValue = currentProperties;
          else
            previousValue = callback(previousValue, currentProperties, featureIndex);
        });
        return previousValue;
      }
      function featureEach2(geojson, callback) {
        if (geojson.type === "Feature") {
          callback(geojson, 0);
        } else if (geojson.type === "FeatureCollection") {
          for (var i = 0; i < geojson.features.length; i++) {
            if (callback(geojson.features[i], i) === false)
              break;
          }
        }
      }
      function featureReduce2(geojson, callback, initialValue) {
        var previousValue = initialValue;
        featureEach2(geojson, function(currentFeature, featureIndex) {
          if (featureIndex === 0 && initialValue === void 0)
            previousValue = currentFeature;
          else
            previousValue = callback(previousValue, currentFeature, featureIndex);
        });
        return previousValue;
      }
      function coordAll2(geojson) {
        var coords = [];
        coordEach2(geojson, function(coord) {
          coords.push(coord);
        });
        return coords;
      }
      function geomEach2(geojson, callback) {
        var i, j, g, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === "FeatureCollection", isFeature = geojson.type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
        for (i = 0; i < stop; i++) {
          geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;
          featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};
          featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;
          featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;
          isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
          stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
          for (g = 0; g < stopG; g++) {
            geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;
            if (geometry === null) {
              if (callback(
                null,
                featureIndex,
                featureProperties,
                featureBBox,
                featureId
              ) === false)
                return false;
              continue;
            }
            switch (geometry.type) {
              case "Point":
              case "LineString":
              case "MultiPoint":
              case "Polygon":
              case "MultiLineString":
              case "MultiPolygon": {
                if (callback(
                  geometry,
                  featureIndex,
                  featureProperties,
                  featureBBox,
                  featureId
                ) === false)
                  return false;
                break;
              }
              case "GeometryCollection": {
                for (j = 0; j < geometry.geometries.length; j++) {
                  if (callback(
                    geometry.geometries[j],
                    featureIndex,
                    featureProperties,
                    featureBBox,
                    featureId
                  ) === false)
                    return false;
                }
                break;
              }
              default:
                throw new Error("Unknown Geometry Type");
            }
          }
          featureIndex++;
        }
      }
      function geomReduce2(geojson, callback, initialValue) {
        var previousValue = initialValue;
        geomEach2(
          geojson,
          function(currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
            if (featureIndex === 0 && initialValue === void 0)
              previousValue = currentGeometry;
            else
              previousValue = callback(
                previousValue,
                currentGeometry,
                featureIndex,
                featureProperties,
                featureBBox,
                featureId
              );
          }
        );
        return previousValue;
      }
      function flattenEach2(geojson, callback) {
        geomEach2(geojson, function(geometry, featureIndex, properties, bbox3, id) {
          var type = geometry === null ? null : geometry.type;
          switch (type) {
            case null:
            case "Point":
            case "LineString":
            case "Polygon":
              if (callback(
                helpers.feature(geometry, properties, { bbox: bbox3, id }),
                featureIndex,
                0
              ) === false)
                return false;
              return;
          }
          var geomType;
          switch (type) {
            case "MultiPoint":
              geomType = "Point";
              break;
            case "MultiLineString":
              geomType = "LineString";
              break;
            case "MultiPolygon":
              geomType = "Polygon";
              break;
          }
          for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {
            var coordinate = geometry.coordinates[multiFeatureIndex];
            var geom = {
              type: geomType,
              coordinates: coordinate
            };
            if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false)
              return false;
          }
        });
      }
      function flattenReduce(geojson, callback, initialValue) {
        var previousValue = initialValue;
        flattenEach2(
          geojson,
          function(currentFeature, featureIndex, multiFeatureIndex) {
            if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === void 0)
              previousValue = currentFeature;
            else
              previousValue = callback(
                previousValue,
                currentFeature,
                featureIndex,
                multiFeatureIndex
              );
          }
        );
        return previousValue;
      }
      function segmentEach2(geojson, callback) {
        flattenEach2(geojson, function(feature2, featureIndex, multiFeatureIndex) {
          var segmentIndex = 0;
          if (!feature2.geometry)
            return;
          var type = feature2.geometry.type;
          if (type === "Point" || type === "MultiPoint")
            return;
          var previousCoords;
          var previousFeatureIndex = 0;
          var previousMultiIndex = 0;
          var prevGeomIndex = 0;
          if (coordEach2(
            feature2,
            function(currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {
              if (previousCoords === void 0 || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {
                previousCoords = currentCoord;
                previousFeatureIndex = featureIndex;
                previousMultiIndex = multiPartIndexCoord;
                prevGeomIndex = geometryIndex;
                segmentIndex = 0;
                return;
              }
              var currentSegment = helpers.lineString(
                [previousCoords, currentCoord],
                feature2.properties
              );
              if (callback(
                currentSegment,
                featureIndex,
                multiFeatureIndex,
                geometryIndex,
                segmentIndex
              ) === false)
                return false;
              segmentIndex++;
              previousCoords = currentCoord;
            }
          ) === false)
            return false;
        });
      }
      function segmentReduce2(geojson, callback, initialValue) {
        var previousValue = initialValue;
        var started = false;
        segmentEach2(
          geojson,
          function(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
            if (started === false && initialValue === void 0)
              previousValue = currentSegment;
            else
              previousValue = callback(
                previousValue,
                currentSegment,
                featureIndex,
                multiFeatureIndex,
                geometryIndex,
                segmentIndex
              );
            started = true;
          }
        );
        return previousValue;
      }
      function lineEach(geojson, callback) {
        if (!geojson)
          throw new Error("geojson is required");
        flattenEach2(geojson, function(feature2, featureIndex, multiFeatureIndex) {
          if (feature2.geometry === null)
            return;
          var type = feature2.geometry.type;
          var coords = feature2.geometry.coordinates;
          switch (type) {
            case "LineString":
              if (callback(feature2, featureIndex, multiFeatureIndex, 0, 0) === false)
                return false;
              break;
            case "Polygon":
              for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {
                if (callback(
                  helpers.lineString(coords[geometryIndex], feature2.properties),
                  featureIndex,
                  multiFeatureIndex,
                  geometryIndex
                ) === false)
                  return false;
              }
              break;
          }
        });
      }
      function lineReduce2(geojson, callback, initialValue) {
        var previousValue = initialValue;
        lineEach(
          geojson,
          function(currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
            if (featureIndex === 0 && initialValue === void 0)
              previousValue = currentLine;
            else
              previousValue = callback(
                previousValue,
                currentLine,
                featureIndex,
                multiFeatureIndex,
                geometryIndex
              );
          }
        );
        return previousValue;
      }
      function findSegment(geojson, options) {
        options = options || {};
        if (!helpers.isObject(options))
          throw new Error("options is invalid");
        var featureIndex = options.featureIndex || 0;
        var multiFeatureIndex = options.multiFeatureIndex || 0;
        var geometryIndex = options.geometryIndex || 0;
        var segmentIndex = options.segmentIndex || 0;
        var properties = options.properties;
        var geometry;
        switch (geojson.type) {
          case "FeatureCollection":
            if (featureIndex < 0)
              featureIndex = geojson.features.length + featureIndex;
            properties = properties || geojson.features[featureIndex].properties;
            geometry = geojson.features[featureIndex].geometry;
            break;
          case "Feature":
            properties = properties || geojson.properties;
            geometry = geojson.geometry;
            break;
          case "Point":
          case "MultiPoint":
            return null;
          case "LineString":
          case "Polygon":
          case "MultiLineString":
          case "MultiPolygon":
            geometry = geojson;
            break;
          default:
            throw new Error("geojson is invalid");
        }
        if (geometry === null)
          return null;
        var coords = geometry.coordinates;
        switch (geometry.type) {
          case "Point":
          case "MultiPoint":
            return null;
          case "LineString":
            if (segmentIndex < 0)
              segmentIndex = coords.length + segmentIndex - 1;
            return helpers.lineString(
              [coords[segmentIndex], coords[segmentIndex + 1]],
              properties,
              options
            );
          case "Polygon":
            if (geometryIndex < 0)
              geometryIndex = coords.length + geometryIndex;
            if (segmentIndex < 0)
              segmentIndex = coords[geometryIndex].length + segmentIndex - 1;
            return helpers.lineString(
              [
                coords[geometryIndex][segmentIndex],
                coords[geometryIndex][segmentIndex + 1]
              ],
              properties,
              options
            );
          case "MultiLineString":
            if (multiFeatureIndex < 0)
              multiFeatureIndex = coords.length + multiFeatureIndex;
            if (segmentIndex < 0)
              segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;
            return helpers.lineString(
              [
                coords[multiFeatureIndex][segmentIndex],
                coords[multiFeatureIndex][segmentIndex + 1]
              ],
              properties,
              options
            );
          case "MultiPolygon":
            if (multiFeatureIndex < 0)
              multiFeatureIndex = coords.length + multiFeatureIndex;
            if (geometryIndex < 0)
              geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
            if (segmentIndex < 0)
              segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;
            return helpers.lineString(
              [
                coords[multiFeatureIndex][geometryIndex][segmentIndex],
                coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]
              ],
              properties,
              options
            );
        }
        throw new Error("geojson is invalid");
      }
      function findPoint(geojson, options) {
        options = options || {};
        if (!helpers.isObject(options))
          throw new Error("options is invalid");
        var featureIndex = options.featureIndex || 0;
        var multiFeatureIndex = options.multiFeatureIndex || 0;
        var geometryIndex = options.geometryIndex || 0;
        var coordIndex = options.coordIndex || 0;
        var properties = options.properties;
        var geometry;
        switch (geojson.type) {
          case "FeatureCollection":
            if (featureIndex < 0)
              featureIndex = geojson.features.length + featureIndex;
            properties = properties || geojson.features[featureIndex].properties;
            geometry = geojson.features[featureIndex].geometry;
            break;
          case "Feature":
            properties = properties || geojson.properties;
            geometry = geojson.geometry;
            break;
          case "Point":
          case "MultiPoint":
            return null;
          case "LineString":
          case "Polygon":
          case "MultiLineString":
          case "MultiPolygon":
            geometry = geojson;
            break;
          default:
            throw new Error("geojson is invalid");
        }
        if (geometry === null)
          return null;
        var coords = geometry.coordinates;
        switch (geometry.type) {
          case "Point":
            return helpers.point(coords, properties, options);
          case "MultiPoint":
            if (multiFeatureIndex < 0)
              multiFeatureIndex = coords.length + multiFeatureIndex;
            return helpers.point(coords[multiFeatureIndex], properties, options);
          case "LineString":
            if (coordIndex < 0)
              coordIndex = coords.length + coordIndex;
            return helpers.point(coords[coordIndex], properties, options);
          case "Polygon":
            if (geometryIndex < 0)
              geometryIndex = coords.length + geometryIndex;
            if (coordIndex < 0)
              coordIndex = coords[geometryIndex].length + coordIndex;
            return helpers.point(coords[geometryIndex][coordIndex], properties, options);
          case "MultiLineString":
            if (multiFeatureIndex < 0)
              multiFeatureIndex = coords.length + multiFeatureIndex;
            if (coordIndex < 0)
              coordIndex = coords[multiFeatureIndex].length + coordIndex;
            return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);
          case "MultiPolygon":
            if (multiFeatureIndex < 0)
              multiFeatureIndex = coords.length + multiFeatureIndex;
            if (geometryIndex < 0)
              geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
            if (coordIndex < 0)
              coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;
            return helpers.point(
              coords[multiFeatureIndex][geometryIndex][coordIndex],
              properties,
              options
            );
        }
        throw new Error("geojson is invalid");
      }
      exports.coordAll = coordAll2;
      exports.coordEach = coordEach2;
      exports.coordReduce = coordReduce2;
      exports.featureEach = featureEach2;
      exports.featureReduce = featureReduce2;
      exports.findPoint = findPoint;
      exports.findSegment = findSegment;
      exports.flattenEach = flattenEach2;
      exports.flattenReduce = flattenReduce;
      exports.geomEach = geomEach2;
      exports.geomReduce = geomReduce2;
      exports.lineEach = lineEach;
      exports.lineReduce = lineReduce2;
      exports.propEach = propEach;
      exports.propReduce = propReduce;
      exports.segmentEach = segmentEach2;
      exports.segmentReduce = segmentReduce2;
    }
  });

  // node_modules/@turf/bbox/dist/js/index.js
  var require_js3 = __commonJS({
    "node_modules/@turf/bbox/dist/js/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var meta_1 = require_js2();
      function bbox3(geojson) {
        var result = [Infinity, Infinity, -Infinity, -Infinity];
        meta_1.coordEach(geojson, function(coord) {
          if (result[0] > coord[0]) {
            result[0] = coord[0];
          }
          if (result[1] > coord[1]) {
            result[1] = coord[1];
          }
          if (result[2] < coord[0]) {
            result[2] = coord[0];
          }
          if (result[3] < coord[1]) {
            result[3] = coord[1];
          }
        });
        return result;
      }
      bbox3["default"] = bbox3;
      exports.default = bbox3;
    }
  });

  // node_modules/geojson-rbush/index.js
  var require_geojson_rbush = __commonJS({
    "node_modules/geojson-rbush/index.js"(exports, module) {
      var rbush6 = require_rbush_min();
      var helpers = require_js();
      var meta = require_js2();
      var turfBBox = require_js3().default;
      var featureEach2 = meta.featureEach;
      var coordEach2 = meta.coordEach;
      var polygon2 = helpers.polygon;
      var featureCollection2 = helpers.featureCollection;
      function geojsonRbush(maxEntries) {
        var tree = new rbush6(maxEntries);
        tree.insert = function(feature2) {
          if (feature2.type !== "Feature")
            throw new Error("invalid feature");
          feature2.bbox = feature2.bbox ? feature2.bbox : turfBBox(feature2);
          return rbush6.prototype.insert.call(this, feature2);
        };
        tree.load = function(features) {
          var load = [];
          if (Array.isArray(features)) {
            features.forEach(function(feature2) {
              if (feature2.type !== "Feature")
                throw new Error("invalid features");
              feature2.bbox = feature2.bbox ? feature2.bbox : turfBBox(feature2);
              load.push(feature2);
            });
          } else {
            featureEach2(features, function(feature2) {
              if (feature2.type !== "Feature")
                throw new Error("invalid features");
              feature2.bbox = feature2.bbox ? feature2.bbox : turfBBox(feature2);
              load.push(feature2);
            });
          }
          return rbush6.prototype.load.call(this, load);
        };
        tree.remove = function(feature2, equals) {
          if (feature2.type !== "Feature")
            throw new Error("invalid feature");
          feature2.bbox = feature2.bbox ? feature2.bbox : turfBBox(feature2);
          return rbush6.prototype.remove.call(this, feature2, equals);
        };
        tree.clear = function() {
          return rbush6.prototype.clear.call(this);
        };
        tree.search = function(geojson) {
          var features = rbush6.prototype.search.call(this, this.toBBox(geojson));
          return featureCollection2(features);
        };
        tree.collides = function(geojson) {
          return rbush6.prototype.collides.call(this, this.toBBox(geojson));
        };
        tree.all = function() {
          var features = rbush6.prototype.all.call(this);
          return featureCollection2(features);
        };
        tree.toJSON = function() {
          return rbush6.prototype.toJSON.call(this);
        };
        tree.fromJSON = function(json) {
          return rbush6.prototype.fromJSON.call(this, json);
        };
        tree.toBBox = function(geojson) {
          var bbox3;
          if (geojson.bbox)
            bbox3 = geojson.bbox;
          else if (Array.isArray(geojson) && geojson.length === 4)
            bbox3 = geojson;
          else if (Array.isArray(geojson) && geojson.length === 6)
            bbox3 = [geojson[0], geojson[1], geojson[3], geojson[4]];
          else if (geojson.type === "Feature")
            bbox3 = turfBBox(geojson);
          else if (geojson.type === "FeatureCollection")
            bbox3 = turfBBox(geojson);
          else
            throw new Error("invalid geojson");
          return {
            minX: bbox3[0],
            minY: bbox3[1],
            maxX: bbox3[2],
            maxY: bbox3[3]
          };
        };
        return tree;
      }
      module.exports = geojsonRbush;
      module.exports.default = geojsonRbush;
    }
  });

  // node_modules/fp-ts/lib/function.js
  var require_function = __commonJS({
    "node_modules/fp-ts/lib/function.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getEndomorphismMonoid = exports.not = exports.SK = exports.hole = exports.pipe = exports.untupled = exports.tupled = exports.absurd = exports.decrement = exports.increment = exports.tuple = exports.flow = exports.flip = exports.constVoid = exports.constUndefined = exports.constNull = exports.constFalse = exports.constTrue = exports.constant = exports.unsafeCoerce = exports.identity = exports.apply = exports.getRing = exports.getSemiring = exports.getMonoid = exports.getSemigroup = exports.getBooleanAlgebra = void 0;
      var getBooleanAlgebra = function(B2) {
        return function() {
          return {
            meet: function(x2, y2) {
              return function(a) {
                return B2.meet(x2(a), y2(a));
              };
            },
            join: function(x2, y2) {
              return function(a) {
                return B2.join(x2(a), y2(a));
              };
            },
            zero: function() {
              return B2.zero;
            },
            one: function() {
              return B2.one;
            },
            implies: function(x2, y2) {
              return function(a) {
                return B2.implies(x2(a), y2(a));
              };
            },
            not: function(x2) {
              return function(a) {
                return B2.not(x2(a));
              };
            }
          };
        };
      };
      exports.getBooleanAlgebra = getBooleanAlgebra;
      var getSemigroup = function(S) {
        return function() {
          return {
            concat: function(f, g) {
              return function(a) {
                return S.concat(f(a), g(a));
              };
            }
          };
        };
      };
      exports.getSemigroup = getSemigroup;
      var getMonoid = function(M) {
        var getSemigroupM = exports.getSemigroup(M);
        return function() {
          return {
            concat: getSemigroupM().concat,
            empty: function() {
              return M.empty;
            }
          };
        };
      };
      exports.getMonoid = getMonoid;
      var getSemiring = function(S) {
        return {
          add: function(f, g) {
            return function(x2) {
              return S.add(f(x2), g(x2));
            };
          },
          zero: function() {
            return S.zero;
          },
          mul: function(f, g) {
            return function(x2) {
              return S.mul(f(x2), g(x2));
            };
          },
          one: function() {
            return S.one;
          }
        };
      };
      exports.getSemiring = getSemiring;
      var getRing = function(R) {
        var S = exports.getSemiring(R);
        return {
          add: S.add,
          mul: S.mul,
          one: S.one,
          zero: S.zero,
          sub: function(f, g) {
            return function(x2) {
              return R.sub(f(x2), g(x2));
            };
          }
        };
      };
      exports.getRing = getRing;
      var apply = function(a) {
        return function(f) {
          return f(a);
        };
      };
      exports.apply = apply;
      function identity(a) {
        return a;
      }
      exports.identity = identity;
      exports.unsafeCoerce = identity;
      function constant(a) {
        return function() {
          return a;
        };
      }
      exports.constant = constant;
      exports.constTrue = /* @__PURE__ */ constant(true);
      exports.constFalse = /* @__PURE__ */ constant(false);
      exports.constNull = /* @__PURE__ */ constant(null);
      exports.constUndefined = /* @__PURE__ */ constant(void 0);
      exports.constVoid = exports.constUndefined;
      function flip(f) {
        return function(b, a) {
          return f(a, b);
        };
      }
      exports.flip = flip;
      function flow2(ab, bc, cd, de, ef, fg, gh, hi, ij) {
        switch (arguments.length) {
          case 1:
            return ab;
          case 2:
            return function() {
              return bc(ab.apply(this, arguments));
            };
          case 3:
            return function() {
              return cd(bc(ab.apply(this, arguments)));
            };
          case 4:
            return function() {
              return de(cd(bc(ab.apply(this, arguments))));
            };
          case 5:
            return function() {
              return ef(de(cd(bc(ab.apply(this, arguments)))));
            };
          case 6:
            return function() {
              return fg(ef(de(cd(bc(ab.apply(this, arguments))))));
            };
          case 7:
            return function() {
              return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));
            };
          case 8:
            return function() {
              return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));
            };
          case 9:
            return function() {
              return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));
            };
        }
        return;
      }
      exports.flow = flow2;
      function tuple() {
        var t = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          t[_i] = arguments[_i];
        }
        return t;
      }
      exports.tuple = tuple;
      function increment(n) {
        return n + 1;
      }
      exports.increment = increment;
      function decrement(n) {
        return n - 1;
      }
      exports.decrement = decrement;
      function absurd(_) {
        throw new Error("Called `absurd` function which should be uncallable");
      }
      exports.absurd = absurd;
      function tupled(f) {
        return function(a) {
          return f.apply(void 0, a);
        };
      }
      exports.tupled = tupled;
      function untupled(f) {
        return function() {
          var a = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            a[_i] = arguments[_i];
          }
          return f(a);
        };
      }
      exports.untupled = untupled;
      function pipe3(a, ab, bc, cd, de, ef, fg, gh, hi) {
        switch (arguments.length) {
          case 1:
            return a;
          case 2:
            return ab(a);
          case 3:
            return bc(ab(a));
          case 4:
            return cd(bc(ab(a)));
          case 5:
            return de(cd(bc(ab(a))));
          case 6:
            return ef(de(cd(bc(ab(a)))));
          case 7:
            return fg(ef(de(cd(bc(ab(a))))));
          case 8:
            return gh(fg(ef(de(cd(bc(ab(a)))))));
          case 9:
            return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
          default:
            var ret = arguments[0];
            for (var i = 1; i < arguments.length; i++) {
              ret = arguments[i](ret);
            }
            return ret;
        }
      }
      exports.pipe = pipe3;
      exports.hole = absurd;
      var SK = function(_, b) {
        return b;
      };
      exports.SK = SK;
      function not(predicate) {
        return function(a) {
          return !predicate(a);
        };
      }
      exports.not = not;
      var getEndomorphismMonoid = function() {
        return {
          concat: function(first, second) {
            return flow2(first, second);
          },
          empty: identity
        };
      };
      exports.getEndomorphismMonoid = getEndomorphismMonoid;
    }
  });

  // node_modules/fp-ts/lib/Apply.js
  var require_Apply = __commonJS({
    "node_modules/fp-ts/lib/Apply.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sequenceS = exports.sequenceT = exports.getApplySemigroup = exports.apS = exports.apSecond = exports.apFirst = exports.ap = void 0;
      var function_1 = require_function();
      function ap(F, G) {
        return function(fa) {
          return function(fab) {
            return F.ap(F.map(fab, function(gab) {
              return function(ga) {
                return G.ap(gab, ga);
              };
            }), fa);
          };
        };
      }
      exports.ap = ap;
      function apFirst(A) {
        return function(second) {
          return function(first) {
            return A.ap(A.map(first, function(a) {
              return function() {
                return a;
              };
            }), second);
          };
        };
      }
      exports.apFirst = apFirst;
      function apSecond(A) {
        return function(second) {
          return function(first) {
            return A.ap(A.map(first, function() {
              return function(b) {
                return b;
              };
            }), second);
          };
        };
      }
      exports.apSecond = apSecond;
      function apS(F) {
        return function(name, fb) {
          return function(fa) {
            return F.ap(F.map(fa, function(a) {
              return function(b) {
                var _a;
                return Object.assign({}, a, (_a = {}, _a[name] = b, _a));
              };
            }), fb);
          };
        };
      }
      exports.apS = apS;
      function getApplySemigroup(F) {
        return function(S) {
          return {
            concat: function(first, second) {
              return F.ap(F.map(first, function(x2) {
                return function(y2) {
                  return S.concat(x2, y2);
                };
              }), second);
            }
          };
        };
      }
      exports.getApplySemigroup = getApplySemigroup;
      function curried(f, n, acc) {
        return function(x2) {
          var combined = Array(acc.length + 1);
          for (var i = 0; i < acc.length; i++) {
            combined[i] = acc[i];
          }
          combined[acc.length] = x2;
          return n === 0 ? f.apply(null, combined) : curried(f, n - 1, combined);
        };
      }
      var tupleConstructors = {
        1: function(a) {
          return [a];
        },
        2: function(a) {
          return function(b) {
            return [a, b];
          };
        },
        3: function(a) {
          return function(b) {
            return function(c) {
              return [a, b, c];
            };
          };
        },
        4: function(a) {
          return function(b) {
            return function(c) {
              return function(d) {
                return [a, b, c, d];
              };
            };
          };
        },
        5: function(a) {
          return function(b) {
            return function(c) {
              return function(d) {
                return function(e) {
                  return [a, b, c, d, e];
                };
              };
            };
          };
        }
      };
      function getTupleConstructor(len) {
        if (!tupleConstructors.hasOwnProperty(len)) {
          tupleConstructors[len] = curried(function_1.tuple, len - 1, []);
        }
        return tupleConstructors[len];
      }
      function sequenceT(F) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var len = args.length;
          var f = getTupleConstructor(len);
          var fas = F.map(args[0], f);
          for (var i = 1; i < len; i++) {
            fas = F.ap(fas, args[i]);
          }
          return fas;
        };
      }
      exports.sequenceT = sequenceT;
      function getRecordConstructor(keys) {
        var len = keys.length;
        switch (len) {
          case 1:
            return function(a) {
              var _a;
              return _a = {}, _a[keys[0]] = a, _a;
            };
          case 2:
            return function(a) {
              return function(b) {
                var _a;
                return _a = {}, _a[keys[0]] = a, _a[keys[1]] = b, _a;
              };
            };
          case 3:
            return function(a) {
              return function(b) {
                return function(c) {
                  var _a;
                  return _a = {}, _a[keys[0]] = a, _a[keys[1]] = b, _a[keys[2]] = c, _a;
                };
              };
            };
          case 4:
            return function(a) {
              return function(b) {
                return function(c) {
                  return function(d) {
                    var _a;
                    return _a = {}, _a[keys[0]] = a, _a[keys[1]] = b, _a[keys[2]] = c, _a[keys[3]] = d, _a;
                  };
                };
              };
            };
          case 5:
            return function(a) {
              return function(b) {
                return function(c) {
                  return function(d) {
                    return function(e) {
                      var _a;
                      return _a = {}, _a[keys[0]] = a, _a[keys[1]] = b, _a[keys[2]] = c, _a[keys[3]] = d, _a[keys[4]] = e, _a;
                    };
                  };
                };
              };
            };
          default:
            return curried(function() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              var r = {};
              for (var i = 0; i < len; i++) {
                r[keys[i]] = args[i];
              }
              return r;
            }, len - 1, []);
        }
      }
      function sequenceS(F) {
        return function(r) {
          var keys = Object.keys(r);
          var len = keys.length;
          var f = getRecordConstructor(keys);
          var fr = F.map(r[keys[0]], f);
          for (var i = 1; i < len; i++) {
            fr = F.ap(fr, r[keys[i]]);
          }
          return fr;
        };
      }
      exports.sequenceS = sequenceS;
    }
  });

  // node_modules/fp-ts/lib/Functor.js
  var require_Functor = __commonJS({
    "node_modules/fp-ts/lib/Functor.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getFunctorComposition = exports.bindTo = exports.flap = exports.map = void 0;
      var function_1 = require_function();
      function map5(F, G) {
        return function(f) {
          return function(fa) {
            return F.map(fa, function(ga) {
              return G.map(ga, f);
            });
          };
        };
      }
      exports.map = map5;
      function flap(F) {
        return function(a) {
          return function(fab) {
            return F.map(fab, function(f) {
              return f(a);
            });
          };
        };
      }
      exports.flap = flap;
      function bindTo(F) {
        return function(name) {
          return function(fa) {
            return F.map(fa, function(a) {
              var _a;
              return _a = {}, _a[name] = a, _a;
            });
          };
        };
      }
      exports.bindTo = bindTo;
      function getFunctorComposition(F, G) {
        var _map = map5(F, G);
        return {
          map: function(fga, f) {
            return function_1.pipe(fga, _map(f));
          }
        };
      }
      exports.getFunctorComposition = getFunctorComposition;
    }
  });

  // node_modules/fp-ts/lib/Applicative.js
  var require_Applicative = __commonJS({
    "node_modules/fp-ts/lib/Applicative.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getApplicativeComposition = exports.getApplicativeMonoid = void 0;
      var Apply_1 = require_Apply();
      var function_1 = require_function();
      var Functor_1 = require_Functor();
      function getApplicativeMonoid(F) {
        var f = Apply_1.getApplySemigroup(F);
        return function(M) {
          return {
            concat: f(M).concat,
            empty: F.of(M.empty)
          };
        };
      }
      exports.getApplicativeMonoid = getApplicativeMonoid;
      function getApplicativeComposition(F, G) {
        var map5 = Functor_1.getFunctorComposition(F, G).map;
        var _ap = Apply_1.ap(F, G);
        return {
          map: map5,
          of: function(a) {
            return F.of(G.of(a));
          },
          ap: function(fgab, fga) {
            return function_1.pipe(fgab, _ap(fga));
          }
        };
      }
      exports.getApplicativeComposition = getApplicativeComposition;
    }
  });

  // node_modules/fp-ts/lib/Chain.js
  var require_Chain = __commonJS({
    "node_modules/fp-ts/lib/Chain.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.bind = exports.chainFirst = void 0;
      function chainFirst(M) {
        return function(f) {
          return function(first) {
            return M.chain(first, function(a) {
              return M.map(f(a), function() {
                return a;
              });
            });
          };
        };
      }
      exports.chainFirst = chainFirst;
      function bind(M) {
        return function(name, f) {
          return function(ma) {
            return M.chain(ma, function(a) {
              return M.map(f(a), function(b) {
                var _a;
                return Object.assign({}, a, (_a = {}, _a[name] = b, _a));
              });
            });
          };
        };
      }
      exports.bind = bind;
    }
  });

  // node_modules/fp-ts/lib/internal.js
  var require_internal = __commonJS({
    "node_modules/fp-ts/lib/internal.js"(exports) {
      "use strict";
      var __spreadArray = exports && exports.__spreadArray || function(to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
          to[j] = from[i];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.fromReadonlyNonEmptyArray = exports.has = exports.emptyRecord = exports.emptyReadonlyArray = exports.tail = exports.head = exports.isNonEmpty = exports.singleton = exports.right = exports.left = exports.isRight = exports.isLeft = exports.some = exports.none = exports.isSome = exports.isNone = void 0;
      var isNone = function(fa) {
        return fa._tag === "None";
      };
      exports.isNone = isNone;
      var isSome2 = function(fa) {
        return fa._tag === "Some";
      };
      exports.isSome = isSome2;
      exports.none = { _tag: "None" };
      var some2 = function(a) {
        return { _tag: "Some", value: a };
      };
      exports.some = some2;
      var isLeft = function(ma) {
        return ma._tag === "Left";
      };
      exports.isLeft = isLeft;
      var isRight = function(ma) {
        return ma._tag === "Right";
      };
      exports.isRight = isRight;
      var left = function(e) {
        return { _tag: "Left", left: e };
      };
      exports.left = left;
      var right = function(a) {
        return { _tag: "Right", right: a };
      };
      exports.right = right;
      var singleton = function(a) {
        return [a];
      };
      exports.singleton = singleton;
      var isNonEmpty = function(as) {
        return as.length > 0;
      };
      exports.isNonEmpty = isNonEmpty;
      var head = function(as) {
        return as[0];
      };
      exports.head = head;
      var tail = function(as) {
        return as.slice(1);
      };
      exports.tail = tail;
      exports.emptyReadonlyArray = [];
      exports.emptyRecord = {};
      exports.has = Object.prototype.hasOwnProperty;
      var fromReadonlyNonEmptyArray = function(as) {
        return __spreadArray([as[0]], as.slice(1));
      };
      exports.fromReadonlyNonEmptyArray = fromReadonlyNonEmptyArray;
    }
  });

  // node_modules/fp-ts/lib/FromEither.js
  var require_FromEither = __commonJS({
    "node_modules/fp-ts/lib/FromEither.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.filterOrElse = exports.chainFirstEitherK = exports.chainEitherK = exports.fromEitherK = exports.chainOptionK = exports.fromOptionK = exports.fromPredicate = exports.fromOption = void 0;
      var Chain_1 = require_Chain();
      var function_1 = require_function();
      var _ = __importStar(require_internal());
      function fromOption(F) {
        return function(onNone) {
          return function(ma) {
            return F.fromEither(_.isNone(ma) ? _.left(onNone()) : _.right(ma.value));
          };
        };
      }
      exports.fromOption = fromOption;
      function fromPredicate(F) {
        return function(predicate, onFalse) {
          return function(a) {
            return F.fromEither(predicate(a) ? _.right(a) : _.left(onFalse(a)));
          };
        };
      }
      exports.fromPredicate = fromPredicate;
      function fromOptionK(F) {
        var fromOptionF = fromOption(F);
        return function(onNone) {
          var from = fromOptionF(onNone);
          return function(f) {
            return function_1.flow(f, from);
          };
        };
      }
      exports.fromOptionK = fromOptionK;
      function chainOptionK(F, M) {
        var fromOptionKF = fromOptionK(F);
        return function(onNone) {
          var from = fromOptionKF(onNone);
          return function(f) {
            return function(ma) {
              return M.chain(ma, from(f));
            };
          };
        };
      }
      exports.chainOptionK = chainOptionK;
      function fromEitherK(F) {
        return function(f) {
          return function_1.flow(f, F.fromEither);
        };
      }
      exports.fromEitherK = fromEitherK;
      function chainEitherK(F, M) {
        var fromEitherKF = fromEitherK(F);
        return function(f) {
          return function(ma) {
            return M.chain(ma, fromEitherKF(f));
          };
        };
      }
      exports.chainEitherK = chainEitherK;
      function chainFirstEitherK(F, M) {
        return function_1.flow(fromEitherK(F), Chain_1.chainFirst(M));
      }
      exports.chainFirstEitherK = chainFirstEitherK;
      function filterOrElse(F, M) {
        return function(predicate, onFalse) {
          return function(ma) {
            return M.chain(ma, function(a) {
              return F.fromEither(predicate(a) ? _.right(a) : _.left(onFalse(a)));
            });
          };
        };
      }
      exports.filterOrElse = filterOrElse;
    }
  });

  // node_modules/fp-ts/lib/Predicate.js
  var require_Predicate = __commonJS({
    "node_modules/fp-ts/lib/Predicate.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.and = exports.or = exports.not = exports.Contravariant = exports.getMonoidAll = exports.getSemigroupAll = exports.getMonoidAny = exports.getSemigroupAny = exports.URI = exports.contramap = void 0;
      var function_1 = require_function();
      var contramap_ = function(predicate, f) {
        return function_1.pipe(predicate, exports.contramap(f));
      };
      var contramap = function(f) {
        return function(predicate) {
          return function_1.flow(f, predicate);
        };
      };
      exports.contramap = contramap;
      exports.URI = "Predicate";
      var getSemigroupAny = function() {
        return {
          concat: function(first, second) {
            return function_1.pipe(first, exports.or(second));
          }
        };
      };
      exports.getSemigroupAny = getSemigroupAny;
      var getMonoidAny = function() {
        return {
          concat: exports.getSemigroupAny().concat,
          empty: function_1.constFalse
        };
      };
      exports.getMonoidAny = getMonoidAny;
      var getSemigroupAll = function() {
        return {
          concat: function(first, second) {
            return function_1.pipe(first, exports.and(second));
          }
        };
      };
      exports.getSemigroupAll = getSemigroupAll;
      var getMonoidAll = function() {
        return {
          concat: exports.getSemigroupAll().concat,
          empty: function_1.constTrue
        };
      };
      exports.getMonoidAll = getMonoidAll;
      exports.Contravariant = {
        URI: exports.URI,
        contramap: contramap_
      };
      var not = function(predicate) {
        return function(a) {
          return !predicate(a);
        };
      };
      exports.not = not;
      var or = function(second) {
        return function(first) {
          return function(a) {
            return first(a) || second(a);
          };
        };
      };
      exports.or = or;
      var and = function(second) {
        return function(first) {
          return function(a) {
            return first(a) && second(a);
          };
        };
      };
      exports.and = and;
    }
  });

  // node_modules/fp-ts/lib/Magma.js
  var require_Magma = __commonJS({
    "node_modules/fp-ts/lib/Magma.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.concatAll = exports.endo = exports.filterSecond = exports.filterFirst = exports.reverse = void 0;
      var reverse = function(M) {
        return {
          concat: function(first, second) {
            return M.concat(second, first);
          }
        };
      };
      exports.reverse = reverse;
      var filterFirst = function(predicate) {
        return function(M) {
          return {
            concat: function(first, second) {
              return predicate(first) ? M.concat(first, second) : second;
            }
          };
        };
      };
      exports.filterFirst = filterFirst;
      var filterSecond = function(predicate) {
        return function(M) {
          return {
            concat: function(first, second) {
              return predicate(second) ? M.concat(first, second) : first;
            }
          };
        };
      };
      exports.filterSecond = filterSecond;
      var endo = function(f) {
        return function(M) {
          return {
            concat: function(first, second) {
              return M.concat(f(first), f(second));
            }
          };
        };
      };
      exports.endo = endo;
      var concatAll = function(M) {
        return function(startWith) {
          return function(as) {
            return as.reduce(function(a, acc) {
              return M.concat(a, acc);
            }, startWith);
          };
        };
      };
      exports.concatAll = concatAll;
    }
  });

  // node_modules/fp-ts/lib/Eq.js
  var require_Eq = __commonJS({
    "node_modules/fp-ts/lib/Eq.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.eqDate = exports.eqNumber = exports.eqString = exports.eqBoolean = exports.eq = exports.strictEqual = exports.getStructEq = exports.getTupleEq = exports.Contravariant = exports.getMonoid = exports.getSemigroup = exports.eqStrict = exports.URI = exports.contramap = exports.tuple = exports.struct = exports.fromEquals = void 0;
      var function_1 = require_function();
      var fromEquals = function(equals) {
        return {
          equals: function(x2, y2) {
            return x2 === y2 || equals(x2, y2);
          }
        };
      };
      exports.fromEquals = fromEquals;
      var struct = function(eqs) {
        return exports.fromEquals(function(first, second) {
          for (var key in eqs) {
            if (!eqs[key].equals(first[key], second[key])) {
              return false;
            }
          }
          return true;
        });
      };
      exports.struct = struct;
      var tuple = function() {
        var eqs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          eqs[_i] = arguments[_i];
        }
        return exports.fromEquals(function(first, second) {
          return eqs.every(function(E, i) {
            return E.equals(first[i], second[i]);
          });
        });
      };
      exports.tuple = tuple;
      var contramap_ = function(fa, f) {
        return function_1.pipe(fa, exports.contramap(f));
      };
      var contramap = function(f) {
        return function(fa) {
          return exports.fromEquals(function(x2, y2) {
            return fa.equals(f(x2), f(y2));
          });
        };
      };
      exports.contramap = contramap;
      exports.URI = "Eq";
      exports.eqStrict = {
        equals: function(a, b) {
          return a === b;
        }
      };
      var empty = {
        equals: function() {
          return true;
        }
      };
      var getSemigroup = function() {
        return {
          concat: function(x2, y2) {
            return exports.fromEquals(function(a, b) {
              return x2.equals(a, b) && y2.equals(a, b);
            });
          }
        };
      };
      exports.getSemigroup = getSemigroup;
      var getMonoid = function() {
        return {
          concat: exports.getSemigroup().concat,
          empty
        };
      };
      exports.getMonoid = getMonoid;
      exports.Contravariant = {
        URI: exports.URI,
        contramap: contramap_
      };
      exports.getTupleEq = exports.tuple;
      exports.getStructEq = exports.struct;
      exports.strictEqual = exports.eqStrict.equals;
      exports.eq = exports.Contravariant;
      exports.eqBoolean = exports.eqStrict;
      exports.eqString = exports.eqStrict;
      exports.eqNumber = exports.eqStrict;
      exports.eqDate = {
        equals: function(first, second) {
          return first.valueOf() === second.valueOf();
        }
      };
    }
  });

  // node_modules/fp-ts/lib/Ord.js
  var require_Ord = __commonJS({
    "node_modules/fp-ts/lib/Ord.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ordDate = exports.ordNumber = exports.ordString = exports.ordBoolean = exports.ord = exports.getDualOrd = exports.getTupleOrd = exports.between = exports.clamp = exports.max = exports.min = exports.geq = exports.leq = exports.gt = exports.lt = exports.equals = exports.trivial = exports.Contravariant = exports.getMonoid = exports.getSemigroup = exports.URI = exports.contramap = exports.reverse = exports.tuple = exports.fromCompare = exports.equalsDefault = void 0;
      var Eq_1 = require_Eq();
      var function_1 = require_function();
      var equalsDefault = function(compare2) {
        return function(first, second) {
          return first === second || compare2(first, second) === 0;
        };
      };
      exports.equalsDefault = equalsDefault;
      var fromCompare = function(compare2) {
        return {
          equals: exports.equalsDefault(compare2),
          compare: function(first, second) {
            return first === second ? 0 : compare2(first, second);
          }
        };
      };
      exports.fromCompare = fromCompare;
      var tuple = function() {
        var ords = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          ords[_i] = arguments[_i];
        }
        return exports.fromCompare(function(first, second) {
          var i = 0;
          for (; i < ords.length - 1; i++) {
            var r = ords[i].compare(first[i], second[i]);
            if (r !== 0) {
              return r;
            }
          }
          return ords[i].compare(first[i], second[i]);
        });
      };
      exports.tuple = tuple;
      var reverse = function(O2) {
        return exports.fromCompare(function(first, second) {
          return O2.compare(second, first);
        });
      };
      exports.reverse = reverse;
      var contramap_ = function(fa, f) {
        return function_1.pipe(fa, exports.contramap(f));
      };
      var contramap = function(f) {
        return function(fa) {
          return exports.fromCompare(function(first, second) {
            return fa.compare(f(first), f(second));
          });
        };
      };
      exports.contramap = contramap;
      exports.URI = "Ord";
      var getSemigroup = function() {
        return {
          concat: function(first, second) {
            return exports.fromCompare(function(a, b) {
              var ox = first.compare(a, b);
              return ox !== 0 ? ox : second.compare(a, b);
            });
          }
        };
      };
      exports.getSemigroup = getSemigroup;
      var getMonoid = function() {
        return {
          concat: exports.getSemigroup().concat,
          empty: exports.fromCompare(function() {
            return 0;
          })
        };
      };
      exports.getMonoid = getMonoid;
      exports.Contravariant = {
        URI: exports.URI,
        contramap: contramap_
      };
      exports.trivial = {
        equals: function_1.constTrue,
        compare: /* @__PURE__ */ function_1.constant(0)
      };
      var equals = function(O2) {
        return function(second) {
          return function(first) {
            return first === second || O2.compare(first, second) === 0;
          };
        };
      };
      exports.equals = equals;
      var lt = function(O2) {
        return function(first, second) {
          return O2.compare(first, second) === -1;
        };
      };
      exports.lt = lt;
      var gt = function(O2) {
        return function(first, second) {
          return O2.compare(first, second) === 1;
        };
      };
      exports.gt = gt;
      var leq = function(O2) {
        return function(first, second) {
          return O2.compare(first, second) !== 1;
        };
      };
      exports.leq = leq;
      var geq = function(O2) {
        return function(first, second) {
          return O2.compare(first, second) !== -1;
        };
      };
      exports.geq = geq;
      var min = function(O2) {
        return function(first, second) {
          return first === second || O2.compare(first, second) < 1 ? first : second;
        };
      };
      exports.min = min;
      var max = function(O2) {
        return function(first, second) {
          return first === second || O2.compare(first, second) > -1 ? first : second;
        };
      };
      exports.max = max;
      var clamp = function(O2) {
        var minO = exports.min(O2);
        var maxO = exports.max(O2);
        return function(low, hi) {
          return function(a) {
            return maxO(minO(a, hi), low);
          };
        };
      };
      exports.clamp = clamp;
      var between = function(O2) {
        var ltO = exports.lt(O2);
        var gtO = exports.gt(O2);
        return function(low, hi) {
          return function(a) {
            return ltO(a, low) || gtO(a, hi) ? false : true;
          };
        };
      };
      exports.between = between;
      exports.getTupleOrd = exports.tuple;
      exports.getDualOrd = exports.reverse;
      exports.ord = exports.Contravariant;
      function compare(first, second) {
        return first < second ? -1 : first > second ? 1 : 0;
      }
      var strictOrd = {
        equals: Eq_1.eqStrict.equals,
        compare
      };
      exports.ordBoolean = strictOrd;
      exports.ordString = strictOrd;
      exports.ordNumber = strictOrd;
      exports.ordDate = /* @__PURE__ */ function_1.pipe(
        exports.ordNumber,
        /* @__PURE__ */ exports.contramap(function(date) {
          return date.valueOf();
        })
      );
    }
  });

  // node_modules/fp-ts/lib/Semigroup.js
  var require_Semigroup = __commonJS({
    "node_modules/fp-ts/lib/Semigroup.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.semigroupProduct = exports.semigroupSum = exports.semigroupString = exports.getFunctionSemigroup = exports.semigroupAny = exports.semigroupAll = exports.fold = exports.getIntercalateSemigroup = exports.getMeetSemigroup = exports.getJoinSemigroup = exports.getDualSemigroup = exports.getStructSemigroup = exports.getTupleSemigroup = exports.getFirstSemigroup = exports.getLastSemigroup = exports.getObjectSemigroup = exports.semigroupVoid = exports.concatAll = exports.last = exports.first = exports.intercalate = exports.tuple = exports.struct = exports.reverse = exports.constant = exports.max = exports.min = void 0;
      var function_1 = require_function();
      var _ = __importStar(require_internal());
      var M = __importStar(require_Magma());
      var Or = __importStar(require_Ord());
      var min = function(O2) {
        return {
          concat: Or.min(O2)
        };
      };
      exports.min = min;
      var max = function(O2) {
        return {
          concat: Or.max(O2)
        };
      };
      exports.max = max;
      var constant = function(a) {
        return {
          concat: function() {
            return a;
          }
        };
      };
      exports.constant = constant;
      exports.reverse = M.reverse;
      var struct = function(semigroups) {
        return {
          concat: function(first2, second) {
            var r = {};
            for (var k in semigroups) {
              if (_.has.call(semigroups, k)) {
                r[k] = semigroups[k].concat(first2[k], second[k]);
              }
            }
            return r;
          }
        };
      };
      exports.struct = struct;
      var tuple = function() {
        var semigroups = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          semigroups[_i] = arguments[_i];
        }
        return {
          concat: function(first2, second) {
            return semigroups.map(function(s, i) {
              return s.concat(first2[i], second[i]);
            });
          }
        };
      };
      exports.tuple = tuple;
      var intercalate = function(middle) {
        return function(S) {
          return {
            concat: function(x2, y2) {
              return S.concat(x2, S.concat(middle, y2));
            }
          };
        };
      };
      exports.intercalate = intercalate;
      var first = function() {
        return { concat: function_1.identity };
      };
      exports.first = first;
      var last = function() {
        return { concat: function(_2, y2) {
          return y2;
        } };
      };
      exports.last = last;
      exports.concatAll = M.concatAll;
      exports.semigroupVoid = exports.constant(void 0);
      var getObjectSemigroup = function() {
        return {
          concat: function(first2, second) {
            return Object.assign({}, first2, second);
          }
        };
      };
      exports.getObjectSemigroup = getObjectSemigroup;
      exports.getLastSemigroup = exports.last;
      exports.getFirstSemigroup = exports.first;
      exports.getTupleSemigroup = exports.tuple;
      exports.getStructSemigroup = exports.struct;
      exports.getDualSemigroup = exports.reverse;
      exports.getJoinSemigroup = exports.max;
      exports.getMeetSemigroup = exports.min;
      exports.getIntercalateSemigroup = exports.intercalate;
      function fold(S) {
        var concatAllS = exports.concatAll(S);
        return function(startWith, as) {
          return as === void 0 ? concatAllS(startWith) : concatAllS(startWith)(as);
        };
      }
      exports.fold = fold;
      exports.semigroupAll = {
        concat: function(x2, y2) {
          return x2 && y2;
        }
      };
      exports.semigroupAny = {
        concat: function(x2, y2) {
          return x2 || y2;
        }
      };
      exports.getFunctionSemigroup = function_1.getSemigroup;
      exports.semigroupString = {
        concat: function(x2, y2) {
          return x2 + y2;
        }
      };
      exports.semigroupSum = {
        concat: function(x2, y2) {
          return x2 + y2;
        }
      };
      exports.semigroupProduct = {
        concat: function(x2, y2) {
          return x2 * y2;
        }
      };
    }
  });

  // node_modules/fp-ts/lib/Separated.js
  var require_Separated = __commonJS({
    "node_modules/fp-ts/lib/Separated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.right = exports.left = exports.flap = exports.Functor = exports.Bifunctor = exports.URI = exports.bimap = exports.mapLeft = exports.map = exports.separated = void 0;
      var function_1 = require_function();
      var Functor_1 = require_Functor();
      var separated = function(left2, right2) {
        return { left: left2, right: right2 };
      };
      exports.separated = separated;
      var _map = function(fa, f) {
        return function_1.pipe(fa, exports.map(f));
      };
      var _mapLeft = function(fa, f) {
        return function_1.pipe(fa, exports.mapLeft(f));
      };
      var _bimap = function(fa, g, f) {
        return function_1.pipe(fa, exports.bimap(g, f));
      };
      var map5 = function(f) {
        return function(fa) {
          return exports.separated(exports.left(fa), f(exports.right(fa)));
        };
      };
      exports.map = map5;
      var mapLeft = function(f) {
        return function(fa) {
          return exports.separated(f(exports.left(fa)), exports.right(fa));
        };
      };
      exports.mapLeft = mapLeft;
      var bimap = function(f, g) {
        return function(fa) {
          return exports.separated(f(exports.left(fa)), g(exports.right(fa)));
        };
      };
      exports.bimap = bimap;
      exports.URI = "Separated";
      exports.Bifunctor = {
        URI: exports.URI,
        mapLeft: _mapLeft,
        bimap: _bimap
      };
      exports.Functor = {
        URI: exports.URI,
        map: _map
      };
      exports.flap = /* @__PURE__ */ Functor_1.flap(exports.Functor);
      var left = function(s) {
        return s.left;
      };
      exports.left = left;
      var right = function(s) {
        return s.right;
      };
      exports.right = right;
    }
  });

  // node_modules/fp-ts/lib/Witherable.js
  var require_Witherable = __commonJS({
    "node_modules/fp-ts/lib/Witherable.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.filterE = exports.witherDefault = exports.wiltDefault = void 0;
      var _ = __importStar(require_internal());
      function wiltDefault(T, C) {
        return function(F) {
          var traverseF = T.traverse(F);
          return function(wa, f) {
            return F.map(traverseF(wa, f), C.separate);
          };
        };
      }
      exports.wiltDefault = wiltDefault;
      function witherDefault(T, C) {
        return function(F) {
          var traverseF = T.traverse(F);
          return function(wa, f) {
            return F.map(traverseF(wa, f), C.compact);
          };
        };
      }
      exports.witherDefault = witherDefault;
      function filterE(W) {
        return function(F) {
          var witherF = W.wither(F);
          return function(predicate) {
            return function(ga) {
              return witherF(ga, function(a) {
                return F.map(predicate(a), function(b) {
                  return b ? _.some(a) : _.none;
                });
              });
            };
          };
        };
      }
      exports.filterE = filterE;
    }
  });

  // node_modules/fp-ts/lib/Zero.js
  var require_Zero = __commonJS({
    "node_modules/fp-ts/lib/Zero.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.guard = void 0;
      function guard(F, P) {
        return function(b) {
          return b ? P.of(void 0) : F.zero();
        };
      }
      exports.guard = guard;
    }
  });

  // node_modules/fp-ts/lib/Option.js
  var require_Option = __commonJS({
    "node_modules/fp-ts/lib/Option.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.fromEither = exports.MonadThrow = exports.throwError = exports.Witherable = exports.wilt = exports.wither = exports.Traversable = exports.sequence = exports.traverse = exports.Filterable = exports.partitionMap = exports.partition = exports.filterMap = exports.filter = exports.Compactable = exports.separate = exports.compact = exports.Extend = exports.extend = exports.Alternative = exports.guard = exports.Zero = exports.zero = exports.Alt = exports.alt = exports.altW = exports.Foldable = exports.reduceRight = exports.foldMap = exports.reduce = exports.Monad = exports.Chain = exports.chain = exports.Applicative = exports.Apply = exports.ap = exports.Pointed = exports.of = exports.Functor = exports.map = exports.getMonoid = exports.getOrd = exports.getEq = exports.getShow = exports.URI = exports.getRight = exports.getLeft = exports.fromPredicate = exports.some = exports.none = void 0;
      exports.getLastMonoid = exports.getFirstMonoid = exports.getApplyMonoid = exports.getApplySemigroup = exports.option = exports.mapNullable = exports.getRefinement = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apS = exports.bind = exports.bindTo = exports.Do = exports.exists = exports.elem = exports.toUndefined = exports.toNullable = exports.chainNullableK = exports.fromNullableK = exports.tryCatchK = exports.tryCatch = exports.fromNullable = exports.chainFirstEitherK = exports.chainEitherK = exports.fromEitherK = exports.duplicate = exports.chainFirst = exports.flatten = exports.apSecond = exports.apFirst = exports.flap = exports.getOrElse = exports.getOrElseW = exports.fold = exports.match = exports.foldW = exports.matchW = exports.isNone = exports.isSome = exports.FromEither = void 0;
      var Applicative_1 = require_Applicative();
      var Apply_1 = require_Apply();
      var Chain_1 = require_Chain();
      var FromEither_1 = require_FromEither();
      var function_1 = require_function();
      var Functor_1 = require_Functor();
      var _ = __importStar(require_internal());
      var Predicate_1 = require_Predicate();
      var Semigroup_1 = require_Semigroup();
      var Separated_1 = require_Separated();
      var Witherable_1 = require_Witherable();
      var Zero_1 = require_Zero();
      exports.none = _.none;
      exports.some = _.some;
      function fromPredicate(predicate) {
        return function(a) {
          return predicate(a) ? exports.some(a) : exports.none;
        };
      }
      exports.fromPredicate = fromPredicate;
      var getLeft = function(ma) {
        return ma._tag === "Right" ? exports.none : exports.some(ma.left);
      };
      exports.getLeft = getLeft;
      var getRight = function(ma) {
        return ma._tag === "Left" ? exports.none : exports.some(ma.right);
      };
      exports.getRight = getRight;
      var _map = function(fa, f) {
        return function_1.pipe(fa, exports.map(f));
      };
      var _ap = function(fab, fa) {
        return function_1.pipe(fab, exports.ap(fa));
      };
      var _chain = function(ma, f) {
        return function_1.pipe(ma, exports.chain(f));
      };
      var _reduce = function(fa, b, f) {
        return function_1.pipe(fa, exports.reduce(b, f));
      };
      var _foldMap = function(M) {
        var foldMapM = exports.foldMap(M);
        return function(fa, f) {
          return function_1.pipe(fa, foldMapM(f));
        };
      };
      var _reduceRight = function(fa, b, f) {
        return function_1.pipe(fa, exports.reduceRight(b, f));
      };
      var _traverse = function(F) {
        var traverseF = exports.traverse(F);
        return function(ta, f) {
          return function_1.pipe(ta, traverseF(f));
        };
      };
      var _alt = function(fa, that) {
        return function_1.pipe(fa, exports.alt(that));
      };
      var _filter = function(fa, predicate) {
        return function_1.pipe(fa, exports.filter(predicate));
      };
      var _filterMap = function(fa, f) {
        return function_1.pipe(fa, exports.filterMap(f));
      };
      var _extend = function(wa, f) {
        return function_1.pipe(wa, exports.extend(f));
      };
      var _partition = function(fa, predicate) {
        return function_1.pipe(fa, exports.partition(predicate));
      };
      var _partitionMap = function(fa, f) {
        return function_1.pipe(fa, exports.partitionMap(f));
      };
      exports.URI = "Option";
      var getShow = function(S) {
        return {
          show: function(ma) {
            return exports.isNone(ma) ? "none" : "some(" + S.show(ma.value) + ")";
          }
        };
      };
      exports.getShow = getShow;
      var getEq = function(E) {
        return {
          equals: function(x2, y2) {
            return x2 === y2 || (exports.isNone(x2) ? exports.isNone(y2) : exports.isNone(y2) ? false : E.equals(x2.value, y2.value));
          }
        };
      };
      exports.getEq = getEq;
      var getOrd = function(O2) {
        return {
          equals: exports.getEq(O2).equals,
          compare: function(x2, y2) {
            return x2 === y2 ? 0 : exports.isSome(x2) ? exports.isSome(y2) ? O2.compare(x2.value, y2.value) : 1 : -1;
          }
        };
      };
      exports.getOrd = getOrd;
      var getMonoid = function(S) {
        return {
          concat: function(x2, y2) {
            return exports.isNone(x2) ? y2 : exports.isNone(y2) ? x2 : exports.some(S.concat(x2.value, y2.value));
          },
          empty: exports.none
        };
      };
      exports.getMonoid = getMonoid;
      var map5 = function(f) {
        return function(fa) {
          return exports.isNone(fa) ? exports.none : exports.some(f(fa.value));
        };
      };
      exports.map = map5;
      exports.Functor = {
        URI: exports.URI,
        map: _map
      };
      exports.of = exports.some;
      exports.Pointed = {
        URI: exports.URI,
        of: exports.of
      };
      var ap = function(fa) {
        return function(fab) {
          return exports.isNone(fab) ? exports.none : exports.isNone(fa) ? exports.none : exports.some(fab.value(fa.value));
        };
      };
      exports.ap = ap;
      exports.Apply = {
        URI: exports.URI,
        map: _map,
        ap: _ap
      };
      exports.Applicative = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of
      };
      var chain3 = function(f) {
        return function(ma) {
          return exports.isNone(ma) ? exports.none : f(ma.value);
        };
      };
      exports.chain = chain3;
      exports.Chain = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        chain: _chain
      };
      exports.Monad = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of,
        chain: _chain
      };
      var reduce = function(b, f) {
        return function(fa) {
          return exports.isNone(fa) ? b : f(b, fa.value);
        };
      };
      exports.reduce = reduce;
      var foldMap = function(M) {
        return function(f) {
          return function(fa) {
            return exports.isNone(fa) ? M.empty : f(fa.value);
          };
        };
      };
      exports.foldMap = foldMap;
      var reduceRight = function(b, f) {
        return function(fa) {
          return exports.isNone(fa) ? b : f(fa.value, b);
        };
      };
      exports.reduceRight = reduceRight;
      exports.Foldable = {
        URI: exports.URI,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight
      };
      var altW = function(that) {
        return function(fa) {
          return exports.isNone(fa) ? that() : fa;
        };
      };
      exports.altW = altW;
      exports.alt = exports.altW;
      exports.Alt = {
        URI: exports.URI,
        map: _map,
        alt: _alt
      };
      var zero = function() {
        return exports.none;
      };
      exports.zero = zero;
      exports.Zero = {
        URI: exports.URI,
        zero: exports.zero
      };
      exports.guard = /* @__PURE__ */ Zero_1.guard(exports.Zero, exports.Pointed);
      exports.Alternative = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of,
        alt: _alt,
        zero: exports.zero
      };
      var extend = function(f) {
        return function(wa) {
          return exports.isNone(wa) ? exports.none : exports.some(f(wa));
        };
      };
      exports.extend = extend;
      exports.Extend = {
        URI: exports.URI,
        map: _map,
        extend: _extend
      };
      exports.compact = /* @__PURE__ */ exports.chain(function_1.identity);
      var defaultSeparated = /* @__PURE__ */ Separated_1.separated(exports.none, exports.none);
      var separate = function(ma) {
        return exports.isNone(ma) ? defaultSeparated : Separated_1.separated(exports.getLeft(ma.value), exports.getRight(ma.value));
      };
      exports.separate = separate;
      exports.Compactable = {
        URI: exports.URI,
        compact: exports.compact,
        separate: exports.separate
      };
      var filter = function(predicate) {
        return function(fa) {
          return exports.isNone(fa) ? exports.none : predicate(fa.value) ? fa : exports.none;
        };
      };
      exports.filter = filter;
      var filterMap = function(f) {
        return function(fa) {
          return exports.isNone(fa) ? exports.none : f(fa.value);
        };
      };
      exports.filterMap = filterMap;
      var partition = function(predicate) {
        return function(fa) {
          return Separated_1.separated(_filter(fa, Predicate_1.not(predicate)), _filter(fa, predicate));
        };
      };
      exports.partition = partition;
      var partitionMap = function(f) {
        return function_1.flow(exports.map(f), exports.separate);
      };
      exports.partitionMap = partitionMap;
      exports.Filterable = {
        URI: exports.URI,
        map: _map,
        compact: exports.compact,
        separate: exports.separate,
        filter: _filter,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap
      };
      var traverse = function(F) {
        return function(f) {
          return function(ta) {
            return exports.isNone(ta) ? F.of(exports.none) : F.map(f(ta.value), exports.some);
          };
        };
      };
      exports.traverse = traverse;
      var sequence = function(F) {
        return function(ta) {
          return exports.isNone(ta) ? F.of(exports.none) : F.map(ta.value, exports.some);
        };
      };
      exports.sequence = sequence;
      exports.Traversable = {
        URI: exports.URI,
        map: _map,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: exports.sequence
      };
      var _wither = /* @__PURE__ */ Witherable_1.witherDefault(exports.Traversable, exports.Compactable);
      var _wilt = /* @__PURE__ */ Witherable_1.wiltDefault(exports.Traversable, exports.Compactable);
      var wither = function(F) {
        var _witherF = _wither(F);
        return function(f) {
          return function(fa) {
            return _witherF(fa, f);
          };
        };
      };
      exports.wither = wither;
      var wilt = function(F) {
        var _wiltF = _wilt(F);
        return function(f) {
          return function(fa) {
            return _wiltF(fa, f);
          };
        };
      };
      exports.wilt = wilt;
      exports.Witherable = {
        URI: exports.URI,
        map: _map,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: exports.sequence,
        compact: exports.compact,
        separate: exports.separate,
        filter: _filter,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap,
        wither: _wither,
        wilt: _wilt
      };
      var throwError = function() {
        return exports.none;
      };
      exports.throwError = throwError;
      exports.MonadThrow = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of,
        chain: _chain,
        throwError: exports.throwError
      };
      exports.fromEither = exports.getRight;
      exports.FromEither = {
        URI: exports.URI,
        fromEither: exports.fromEither
      };
      exports.isSome = _.isSome;
      var isNone = function(fa) {
        return fa._tag === "None";
      };
      exports.isNone = isNone;
      var matchW = function(onNone, onSome) {
        return function(ma) {
          return exports.isNone(ma) ? onNone() : onSome(ma.value);
        };
      };
      exports.matchW = matchW;
      exports.foldW = exports.matchW;
      exports.match = exports.matchW;
      exports.fold = exports.match;
      var getOrElseW = function(onNone) {
        return function(ma) {
          return exports.isNone(ma) ? onNone() : ma.value;
        };
      };
      exports.getOrElseW = getOrElseW;
      exports.getOrElse = exports.getOrElseW;
      exports.flap = /* @__PURE__ */ Functor_1.flap(exports.Functor);
      exports.apFirst = /* @__PURE__ */ Apply_1.apFirst(exports.Apply);
      exports.apSecond = /* @__PURE__ */ Apply_1.apSecond(exports.Apply);
      exports.flatten = exports.compact;
      exports.chainFirst = /* @__PURE__ */ Chain_1.chainFirst(exports.Chain);
      exports.duplicate = /* @__PURE__ */ exports.extend(function_1.identity);
      exports.fromEitherK = /* @__PURE__ */ FromEither_1.fromEitherK(exports.FromEither);
      exports.chainEitherK = /* @__PURE__ */ FromEither_1.chainEitherK(exports.FromEither, exports.Chain);
      exports.chainFirstEitherK = /* @__PURE__ */ FromEither_1.chainFirstEitherK(exports.FromEither, exports.Chain);
      var fromNullable3 = function(a) {
        return a == null ? exports.none : exports.some(a);
      };
      exports.fromNullable = fromNullable3;
      var tryCatch2 = function(f) {
        try {
          return exports.some(f());
        } catch (e) {
          return exports.none;
        }
      };
      exports.tryCatch = tryCatch2;
      var tryCatchK = function(f) {
        return function() {
          var a = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            a[_i] = arguments[_i];
          }
          return exports.tryCatch(function() {
            return f.apply(void 0, a);
          });
        };
      };
      exports.tryCatchK = tryCatchK;
      var fromNullableK = function(f) {
        return function_1.flow(f, exports.fromNullable);
      };
      exports.fromNullableK = fromNullableK;
      var chainNullableK = function(f) {
        return function(ma) {
          return exports.isNone(ma) ? exports.none : exports.fromNullable(f(ma.value));
        };
      };
      exports.chainNullableK = chainNullableK;
      exports.toNullable = /* @__PURE__ */ exports.match(function_1.constNull, function_1.identity);
      exports.toUndefined = /* @__PURE__ */ exports.match(function_1.constUndefined, function_1.identity);
      function elem(E) {
        return function(a, ma) {
          if (ma === void 0) {
            var elemE_1 = elem(E);
            return function(ma2) {
              return elemE_1(a, ma2);
            };
          }
          return exports.isNone(ma) ? false : E.equals(a, ma.value);
        };
      }
      exports.elem = elem;
      var exists = function(predicate) {
        return function(ma) {
          return exports.isNone(ma) ? false : predicate(ma.value);
        };
      };
      exports.exists = exists;
      exports.Do = /* @__PURE__ */ exports.of(_.emptyRecord);
      exports.bindTo = /* @__PURE__ */ Functor_1.bindTo(exports.Functor);
      exports.bind = /* @__PURE__ */ Chain_1.bind(exports.Chain);
      exports.apS = /* @__PURE__ */ Apply_1.apS(exports.Apply);
      exports.ApT = /* @__PURE__ */ exports.of(_.emptyReadonlyArray);
      var traverseReadonlyNonEmptyArrayWithIndex = function(f) {
        return function(as) {
          var o = f(0, _.head(as));
          if (exports.isNone(o)) {
            return exports.none;
          }
          var out = [o.value];
          for (var i = 1; i < as.length; i++) {
            var o_1 = f(i, as[i]);
            if (exports.isNone(o_1)) {
              return exports.none;
            }
            out.push(o_1.value);
          }
          return exports.some(out);
        };
      };
      exports.traverseReadonlyNonEmptyArrayWithIndex = traverseReadonlyNonEmptyArrayWithIndex;
      var traverseReadonlyArrayWithIndex = function(f) {
        var g = exports.traverseReadonlyNonEmptyArrayWithIndex(f);
        return function(as) {
          return _.isNonEmpty(as) ? g(as) : exports.ApT;
        };
      };
      exports.traverseReadonlyArrayWithIndex = traverseReadonlyArrayWithIndex;
      exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex;
      var traverseArray = function(f) {
        return exports.traverseReadonlyArrayWithIndex(function(_2, a) {
          return f(a);
        });
      };
      exports.traverseArray = traverseArray;
      exports.sequenceArray = /* @__PURE__ */ exports.traverseArray(function_1.identity);
      function getRefinement(getOption) {
        return function(a) {
          return exports.isSome(getOption(a));
        };
      }
      exports.getRefinement = getRefinement;
      exports.mapNullable = exports.chainNullableK;
      exports.option = {
        URI: exports.URI,
        map: _map,
        of: exports.of,
        ap: _ap,
        chain: _chain,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: exports.sequence,
        zero: exports.zero,
        alt: _alt,
        extend: _extend,
        compact: exports.compact,
        separate: exports.separate,
        filter: _filter,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap,
        wither: _wither,
        wilt: _wilt,
        throwError: exports.throwError
      };
      exports.getApplySemigroup = /* @__PURE__ */ Apply_1.getApplySemigroup(exports.Apply);
      exports.getApplyMonoid = /* @__PURE__ */ Applicative_1.getApplicativeMonoid(exports.Applicative);
      var getFirstMonoid = function() {
        return exports.getMonoid(Semigroup_1.first());
      };
      exports.getFirstMonoid = getFirstMonoid;
      var getLastMonoid = function() {
        return exports.getMonoid(Semigroup_1.last());
      };
      exports.getLastMonoid = getLastMonoid;
    }
  });

  // node_modules/object-assign/index.js
  var require_object_assign = __commonJS({
    "node_modules/object-assign/index.js"(exports, module) {
      "use strict";
      var getOwnPropertySymbols = Object.getOwnPropertySymbols;
      var hasOwnProperty2 = Object.prototype.hasOwnProperty;
      var propIsEnumerable = Object.prototype.propertyIsEnumerable;
      function toObject(val) {
        if (val === null || val === void 0) {
          throw new TypeError("Object.assign cannot be called with null or undefined");
        }
        return Object(val);
      }
      function shouldUseNative() {
        try {
          if (!Object.assign) {
            return false;
          }
          var test1 = new String("abc");
          test1[5] = "de";
          if (Object.getOwnPropertyNames(test1)[0] === "5") {
            return false;
          }
          var test2 = {};
          for (var i = 0; i < 10; i++) {
            test2["_" + String.fromCharCode(i)] = i;
          }
          var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
            return test2[n];
          });
          if (order2.join("") !== "0123456789") {
            return false;
          }
          var test3 = {};
          "abcdefghijklmnopqrst".split("").forEach(function(letter) {
            test3[letter] = letter;
          });
          if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
            return false;
          }
          return true;
        } catch (err) {
          return false;
        }
      }
      module.exports = shouldUseNative() ? Object.assign : function(target, source) {
        var from;
        var to = toObject(target);
        var symbols;
        for (var s = 1; s < arguments.length; s++) {
          from = Object(arguments[s]);
          for (var key in from) {
            if (hasOwnProperty2.call(from, key)) {
              to[key] = from[key];
            }
          }
          if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from);
            for (var i = 0; i < symbols.length; i++) {
              if (propIsEnumerable.call(from, symbols[i])) {
                to[symbols[i]] = from[symbols[i]];
              }
            }
          }
        }
        return to;
      };
    }
  });

  // node_modules/concaveman/node_modules/rbush/rbush.min.js
  var require_rbush_min2 = __commonJS({
    "node_modules/concaveman/node_modules/rbush/rbush.min.js"(exports, module) {
      !function(t, i) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = i() : "function" == typeof define && define.amd ? define(i) : (t = t || self).RBush = i();
      }(exports, function() {
        "use strict";
        function t(t2, r2, e3, a2, h2) {
          !function t3(n2, r3, e4, a3, h3) {
            for (; a3 > e4; ) {
              if (a3 - e4 > 600) {
                var o2 = a3 - e4 + 1, s2 = r3 - e4 + 1, l2 = Math.log(o2), f2 = 0.5 * Math.exp(2 * l2 / 3), u2 = 0.5 * Math.sqrt(l2 * f2 * (o2 - f2) / o2) * (s2 - o2 / 2 < 0 ? -1 : 1), m2 = Math.max(e4, Math.floor(r3 - s2 * f2 / o2 + u2)), c2 = Math.min(a3, Math.floor(r3 + (o2 - s2) * f2 / o2 + u2));
                t3(n2, r3, m2, c2, h3);
              }
              var p2 = n2[r3], d2 = e4, x2 = a3;
              for (i(n2, e4, r3), h3(n2[a3], p2) > 0 && i(n2, e4, a3); d2 < x2; ) {
                for (i(n2, d2, x2), d2++, x2--; h3(n2[d2], p2) < 0; )
                  d2++;
                for (; h3(n2[x2], p2) > 0; )
                  x2--;
              }
              0 === h3(n2[e4], p2) ? i(n2, e4, x2) : i(n2, ++x2, a3), x2 <= r3 && (e4 = x2 + 1), r3 <= x2 && (a3 = x2 - 1);
            }
          }(t2, r2, e3 || 0, a2 || t2.length - 1, h2 || n);
        }
        function i(t2, i2, n2) {
          var r2 = t2[i2];
          t2[i2] = t2[n2], t2[n2] = r2;
        }
        function n(t2, i2) {
          return t2 < i2 ? -1 : t2 > i2 ? 1 : 0;
        }
        var r = function(t2) {
          void 0 === t2 && (t2 = 9), this._maxEntries = Math.max(4, t2), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
        };
        function e(t2, i2, n2) {
          if (!n2)
            return i2.indexOf(t2);
          for (var r2 = 0; r2 < i2.length; r2++)
            if (n2(t2, i2[r2]))
              return r2;
          return -1;
        }
        function a(t2, i2) {
          h(t2, 0, t2.children.length, i2, t2);
        }
        function h(t2, i2, n2, r2, e3) {
          e3 || (e3 = p(null)), e3.minX = 1 / 0, e3.minY = 1 / 0, e3.maxX = -1 / 0, e3.maxY = -1 / 0;
          for (var a2 = i2; a2 < n2; a2++) {
            var h2 = t2.children[a2];
            o(e3, t2.leaf ? r2(h2) : h2);
          }
          return e3;
        }
        function o(t2, i2) {
          return t2.minX = Math.min(t2.minX, i2.minX), t2.minY = Math.min(t2.minY, i2.minY), t2.maxX = Math.max(t2.maxX, i2.maxX), t2.maxY = Math.max(t2.maxY, i2.maxY), t2;
        }
        function s(t2, i2) {
          return t2.minX - i2.minX;
        }
        function l(t2, i2) {
          return t2.minY - i2.minY;
        }
        function f(t2) {
          return (t2.maxX - t2.minX) * (t2.maxY - t2.minY);
        }
        function u(t2) {
          return t2.maxX - t2.minX + (t2.maxY - t2.minY);
        }
        function m(t2, i2) {
          return t2.minX <= i2.minX && t2.minY <= i2.minY && i2.maxX <= t2.maxX && i2.maxY <= t2.maxY;
        }
        function c(t2, i2) {
          return i2.minX <= t2.maxX && i2.minY <= t2.maxY && i2.maxX >= t2.minX && i2.maxY >= t2.minY;
        }
        function p(t2) {
          return { children: t2, height: 1, leaf: true, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
        }
        function d(i2, n2, r2, e3, a2) {
          for (var h2 = [n2, r2]; h2.length; )
            if (!((r2 = h2.pop()) - (n2 = h2.pop()) <= e3)) {
              var o2 = n2 + Math.ceil((r2 - n2) / e3 / 2) * e3;
              t(i2, o2, n2, r2, a2), h2.push(n2, o2, o2, r2);
            }
        }
        return r.prototype.all = function() {
          return this._all(this.data, []);
        }, r.prototype.search = function(t2) {
          var i2 = this.data, n2 = [];
          if (!c(t2, i2))
            return n2;
          for (var r2 = this.toBBox, e3 = []; i2; ) {
            for (var a2 = 0; a2 < i2.children.length; a2++) {
              var h2 = i2.children[a2], o2 = i2.leaf ? r2(h2) : h2;
              c(t2, o2) && (i2.leaf ? n2.push(h2) : m(t2, o2) ? this._all(h2, n2) : e3.push(h2));
            }
            i2 = e3.pop();
          }
          return n2;
        }, r.prototype.collides = function(t2) {
          var i2 = this.data;
          if (!c(t2, i2))
            return false;
          for (var n2 = []; i2; ) {
            for (var r2 = 0; r2 < i2.children.length; r2++) {
              var e3 = i2.children[r2], a2 = i2.leaf ? this.toBBox(e3) : e3;
              if (c(t2, a2)) {
                if (i2.leaf || m(t2, a2))
                  return true;
                n2.push(e3);
              }
            }
            i2 = n2.pop();
          }
          return false;
        }, r.prototype.load = function(t2) {
          if (!t2 || !t2.length)
            return this;
          if (t2.length < this._minEntries) {
            for (var i2 = 0; i2 < t2.length; i2++)
              this.insert(t2[i2]);
            return this;
          }
          var n2 = this._build(t2.slice(), 0, t2.length - 1, 0);
          if (this.data.children.length)
            if (this.data.height === n2.height)
              this._splitRoot(this.data, n2);
            else {
              if (this.data.height < n2.height) {
                var r2 = this.data;
                this.data = n2, n2 = r2;
              }
              this._insert(n2, this.data.height - n2.height - 1, true);
            }
          else
            this.data = n2;
          return this;
        }, r.prototype.insert = function(t2) {
          return t2 && this._insert(t2, this.data.height - 1), this;
        }, r.prototype.clear = function() {
          return this.data = p([]), this;
        }, r.prototype.remove = function(t2, i2) {
          if (!t2)
            return this;
          for (var n2, r2, a2, h2 = this.data, o2 = this.toBBox(t2), s2 = [], l2 = []; h2 || s2.length; ) {
            if (h2 || (h2 = s2.pop(), r2 = s2[s2.length - 1], n2 = l2.pop(), a2 = true), h2.leaf) {
              var f2 = e(t2, h2.children, i2);
              if (-1 !== f2)
                return h2.children.splice(f2, 1), s2.push(h2), this._condense(s2), this;
            }
            a2 || h2.leaf || !m(h2, o2) ? r2 ? (n2++, h2 = r2.children[n2], a2 = false) : h2 = null : (s2.push(h2), l2.push(n2), n2 = 0, r2 = h2, h2 = h2.children[0]);
          }
          return this;
        }, r.prototype.toBBox = function(t2) {
          return t2;
        }, r.prototype.compareMinX = function(t2, i2) {
          return t2.minX - i2.minX;
        }, r.prototype.compareMinY = function(t2, i2) {
          return t2.minY - i2.minY;
        }, r.prototype.toJSON = function() {
          return this.data;
        }, r.prototype.fromJSON = function(t2) {
          return this.data = t2, this;
        }, r.prototype._all = function(t2, i2) {
          for (var n2 = []; t2; )
            t2.leaf ? i2.push.apply(i2, t2.children) : n2.push.apply(n2, t2.children), t2 = n2.pop();
          return i2;
        }, r.prototype._build = function(t2, i2, n2, r2) {
          var e3, h2 = n2 - i2 + 1, o2 = this._maxEntries;
          if (h2 <= o2)
            return a(e3 = p(t2.slice(i2, n2 + 1)), this.toBBox), e3;
          r2 || (r2 = Math.ceil(Math.log(h2) / Math.log(o2)), o2 = Math.ceil(h2 / Math.pow(o2, r2 - 1))), (e3 = p([])).leaf = false, e3.height = r2;
          var s2 = Math.ceil(h2 / o2), l2 = s2 * Math.ceil(Math.sqrt(o2));
          d(t2, i2, n2, l2, this.compareMinX);
          for (var f2 = i2; f2 <= n2; f2 += l2) {
            var u2 = Math.min(f2 + l2 - 1, n2);
            d(t2, f2, u2, s2, this.compareMinY);
            for (var m2 = f2; m2 <= u2; m2 += s2) {
              var c2 = Math.min(m2 + s2 - 1, u2);
              e3.children.push(this._build(t2, m2, c2, r2 - 1));
            }
          }
          return a(e3, this.toBBox), e3;
        }, r.prototype._chooseSubtree = function(t2, i2, n2, r2) {
          for (; r2.push(i2), !i2.leaf && r2.length - 1 !== n2; ) {
            for (var e3 = 1 / 0, a2 = 1 / 0, h2 = void 0, o2 = 0; o2 < i2.children.length; o2++) {
              var s2 = i2.children[o2], l2 = f(s2), u2 = (m2 = t2, c2 = s2, (Math.max(c2.maxX, m2.maxX) - Math.min(c2.minX, m2.minX)) * (Math.max(c2.maxY, m2.maxY) - Math.min(c2.minY, m2.minY)) - l2);
              u2 < a2 ? (a2 = u2, e3 = l2 < e3 ? l2 : e3, h2 = s2) : u2 === a2 && l2 < e3 && (e3 = l2, h2 = s2);
            }
            i2 = h2 || i2.children[0];
          }
          var m2, c2;
          return i2;
        }, r.prototype._insert = function(t2, i2, n2) {
          var r2 = n2 ? t2 : this.toBBox(t2), e3 = [], a2 = this._chooseSubtree(r2, this.data, i2, e3);
          for (a2.children.push(t2), o(a2, r2); i2 >= 0 && e3[i2].children.length > this._maxEntries; )
            this._split(e3, i2), i2--;
          this._adjustParentBBoxes(r2, e3, i2);
        }, r.prototype._split = function(t2, i2) {
          var n2 = t2[i2], r2 = n2.children.length, e3 = this._minEntries;
          this._chooseSplitAxis(n2, e3, r2);
          var h2 = this._chooseSplitIndex(n2, e3, r2), o2 = p(n2.children.splice(h2, n2.children.length - h2));
          o2.height = n2.height, o2.leaf = n2.leaf, a(n2, this.toBBox), a(o2, this.toBBox), i2 ? t2[i2 - 1].children.push(o2) : this._splitRoot(n2, o2);
        }, r.prototype._splitRoot = function(t2, i2) {
          this.data = p([t2, i2]), this.data.height = t2.height + 1, this.data.leaf = false, a(this.data, this.toBBox);
        }, r.prototype._chooseSplitIndex = function(t2, i2, n2) {
          for (var r2, e3, a2, o2, s2, l2, u2, m2 = 1 / 0, c2 = 1 / 0, p2 = i2; p2 <= n2 - i2; p2++) {
            var d2 = h(t2, 0, p2, this.toBBox), x2 = h(t2, p2, n2, this.toBBox), v = (e3 = d2, a2 = x2, o2 = void 0, s2 = void 0, l2 = void 0, u2 = void 0, o2 = Math.max(e3.minX, a2.minX), s2 = Math.max(e3.minY, a2.minY), l2 = Math.min(e3.maxX, a2.maxX), u2 = Math.min(e3.maxY, a2.maxY), Math.max(0, l2 - o2) * Math.max(0, u2 - s2)), M = f(d2) + f(x2);
            v < m2 ? (m2 = v, r2 = p2, c2 = M < c2 ? M : c2) : v === m2 && M < c2 && (c2 = M, r2 = p2);
          }
          return r2 || n2 - i2;
        }, r.prototype._chooseSplitAxis = function(t2, i2, n2) {
          var r2 = t2.leaf ? this.compareMinX : s, e3 = t2.leaf ? this.compareMinY : l;
          this._allDistMargin(t2, i2, n2, r2) < this._allDistMargin(t2, i2, n2, e3) && t2.children.sort(r2);
        }, r.prototype._allDistMargin = function(t2, i2, n2, r2) {
          t2.children.sort(r2);
          for (var e3 = this.toBBox, a2 = h(t2, 0, i2, e3), s2 = h(t2, n2 - i2, n2, e3), l2 = u(a2) + u(s2), f2 = i2; f2 < n2 - i2; f2++) {
            var m2 = t2.children[f2];
            o(a2, t2.leaf ? e3(m2) : m2), l2 += u(a2);
          }
          for (var c2 = n2 - i2 - 1; c2 >= i2; c2--) {
            var p2 = t2.children[c2];
            o(s2, t2.leaf ? e3(p2) : p2), l2 += u(s2);
          }
          return l2;
        }, r.prototype._adjustParentBBoxes = function(t2, i2, n2) {
          for (var r2 = n2; r2 >= 0; r2--)
            o(i2[r2], t2);
        }, r.prototype._condense = function(t2) {
          for (var i2 = t2.length - 1, n2 = void 0; i2 >= 0; i2--)
            0 === t2[i2].children.length ? i2 > 0 ? (n2 = t2[i2 - 1].children).splice(n2.indexOf(t2[i2]), 1) : this.clear() : a(t2[i2], this.toBBox);
        }, r;
      });
    }
  });

  // node_modules/tinyqueue/tinyqueue.js
  var require_tinyqueue = __commonJS({
    "node_modules/tinyqueue/tinyqueue.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = global2 || self, global2.TinyQueue = factory());
      })(exports, function() {
        "use strict";
        var TinyQueue = function TinyQueue2(data, compare) {
          if (data === void 0)
            data = [];
          if (compare === void 0)
            compare = defaultCompare;
          this.data = data;
          this.length = this.data.length;
          this.compare = compare;
          if (this.length > 0) {
            for (var i = (this.length >> 1) - 1; i >= 0; i--) {
              this._down(i);
            }
          }
        };
        TinyQueue.prototype.push = function push(item) {
          this.data.push(item);
          this.length++;
          this._up(this.length - 1);
        };
        TinyQueue.prototype.pop = function pop() {
          if (this.length === 0) {
            return void 0;
          }
          var top = this.data[0];
          var bottom = this.data.pop();
          this.length--;
          if (this.length > 0) {
            this.data[0] = bottom;
            this._down(0);
          }
          return top;
        };
        TinyQueue.prototype.peek = function peek() {
          return this.data[0];
        };
        TinyQueue.prototype._up = function _up(pos) {
          var ref = this;
          var data = ref.data;
          var compare = ref.compare;
          var item = data[pos];
          while (pos > 0) {
            var parent = pos - 1 >> 1;
            var current = data[parent];
            if (compare(item, current) >= 0) {
              break;
            }
            data[pos] = current;
            pos = parent;
          }
          data[pos] = item;
        };
        TinyQueue.prototype._down = function _down(pos) {
          var ref = this;
          var data = ref.data;
          var compare = ref.compare;
          var halfLength = this.length >> 1;
          var item = data[pos];
          while (pos < halfLength) {
            var left = (pos << 1) + 1;
            var best = data[left];
            var right = left + 1;
            if (right < this.length && compare(data[right], best) < 0) {
              left = right;
              best = data[right];
            }
            if (compare(best, item) >= 0) {
              break;
            }
            data[pos] = best;
            pos = left;
          }
          data[pos] = item;
        };
        function defaultCompare(a, b) {
          return a < b ? -1 : a > b ? 1 : 0;
        }
        return TinyQueue;
      });
    }
  });

  // node_modules/point-in-polygon/flat.js
  var require_flat = __commonJS({
    "node_modules/point-in-polygon/flat.js"(exports, module) {
      module.exports = function pointInPolygonFlat(point2, vs, start, end) {
        var x2 = point2[0], y2 = point2[1];
        var inside = false;
        if (start === void 0)
          start = 0;
        if (end === void 0)
          end = vs.length;
        var len = (end - start) / 2;
        for (var i = 0, j = len - 1; i < len; j = i++) {
          var xi = vs[start + i * 2 + 0], yi = vs[start + i * 2 + 1];
          var xj = vs[start + j * 2 + 0], yj = vs[start + j * 2 + 1];
          var intersect2 = yi > y2 !== yj > y2 && x2 < (xj - xi) * (y2 - yi) / (yj - yi) + xi;
          if (intersect2)
            inside = !inside;
        }
        return inside;
      };
    }
  });

  // node_modules/point-in-polygon/nested.js
  var require_nested = __commonJS({
    "node_modules/point-in-polygon/nested.js"(exports, module) {
      module.exports = function pointInPolygonNested(point2, vs, start, end) {
        var x2 = point2[0], y2 = point2[1];
        var inside = false;
        if (start === void 0)
          start = 0;
        if (end === void 0)
          end = vs.length;
        var len = end - start;
        for (var i = 0, j = len - 1; i < len; j = i++) {
          var xi = vs[i + start][0], yi = vs[i + start][1];
          var xj = vs[j + start][0], yj = vs[j + start][1];
          var intersect2 = yi > y2 !== yj > y2 && x2 < (xj - xi) * (y2 - yi) / (yj - yi) + xi;
          if (intersect2)
            inside = !inside;
        }
        return inside;
      };
    }
  });

  // node_modules/point-in-polygon/index.js
  var require_point_in_polygon = __commonJS({
    "node_modules/point-in-polygon/index.js"(exports, module) {
      var pointInPolygonFlat = require_flat();
      var pointInPolygonNested = require_nested();
      module.exports = function pointInPolygon(point2, vs, start, end) {
        if (vs.length > 0 && Array.isArray(vs[0])) {
          return pointInPolygonNested(point2, vs, start, end);
        } else {
          return pointInPolygonFlat(point2, vs, start, end);
        }
      };
      module.exports.nested = pointInPolygonNested;
      module.exports.flat = pointInPolygonFlat;
    }
  });

  // node_modules/robust-predicates/umd/orient2d.min.js
  var require_orient2d_min = __commonJS({
    "node_modules/robust-predicates/umd/orient2d.min.js"(exports, module) {
      !function(t, e) {
        "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e((t = t || self).predicates = {});
      }(exports, function(t) {
        "use strict";
        const e = 134217729, n = 33306690738754706e-32;
        function r(t2, e3, n2, r2, o2) {
          let f2, i2, u2, c2, s2 = e3[0], a2 = r2[0], d2 = 0, l2 = 0;
          a2 > s2 == a2 > -s2 ? (f2 = s2, s2 = e3[++d2]) : (f2 = a2, a2 = r2[++l2]);
          let p = 0;
          if (d2 < t2 && l2 < n2)
            for (a2 > s2 == a2 > -s2 ? (u2 = f2 - ((i2 = s2 + f2) - s2), s2 = e3[++d2]) : (u2 = f2 - ((i2 = a2 + f2) - a2), a2 = r2[++l2]), f2 = i2, 0 !== u2 && (o2[p++] = u2); d2 < t2 && l2 < n2; )
              a2 > s2 == a2 > -s2 ? (u2 = f2 - ((i2 = f2 + s2) - (c2 = i2 - f2)) + (s2 - c2), s2 = e3[++d2]) : (u2 = f2 - ((i2 = f2 + a2) - (c2 = i2 - f2)) + (a2 - c2), a2 = r2[++l2]), f2 = i2, 0 !== u2 && (o2[p++] = u2);
          for (; d2 < t2; )
            u2 = f2 - ((i2 = f2 + s2) - (c2 = i2 - f2)) + (s2 - c2), s2 = e3[++d2], f2 = i2, 0 !== u2 && (o2[p++] = u2);
          for (; l2 < n2; )
            u2 = f2 - ((i2 = f2 + a2) - (c2 = i2 - f2)) + (a2 - c2), a2 = r2[++l2], f2 = i2, 0 !== u2 && (o2[p++] = u2);
          return 0 === f2 && 0 !== p || (o2[p++] = f2), p;
        }
        function o(t2) {
          return new Float64Array(t2);
        }
        const f = 33306690738754716e-32, i = 22204460492503146e-32, u = 11093356479670487e-47, c = o(4), s = o(8), a = o(12), d = o(16), l = o(4);
        t.orient2d = function(t2, o2, p, b, y2, h) {
          const M = (o2 - h) * (p - y2), x2 = (t2 - y2) * (b - h), j = M - x2;
          if (0 === M || 0 === x2 || M > 0 != x2 > 0)
            return j;
          const m = Math.abs(M + x2);
          return Math.abs(j) >= f * m ? j : -function(t3, o3, f2, p2, b2, y3, h2) {
            let M2, x3, j2, m2, _, v, w, A, F, O2, P, g, k, q, z, B2, C, D;
            const E = t3 - b2, G = f2 - b2, H = o3 - y3, I = p2 - y3;
            _ = (z = (A = E - (w = (v = e * E) - (v - E))) * (O2 = I - (F = (v = e * I) - (v - I))) - ((q = E * I) - w * F - A * F - w * O2)) - (P = z - (C = (A = H - (w = (v = e * H) - (v - H))) * (O2 = G - (F = (v = e * G) - (v - G))) - ((B2 = H * G) - w * F - A * F - w * O2))), c[0] = z - (P + _) + (_ - C), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B2), c[1] = k - (P + _) + (_ - B2), _ = (D = g + P) - g, c[2] = g - (D - _) + (P - _), c[3] = D;
            let J = function(t4, e3) {
              let n2 = e3[0];
              for (let r2 = 1; r2 < t4; r2++)
                n2 += e3[r2];
              return n2;
            }(4, c), K = i * h2;
            if (J >= K || -J >= K)
              return J;
            if (M2 = t3 - (E + (_ = t3 - E)) + (_ - b2), j2 = f2 - (G + (_ = f2 - G)) + (_ - b2), x3 = o3 - (H + (_ = o3 - H)) + (_ - y3), m2 = p2 - (I + (_ = p2 - I)) + (_ - y3), 0 === M2 && 0 === x3 && 0 === j2 && 0 === m2)
              return J;
            if (K = u * h2 + n * Math.abs(J), (J += E * m2 + I * M2 - (H * j2 + G * x3)) >= K || -J >= K)
              return J;
            _ = (z = (A = M2 - (w = (v = e * M2) - (v - M2))) * (O2 = I - (F = (v = e * I) - (v - I))) - ((q = M2 * I) - w * F - A * F - w * O2)) - (P = z - (C = (A = x3 - (w = (v = e * x3) - (v - x3))) * (O2 = G - (F = (v = e * G) - (v - G))) - ((B2 = x3 * G) - w * F - A * F - w * O2))), l[0] = z - (P + _) + (_ - C), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B2), l[1] = k - (P + _) + (_ - B2), _ = (D = g + P) - g, l[2] = g - (D - _) + (P - _), l[3] = D;
            const L = r(4, c, 4, l, s);
            _ = (z = (A = E - (w = (v = e * E) - (v - E))) * (O2 = m2 - (F = (v = e * m2) - (v - m2))) - ((q = E * m2) - w * F - A * F - w * O2)) - (P = z - (C = (A = H - (w = (v = e * H) - (v - H))) * (O2 = j2 - (F = (v = e * j2) - (v - j2))) - ((B2 = H * j2) - w * F - A * F - w * O2))), l[0] = z - (P + _) + (_ - C), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B2), l[1] = k - (P + _) + (_ - B2), _ = (D = g + P) - g, l[2] = g - (D - _) + (P - _), l[3] = D;
            const N = r(L, s, 4, l, a);
            _ = (z = (A = M2 - (w = (v = e * M2) - (v - M2))) * (O2 = m2 - (F = (v = e * m2) - (v - m2))) - ((q = M2 * m2) - w * F - A * F - w * O2)) - (P = z - (C = (A = x3 - (w = (v = e * x3) - (v - x3))) * (O2 = j2 - (F = (v = e * j2) - (v - j2))) - ((B2 = x3 * j2) - w * F - A * F - w * O2))), l[0] = z - (P + _) + (_ - C), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B2), l[1] = k - (P + _) + (_ - B2), _ = (D = g + P) - g, l[2] = g - (D - _) + (P - _), l[3] = D;
            const Q = r(N, a, 4, l, d);
            return d[Q - 1];
          }(t2, o2, p, b, y2, h, m);
        }, t.orient2dfast = function(t2, e3, n2, r2, o2, f2) {
          return (e3 - f2) * (n2 - o2) - (t2 - o2) * (r2 - f2);
        }, Object.defineProperty(t, "__esModule", { value: true });
      });
    }
  });

  // node_modules/concaveman/index.js
  var require_concaveman = __commonJS({
    "node_modules/concaveman/index.js"(exports, module) {
      "use strict";
      var RBush = require_rbush_min2();
      var Queue = require_tinyqueue();
      var pointInPolygon = require_point_in_polygon();
      var orient = require_orient2d_min().orient2d;
      if (Queue.default) {
        Queue = Queue.default;
      }
      module.exports = concaveman2;
      module.exports.default = concaveman2;
      function concaveman2(points, concavity, lengthThreshold) {
        concavity = Math.max(0, concavity === void 0 ? 2 : concavity);
        lengthThreshold = lengthThreshold || 0;
        var hull = fastConvexHull(points);
        var tree = new RBush(16);
        tree.toBBox = function(a2) {
          return {
            minX: a2[0],
            minY: a2[1],
            maxX: a2[0],
            maxY: a2[1]
          };
        };
        tree.compareMinX = function(a2, b2) {
          return a2[0] - b2[0];
        };
        tree.compareMinY = function(a2, b2) {
          return a2[1] - b2[1];
        };
        tree.load(points);
        var queue = [];
        for (var i = 0, last; i < hull.length; i++) {
          var p = hull[i];
          tree.remove(p);
          last = insertNode(p, last);
          queue.push(last);
        }
        var segTree = new RBush(16);
        for (i = 0; i < queue.length; i++)
          segTree.insert(updateBBox(queue[i]));
        var sqConcavity = concavity * concavity;
        var sqLenThreshold = lengthThreshold * lengthThreshold;
        while (queue.length) {
          var node = queue.shift();
          var a = node.p;
          var b = node.next.p;
          var sqLen = getSqDist(a, b);
          if (sqLen < sqLenThreshold)
            continue;
          var maxSqLen = sqLen / sqConcavity;
          p = findCandidate(tree, node.prev.p, a, b, node.next.next.p, maxSqLen, segTree);
          if (p && Math.min(getSqDist(p, a), getSqDist(p, b)) <= maxSqLen) {
            queue.push(node);
            queue.push(insertNode(p, node));
            tree.remove(p);
            segTree.remove(node);
            segTree.insert(updateBBox(node));
            segTree.insert(updateBBox(node.next));
          }
        }
        node = last;
        var concave = [];
        do {
          concave.push(node.p);
          node = node.next;
        } while (node !== last);
        concave.push(node.p);
        return concave;
      }
      function findCandidate(tree, a, b, c, d, maxDist, segTree) {
        var queue = new Queue([], compareDist);
        var node = tree.data;
        while (node) {
          for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];
            var dist = node.leaf ? sqSegDist(child, b, c) : sqSegBoxDist(b, c, child);
            if (dist > maxDist)
              continue;
            queue.push({
              node: child,
              dist
            });
          }
          while (queue.length && !queue.peek().node.children) {
            var item = queue.pop();
            var p = item.node;
            var d0 = sqSegDist(p, a, b);
            var d1 = sqSegDist(p, c, d);
            if (item.dist < d0 && item.dist < d1 && noIntersections(b, p, segTree) && noIntersections(c, p, segTree))
              return p;
          }
          node = queue.pop();
          if (node)
            node = node.node;
        }
        return null;
      }
      function compareDist(a, b) {
        return a.dist - b.dist;
      }
      function sqSegBoxDist(a, b, bbox3) {
        if (inside(a, bbox3) || inside(b, bbox3))
          return 0;
        var d1 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox3.minX, bbox3.minY, bbox3.maxX, bbox3.minY);
        if (d1 === 0)
          return 0;
        var d2 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox3.minX, bbox3.minY, bbox3.minX, bbox3.maxY);
        if (d2 === 0)
          return 0;
        var d3 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox3.maxX, bbox3.minY, bbox3.maxX, bbox3.maxY);
        if (d3 === 0)
          return 0;
        var d4 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox3.minX, bbox3.maxY, bbox3.maxX, bbox3.maxY);
        if (d4 === 0)
          return 0;
        return Math.min(d1, d2, d3, d4);
      }
      function inside(a, bbox3) {
        return a[0] >= bbox3.minX && a[0] <= bbox3.maxX && a[1] >= bbox3.minY && a[1] <= bbox3.maxY;
      }
      function noIntersections(a, b, segTree) {
        var minX = Math.min(a[0], b[0]);
        var minY = Math.min(a[1], b[1]);
        var maxX = Math.max(a[0], b[0]);
        var maxY = Math.max(a[1], b[1]);
        var edges2 = segTree.search({ minX, minY, maxX, maxY });
        for (var i = 0; i < edges2.length; i++) {
          if (intersects2(edges2[i].p, edges2[i].next.p, a, b))
            return false;
        }
        return true;
      }
      function cross(p1, p2, p3) {
        return orient(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
      }
      function intersects2(p1, q1, p2, q2) {
        return p1 !== q2 && q1 !== p2 && cross(p1, q1, p2) > 0 !== cross(p1, q1, q2) > 0 && cross(p2, q2, p1) > 0 !== cross(p2, q2, q1) > 0;
      }
      function updateBBox(node) {
        var p1 = node.p;
        var p2 = node.next.p;
        node.minX = Math.min(p1[0], p2[0]);
        node.minY = Math.min(p1[1], p2[1]);
        node.maxX = Math.max(p1[0], p2[0]);
        node.maxY = Math.max(p1[1], p2[1]);
        return node;
      }
      function fastConvexHull(points) {
        var left = points[0];
        var top = points[0];
        var right = points[0];
        var bottom = points[0];
        for (var i = 0; i < points.length; i++) {
          var p = points[i];
          if (p[0] < left[0])
            left = p;
          if (p[0] > right[0])
            right = p;
          if (p[1] < top[1])
            top = p;
          if (p[1] > bottom[1])
            bottom = p;
        }
        var cull = [left, top, right, bottom];
        var filtered = cull.slice();
        for (i = 0; i < points.length; i++) {
          if (!pointInPolygon(points[i], cull))
            filtered.push(points[i]);
        }
        return convexHull(filtered);
      }
      function insertNode(p, prev) {
        var node = {
          p,
          prev: null,
          next: null,
          minX: 0,
          minY: 0,
          maxX: 0,
          maxY: 0
        };
        if (!prev) {
          node.prev = node;
          node.next = node;
        } else {
          node.next = prev.next;
          node.prev = prev;
          prev.next.prev = node;
          prev.next = node;
        }
        return node;
      }
      function getSqDist(p1, p2) {
        var dx = p1[0] - p2[0], dy = p1[1] - p2[1];
        return dx * dx + dy * dy;
      }
      function sqSegDist(p, p1, p2) {
        var x2 = p1[0], y2 = p1[1], dx = p2[0] - x2, dy = p2[1] - y2;
        if (dx !== 0 || dy !== 0) {
          var t = ((p[0] - x2) * dx + (p[1] - y2) * dy) / (dx * dx + dy * dy);
          if (t > 1) {
            x2 = p2[0];
            y2 = p2[1];
          } else if (t > 0) {
            x2 += dx * t;
            y2 += dy * t;
          }
        }
        dx = p[0] - x2;
        dy = p[1] - y2;
        return dx * dx + dy * dy;
      }
      function sqSegSegDist(x02, y0, x12, y1, x2, y2, x3, y3) {
        var ux = x12 - x02;
        var uy = y1 - y0;
        var vx = x3 - x2;
        var vy = y3 - y2;
        var wx = x02 - x2;
        var wy = y0 - y2;
        var a = ux * ux + uy * uy;
        var b = ux * vx + uy * vy;
        var c = vx * vx + vy * vy;
        var d = ux * wx + uy * wy;
        var e = vx * wx + vy * wy;
        var D = a * c - b * b;
        var sc, sN, tc, tN;
        var sD = D;
        var tD = D;
        if (D === 0) {
          sN = 0;
          sD = 1;
          tN = e;
          tD = c;
        } else {
          sN = b * e - c * d;
          tN = a * e - b * d;
          if (sN < 0) {
            sN = 0;
            tN = e;
            tD = c;
          } else if (sN > sD) {
            sN = sD;
            tN = e + b;
            tD = c;
          }
        }
        if (tN < 0) {
          tN = 0;
          if (-d < 0)
            sN = 0;
          else if (-d > a)
            sN = sD;
          else {
            sN = -d;
            sD = a;
          }
        } else if (tN > tD) {
          tN = tD;
          if (-d + b < 0)
            sN = 0;
          else if (-d + b > a)
            sN = sD;
          else {
            sN = -d + b;
            sD = a;
          }
        }
        sc = sN === 0 ? 0 : sN / sD;
        tc = tN === 0 ? 0 : tN / tD;
        var cx = (1 - sc) * x02 + sc * x12;
        var cy = (1 - sc) * y0 + sc * y1;
        var cx2 = (1 - tc) * x2 + tc * x3;
        var cy2 = (1 - tc) * y2 + tc * y3;
        var dx = cx2 - cx;
        var dy = cy2 - cy;
        return dx * dx + dy * dy;
      }
      function compareByX(a, b) {
        return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0];
      }
      function convexHull(points) {
        points.sort(compareByX);
        var lower = [];
        for (var i = 0; i < points.length; i++) {
          while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0) {
            lower.pop();
          }
          lower.push(points[i]);
        }
        var upper = [];
        for (var ii = points.length - 1; ii >= 0; ii--) {
          while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points[ii]) <= 0) {
            upper.pop();
          }
          upper.push(points[ii]);
        }
        upper.pop();
        lower.pop();
        return lower.concat(upper);
      }
    }
  });

  // node_modules/quickselect/quickselect.js
  var require_quickselect = __commonJS({
    "node_modules/quickselect/quickselect.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.quickselect = factory();
      })(exports, function() {
        "use strict";
        function quickselect(arr, k, left, right, compare) {
          quickselectStep(arr, k, left || 0, right || arr.length - 1, compare || defaultCompare);
        }
        function quickselectStep(arr, k, left, right, compare) {
          while (right > left) {
            if (right - left > 600) {
              var n = right - left + 1;
              var m = k - left + 1;
              var z = Math.log(n);
              var s = 0.5 * Math.exp(2 * z / 3);
              var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
              var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
              var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
              quickselectStep(arr, k, newLeft, newRight, compare);
            }
            var t = arr[k];
            var i = left;
            var j = right;
            swap(arr, left, k);
            if (compare(arr[right], t) > 0)
              swap(arr, left, right);
            while (i < j) {
              swap(arr, i, j);
              i++;
              j--;
              while (compare(arr[i], t) < 0)
                i++;
              while (compare(arr[j], t) > 0)
                j--;
            }
            if (compare(arr[left], t) === 0)
              swap(arr, left, j);
            else {
              j++;
              swap(arr, j, right);
            }
            if (j <= k)
              left = j + 1;
            if (k <= j)
              right = j - 1;
          }
        }
        function swap(arr, i, j) {
          var tmp = arr[i];
          arr[i] = arr[j];
          arr[j] = tmp;
        }
        function defaultCompare(a, b) {
          return a < b ? -1 : a > b ? 1 : 0;
        }
        return quickselect;
      });
    }
  });

  // node_modules/rbush/index.js
  var require_rbush = __commonJS({
    "node_modules/rbush/index.js"(exports, module) {
      "use strict";
      module.exports = rbush6;
      module.exports.default = rbush6;
      var quickselect = require_quickselect();
      function rbush6(maxEntries, format) {
        if (!(this instanceof rbush6))
          return new rbush6(maxEntries, format);
        this._maxEntries = Math.max(4, maxEntries || 9);
        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
        if (format) {
          this._initFormat(format);
        }
        this.clear();
      }
      rbush6.prototype = {
        all: function() {
          return this._all(this.data, []);
        },
        search: function(bbox3) {
          var node = this.data, result = [], toBBox = this.toBBox;
          if (!intersects2(bbox3, node))
            return result;
          var nodesToSearch = [], i, len, child, childBBox;
          while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {
              child = node.children[i];
              childBBox = node.leaf ? toBBox(child) : child;
              if (intersects2(bbox3, childBBox)) {
                if (node.leaf)
                  result.push(child);
                else if (contains(bbox3, childBBox))
                  this._all(child, result);
                else
                  nodesToSearch.push(child);
              }
            }
            node = nodesToSearch.pop();
          }
          return result;
        },
        collides: function(bbox3) {
          var node = this.data, toBBox = this.toBBox;
          if (!intersects2(bbox3, node))
            return false;
          var nodesToSearch = [], i, len, child, childBBox;
          while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {
              child = node.children[i];
              childBBox = node.leaf ? toBBox(child) : child;
              if (intersects2(bbox3, childBBox)) {
                if (node.leaf || contains(bbox3, childBBox))
                  return true;
                nodesToSearch.push(child);
              }
            }
            node = nodesToSearch.pop();
          }
          return false;
        },
        load: function(data) {
          if (!(data && data.length))
            return this;
          if (data.length < this._minEntries) {
            for (var i = 0, len = data.length; i < len; i++) {
              this.insert(data[i]);
            }
            return this;
          }
          var node = this._build(data.slice(), 0, data.length - 1, 0);
          if (!this.data.children.length) {
            this.data = node;
          } else if (this.data.height === node.height) {
            this._splitRoot(this.data, node);
          } else {
            if (this.data.height < node.height) {
              var tmpNode = this.data;
              this.data = node;
              node = tmpNode;
            }
            this._insert(node, this.data.height - node.height - 1, true);
          }
          return this;
        },
        insert: function(item) {
          if (item)
            this._insert(item, this.data.height - 1);
          return this;
        },
        clear: function() {
          this.data = createNode([]);
          return this;
        },
        remove: function(item, equalsFn) {
          if (!item)
            return this;
          var node = this.data, bbox3 = this.toBBox(item), path = [], indexes = [], i, parent, index, goingUp;
          while (node || path.length) {
            if (!node) {
              node = path.pop();
              parent = path[path.length - 1];
              i = indexes.pop();
              goingUp = true;
            }
            if (node.leaf) {
              index = findItem(item, node.children, equalsFn);
              if (index !== -1) {
                node.children.splice(index, 1);
                path.push(node);
                this._condense(path);
                return this;
              }
            }
            if (!goingUp && !node.leaf && contains(node, bbox3)) {
              path.push(node);
              indexes.push(i);
              i = 0;
              parent = node;
              node = node.children[0];
            } else if (parent) {
              i++;
              node = parent.children[i];
              goingUp = false;
            } else
              node = null;
          }
          return this;
        },
        toBBox: function(item) {
          return item;
        },
        compareMinX: compareNodeMinX,
        compareMinY: compareNodeMinY,
        toJSON: function() {
          return this.data;
        },
        fromJSON: function(data) {
          this.data = data;
          return this;
        },
        _all: function(node, result) {
          var nodesToSearch = [];
          while (node) {
            if (node.leaf)
              result.push.apply(result, node.children);
            else
              nodesToSearch.push.apply(nodesToSearch, node.children);
            node = nodesToSearch.pop();
          }
          return result;
        },
        _build: function(items, left, right, height) {
          var N = right - left + 1, M = this._maxEntries, node;
          if (N <= M) {
            node = createNode(items.slice(left, right + 1));
            calcBBox(node, this.toBBox);
            return node;
          }
          if (!height) {
            height = Math.ceil(Math.log(N) / Math.log(M));
            M = Math.ceil(N / Math.pow(M, height - 1));
          }
          node = createNode([]);
          node.leaf = false;
          node.height = height;
          var N2 = Math.ceil(N / M), N1 = N2 * Math.ceil(Math.sqrt(M)), i, j, right2, right3;
          multiSelect(items, left, right, N1, this.compareMinX);
          for (i = left; i <= right; i += N1) {
            right2 = Math.min(i + N1 - 1, right);
            multiSelect(items, i, right2, N2, this.compareMinY);
            for (j = i; j <= right2; j += N2) {
              right3 = Math.min(j + N2 - 1, right2);
              node.children.push(this._build(items, j, right3, height - 1));
            }
          }
          calcBBox(node, this.toBBox);
          return node;
        },
        _chooseSubtree: function(bbox3, node, level, path) {
          var i, len, child, targetNode, area2, enlargement, minArea, minEnlargement;
          while (true) {
            path.push(node);
            if (node.leaf || path.length - 1 === level)
              break;
            minArea = minEnlargement = Infinity;
            for (i = 0, len = node.children.length; i < len; i++) {
              child = node.children[i];
              area2 = bboxArea(child);
              enlargement = enlargedArea(bbox3, child) - area2;
              if (enlargement < minEnlargement) {
                minEnlargement = enlargement;
                minArea = area2 < minArea ? area2 : minArea;
                targetNode = child;
              } else if (enlargement === minEnlargement) {
                if (area2 < minArea) {
                  minArea = area2;
                  targetNode = child;
                }
              }
            }
            node = targetNode || node.children[0];
          }
          return node;
        },
        _insert: function(item, level, isNode) {
          var toBBox = this.toBBox, bbox3 = isNode ? item : toBBox(item), insertPath = [];
          var node = this._chooseSubtree(bbox3, this.data, level, insertPath);
          node.children.push(item);
          extend(node, bbox3);
          while (level >= 0) {
            if (insertPath[level].children.length > this._maxEntries) {
              this._split(insertPath, level);
              level--;
            } else
              break;
          }
          this._adjustParentBBoxes(bbox3, insertPath, level);
        },
        _split: function(insertPath, level) {
          var node = insertPath[level], M = node.children.length, m = this._minEntries;
          this._chooseSplitAxis(node, m, M);
          var splitIndex = this._chooseSplitIndex(node, m, M);
          var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
          newNode.height = node.height;
          newNode.leaf = node.leaf;
          calcBBox(node, this.toBBox);
          calcBBox(newNode, this.toBBox);
          if (level)
            insertPath[level - 1].children.push(newNode);
          else
            this._splitRoot(node, newNode);
        },
        _splitRoot: function(node, newNode) {
          this.data = createNode([node, newNode]);
          this.data.height = node.height + 1;
          this.data.leaf = false;
          calcBBox(this.data, this.toBBox);
        },
        _chooseSplitIndex: function(node, m, M) {
          var i, bbox1, bbox22, overlap, area2, minOverlap, minArea, index;
          minOverlap = minArea = Infinity;
          for (i = m; i <= M - m; i++) {
            bbox1 = distBBox(node, 0, i, this.toBBox);
            bbox22 = distBBox(node, i, M, this.toBBox);
            overlap = intersectionArea(bbox1, bbox22);
            area2 = bboxArea(bbox1) + bboxArea(bbox22);
            if (overlap < minOverlap) {
              minOverlap = overlap;
              index = i;
              minArea = area2 < minArea ? area2 : minArea;
            } else if (overlap === minOverlap) {
              if (area2 < minArea) {
                minArea = area2;
                index = i;
              }
            }
          }
          return index;
        },
        _chooseSplitAxis: function(node, m, M) {
          var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX, compareMinY = node.leaf ? this.compareMinY : compareNodeMinY, xMargin = this._allDistMargin(node, m, M, compareMinX), yMargin = this._allDistMargin(node, m, M, compareMinY);
          if (xMargin < yMargin)
            node.children.sort(compareMinX);
        },
        _allDistMargin: function(node, m, M, compare) {
          node.children.sort(compare);
          var toBBox = this.toBBox, leftBBox = distBBox(node, 0, m, toBBox), rightBBox = distBBox(node, M - m, M, toBBox), margin = bboxMargin(leftBBox) + bboxMargin(rightBBox), i, child;
          for (i = m; i < M - m; i++) {
            child = node.children[i];
            extend(leftBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(leftBBox);
          }
          for (i = M - m - 1; i >= m; i--) {
            child = node.children[i];
            extend(rightBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(rightBBox);
          }
          return margin;
        },
        _adjustParentBBoxes: function(bbox3, path, level) {
          for (var i = level; i >= 0; i--) {
            extend(path[i], bbox3);
          }
        },
        _condense: function(path) {
          for (var i = path.length - 1, siblings; i >= 0; i--) {
            if (path[i].children.length === 0) {
              if (i > 0) {
                siblings = path[i - 1].children;
                siblings.splice(siblings.indexOf(path[i]), 1);
              } else
                this.clear();
            } else
              calcBBox(path[i], this.toBBox);
          }
        },
        _initFormat: function(format) {
          var compareArr = ["return a", " - b", ";"];
          this.compareMinX = new Function("a", "b", compareArr.join(format[0]));
          this.compareMinY = new Function("a", "b", compareArr.join(format[1]));
          this.toBBox = new Function(
            "a",
            "return {minX: a" + format[0] + ", minY: a" + format[1] + ", maxX: a" + format[2] + ", maxY: a" + format[3] + "};"
          );
        }
      };
      function findItem(item, items, equalsFn) {
        if (!equalsFn)
          return items.indexOf(item);
        for (var i = 0; i < items.length; i++) {
          if (equalsFn(item, items[i]))
            return i;
        }
        return -1;
      }
      function calcBBox(node, toBBox) {
        distBBox(node, 0, node.children.length, toBBox, node);
      }
      function distBBox(node, k, p, toBBox, destNode) {
        if (!destNode)
          destNode = createNode(null);
        destNode.minX = Infinity;
        destNode.minY = Infinity;
        destNode.maxX = -Infinity;
        destNode.maxY = -Infinity;
        for (var i = k, child; i < p; i++) {
          child = node.children[i];
          extend(destNode, node.leaf ? toBBox(child) : child);
        }
        return destNode;
      }
      function extend(a, b) {
        a.minX = Math.min(a.minX, b.minX);
        a.minY = Math.min(a.minY, b.minY);
        a.maxX = Math.max(a.maxX, b.maxX);
        a.maxY = Math.max(a.maxY, b.maxY);
        return a;
      }
      function compareNodeMinX(a, b) {
        return a.minX - b.minX;
      }
      function compareNodeMinY(a, b) {
        return a.minY - b.minY;
      }
      function bboxArea(a) {
        return (a.maxX - a.minX) * (a.maxY - a.minY);
      }
      function bboxMargin(a) {
        return a.maxX - a.minX + (a.maxY - a.minY);
      }
      function enlargedArea(a, b) {
        return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
      }
      function intersectionArea(a, b) {
        var minX = Math.max(a.minX, b.minX), minY = Math.max(a.minY, b.minY), maxX = Math.min(a.maxX, b.maxX), maxY = Math.min(a.maxY, b.maxY);
        return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
      }
      function contains(a, b) {
        return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
      }
      function intersects2(a, b) {
        return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
      }
      function createNode(children) {
        return {
          children,
          height: 1,
          leaf: true,
          minX: Infinity,
          minY: Infinity,
          maxX: -Infinity,
          maxY: -Infinity
        };
      }
      function multiSelect(arr, left, right, n, compare) {
        var stack = [left, right], mid;
        while (stack.length) {
          right = stack.pop();
          left = stack.pop();
          if (right - left <= n)
            continue;
          mid = left + Math.ceil((right - left) / n / 2) * n;
          quickselect(arr, mid, left, right, compare);
          stack.push(left, mid, mid, right);
        }
      }
    }
  });

  // node_modules/earcut/src/earcut.js
  var require_earcut = __commonJS({
    "node_modules/earcut/src/earcut.js"(exports, module) {
      "use strict";
      module.exports = earcut2;
      module.exports.default = earcut2;
      function earcut2(data, holeIndices, dim) {
        dim = dim || 2;
        var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
        if (!outerNode || outerNode.next === outerNode.prev)
          return triangles;
        var minX, minY, maxX, maxY, x2, y2, invSize;
        if (hasHoles)
          outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
        if (data.length > 80 * dim) {
          minX = maxX = data[0];
          minY = maxY = data[1];
          for (var i = dim; i < outerLen; i += dim) {
            x2 = data[i];
            y2 = data[i + 1];
            if (x2 < minX)
              minX = x2;
            if (y2 < minY)
              minY = y2;
            if (x2 > maxX)
              maxX = x2;
            if (y2 > maxY)
              maxY = y2;
          }
          invSize = Math.max(maxX - minX, maxY - minY);
          invSize = invSize !== 0 ? 1 / invSize : 0;
        }
        earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
        return triangles;
      }
      function linkedList(data, start, end, dim, clockwise) {
        var i, last;
        if (clockwise === signedArea(data, start, end, dim) > 0) {
          for (i = start; i < end; i += dim)
            last = insertNode(i, data[i], data[i + 1], last);
        } else {
          for (i = end - dim; i >= start; i -= dim)
            last = insertNode(i, data[i], data[i + 1], last);
        }
        if (last && equals(last, last.next)) {
          removeNode(last);
          last = last.next;
        }
        return last;
      }
      function filterPoints(start, end) {
        if (!start)
          return start;
        if (!end)
          end = start;
        var p = start, again;
        do {
          again = false;
          if (!p.steiner && (equals(p, p.next) || area2(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next)
              break;
            again = true;
          } else {
            p = p.next;
          }
        } while (again || p !== end);
        return end;
      }
      function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
        if (!ear)
          return;
        if (!pass && invSize)
          indexCurve(ear, minX, minY, invSize);
        var stop = ear, prev, next;
        while (ear.prev !== ear.next) {
          prev = ear.prev;
          next = ear.next;
          if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);
            removeNode(ear);
            ear = next.next;
            stop = next.next;
            continue;
          }
          ear = next;
          if (ear === stop) {
            if (!pass) {
              earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
            } else if (pass === 1) {
              ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
              earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
            } else if (pass === 2) {
              splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }
            break;
          }
        }
      }
      function isEar(ear) {
        var a = ear.prev, b = ear, c = ear.next;
        if (area2(a, b, c) >= 0)
          return false;
        var p = ear.next.next;
        while (p !== ear.prev) {
          if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area2(p.prev, p, p.next) >= 0)
            return false;
          p = p.next;
        }
        return true;
      }
      function isEarHashed(ear, minX, minY, invSize) {
        var a = ear.prev, b = ear, c = ear.next;
        if (area2(a, b, c) >= 0)
          return false;
        var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
        var minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
        var p = ear.prevZ, n = ear.nextZ;
        while (p && p.z >= minZ && n && n.z <= maxZ) {
          if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area2(p.prev, p, p.next) >= 0)
            return false;
          p = p.prevZ;
          if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area2(n.prev, n, n.next) >= 0)
            return false;
          n = n.nextZ;
        }
        while (p && p.z >= minZ) {
          if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area2(p.prev, p, p.next) >= 0)
            return false;
          p = p.prevZ;
        }
        while (n && n.z <= maxZ) {
          if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area2(n.prev, n, n.next) >= 0)
            return false;
          n = n.nextZ;
        }
        return true;
      }
      function cureLocalIntersections(start, triangles, dim) {
        var p = start;
        do {
          var a = p.prev, b = p.next.next;
          if (!equals(a, b) && intersects2(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);
            removeNode(p);
            removeNode(p.next);
            p = start = b;
          }
          p = p.next;
        } while (p !== start);
        return filterPoints(p);
      }
      function splitEarcut(start, triangles, dim, minX, minY, invSize) {
        var a = start;
        do {
          var b = a.next.next;
          while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
              var c = splitPolygon(a, b);
              a = filterPoints(a, a.next);
              c = filterPoints(c, c.next);
              earcutLinked(a, triangles, dim, minX, minY, invSize);
              earcutLinked(c, triangles, dim, minX, minY, invSize);
              return;
            }
            b = b.next;
          }
          a = a.next;
        } while (a !== start);
      }
      function eliminateHoles(data, holeIndices, outerNode, dim) {
        var queue = [], i, len, start, end, list;
        for (i = 0, len = holeIndices.length; i < len; i++) {
          start = holeIndices[i] * dim;
          end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
          list = linkedList(data, start, end, dim, false);
          if (list === list.next)
            list.steiner = true;
          queue.push(getLeftmost(list));
        }
        queue.sort(compareX);
        for (i = 0; i < queue.length; i++) {
          outerNode = eliminateHole(queue[i], outerNode);
          outerNode = filterPoints(outerNode, outerNode.next);
        }
        return outerNode;
      }
      function compareX(a, b) {
        return a.x - b.x;
      }
      function eliminateHole(hole, outerNode) {
        var bridge = findHoleBridge(hole, outerNode);
        if (!bridge) {
          return outerNode;
        }
        var bridgeReverse = splitPolygon(bridge, hole);
        var filteredBridge = filterPoints(bridge, bridge.next);
        filterPoints(bridgeReverse, bridgeReverse.next);
        return outerNode === bridge ? filteredBridge : outerNode;
      }
      function findHoleBridge(hole, outerNode) {
        var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
        do {
          if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x2 = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x2 <= hx && x2 > qx) {
              qx = x2;
              if (x2 === hx) {
                if (hy === p.y)
                  return p;
                if (hy === p.next.y)
                  return p.next;
              }
              m = p.x < p.next.x ? p : p.next;
            }
          }
          p = p.next;
        } while (p !== outerNode);
        if (!m)
          return null;
        if (hx === qx)
          return m;
        var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan2;
        p = m;
        do {
          if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
            tan2 = Math.abs(hy - p.y) / (hx - p.x);
            if (locallyInside(p, hole) && (tan2 < tanMin || tan2 === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
              m = p;
              tanMin = tan2;
            }
          }
          p = p.next;
        } while (p !== stop);
        return m;
      }
      function sectorContainsSector(m, p) {
        return area2(m.prev, m, p.prev) < 0 && area2(p.next, m, m.next) < 0;
      }
      function indexCurve(start, minX, minY, invSize) {
        var p = start;
        do {
          if (p.z === null)
            p.z = zOrder(p.x, p.y, minX, minY, invSize);
          p.prevZ = p.prev;
          p.nextZ = p.next;
          p = p.next;
        } while (p !== start);
        p.prevZ.nextZ = null;
        p.prevZ = null;
        sortLinked(p);
      }
      function sortLinked(list) {
        var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
        do {
          p = list;
          list = null;
          tail = null;
          numMerges = 0;
          while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
              pSize++;
              q = q.nextZ;
              if (!q)
                break;
            }
            qSize = inSize;
            while (pSize > 0 || qSize > 0 && q) {
              if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                e = p;
                p = p.nextZ;
                pSize--;
              } else {
                e = q;
                q = q.nextZ;
                qSize--;
              }
              if (tail)
                tail.nextZ = e;
              else
                list = e;
              e.prevZ = tail;
              tail = e;
            }
            p = q;
          }
          tail.nextZ = null;
          inSize *= 2;
        } while (numMerges > 1);
        return list;
      }
      function zOrder(x2, y2, minX, minY, invSize) {
        x2 = 32767 * (x2 - minX) * invSize;
        y2 = 32767 * (y2 - minY) * invSize;
        x2 = (x2 | x2 << 8) & 16711935;
        x2 = (x2 | x2 << 4) & 252645135;
        x2 = (x2 | x2 << 2) & 858993459;
        x2 = (x2 | x2 << 1) & 1431655765;
        y2 = (y2 | y2 << 8) & 16711935;
        y2 = (y2 | y2 << 4) & 252645135;
        y2 = (y2 | y2 << 2) & 858993459;
        y2 = (y2 | y2 << 1) & 1431655765;
        return x2 | y2 << 1;
      }
      function getLeftmost(start) {
        var p = start, leftmost = start;
        do {
          if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
            leftmost = p;
          p = p.next;
        } while (p !== start);
        return leftmost;
      }
      function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
      }
      function isValidDiagonal(a, b) {
        return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (area2(a.prev, a, b.prev) || area2(a, b.prev, b)) || equals(a, b) && area2(a.prev, a, a.next) > 0 && area2(b.prev, b, b.next) > 0);
      }
      function area2(p, q, r) {
        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
      }
      function equals(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
      }
      function intersects2(p1, q1, p2, q2) {
        var o1 = sign2(area2(p1, q1, p2));
        var o2 = sign2(area2(p1, q1, q2));
        var o3 = sign2(area2(p2, q2, p1));
        var o4 = sign2(area2(p2, q2, q1));
        if (o1 !== o2 && o3 !== o4)
          return true;
        if (o1 === 0 && onSegment(p1, p2, q1))
          return true;
        if (o2 === 0 && onSegment(p1, q2, q1))
          return true;
        if (o3 === 0 && onSegment(p2, p1, q2))
          return true;
        if (o4 === 0 && onSegment(p2, q1, q2))
          return true;
        return false;
      }
      function onSegment(p, q, r) {
        return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
      }
      function sign2(num) {
        return num > 0 ? 1 : num < 0 ? -1 : 0;
      }
      function intersectsPolygon(a, b) {
        var p = a;
        do {
          if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects2(p, p.next, a, b))
            return true;
          p = p.next;
        } while (p !== a);
        return false;
      }
      function locallyInside(a, b) {
        return area2(a.prev, a, a.next) < 0 ? area2(a, b, a.next) >= 0 && area2(a, a.prev, b) >= 0 : area2(a, b, a.prev) < 0 || area2(a, a.next, b) < 0;
      }
      function middleInside(a, b) {
        var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
        do {
          if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)
            inside = !inside;
          p = p.next;
        } while (p !== a);
        return inside;
      }
      function splitPolygon(a, b) {
        var a2 = new Node2(a.i, a.x, a.y), b2 = new Node2(b.i, b.x, b.y), an = a.next, bp = b.prev;
        a.next = b;
        b.prev = a;
        a2.next = an;
        an.prev = a2;
        b2.next = a2;
        a2.prev = b2;
        bp.next = b2;
        b2.prev = bp;
        return b2;
      }
      function insertNode(i, x2, y2, last) {
        var p = new Node2(i, x2, y2);
        if (!last) {
          p.prev = p;
          p.next = p;
        } else {
          p.next = last.next;
          p.prev = last;
          last.next.prev = p;
          last.next = p;
        }
        return p;
      }
      function removeNode(p) {
        p.next.prev = p.prev;
        p.prev.next = p.next;
        if (p.prevZ)
          p.prevZ.nextZ = p.nextZ;
        if (p.nextZ)
          p.nextZ.prevZ = p.prevZ;
      }
      function Node2(i, x2, y2) {
        this.i = i;
        this.x = x2;
        this.y = y2;
        this.prev = null;
        this.next = null;
        this.z = null;
        this.prevZ = null;
        this.nextZ = null;
        this.steiner = false;
      }
      earcut2.deviation = function(data, holeIndices, dim, triangles) {
        var hasHoles = holeIndices && holeIndices.length;
        var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
        var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
        if (hasHoles) {
          for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
          }
        }
        var trianglesArea = 0;
        for (i = 0; i < triangles.length; i += 3) {
          var a = triangles[i] * dim;
          var b = triangles[i + 1] * dim;
          var c = triangles[i + 2] * dim;
          trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1])
          );
        }
        return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
      };
      function signedArea(data, start, end, dim) {
        var sum2 = 0;
        for (var i = start, j = end - dim; i < end; i += dim) {
          sum2 += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
          j = i;
        }
        return sum2;
      }
      earcut2.flatten = function(data) {
        var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
        for (var i = 0; i < data.length; i++) {
          for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++)
              result.vertices.push(data[i][j][d]);
          }
          if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
          }
        }
        return result;
      };
    }
  });

  // node_modules/object-keys/isArguments.js
  var require_isArguments = __commonJS({
    "node_modules/object-keys/isArguments.js"(exports, module) {
      "use strict";
      var toStr = Object.prototype.toString;
      module.exports = function isArguments(value) {
        var str = toStr.call(value);
        var isArgs = str === "[object Arguments]";
        if (!isArgs) {
          isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
        }
        return isArgs;
      };
    }
  });

  // node_modules/object-keys/implementation.js
  var require_implementation = __commonJS({
    "node_modules/object-keys/implementation.js"(exports, module) {
      "use strict";
      var keysShim;
      if (!Object.keys) {
        has = Object.prototype.hasOwnProperty;
        toStr = Object.prototype.toString;
        isArgs = require_isArguments();
        isEnumerable = Object.prototype.propertyIsEnumerable;
        hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
        hasProtoEnumBug = isEnumerable.call(function() {
        }, "prototype");
        dontEnums = [
          "toString",
          "toLocaleString",
          "valueOf",
          "hasOwnProperty",
          "isPrototypeOf",
          "propertyIsEnumerable",
          "constructor"
        ];
        equalsConstructorPrototype = function(o) {
          var ctor = o.constructor;
          return ctor && ctor.prototype === o;
        };
        excludedKeys = {
          $applicationCache: true,
          $console: true,
          $external: true,
          $frame: true,
          $frameElement: true,
          $frames: true,
          $innerHeight: true,
          $innerWidth: true,
          $onmozfullscreenchange: true,
          $onmozfullscreenerror: true,
          $outerHeight: true,
          $outerWidth: true,
          $pageXOffset: true,
          $pageYOffset: true,
          $parent: true,
          $scrollLeft: true,
          $scrollTop: true,
          $scrollX: true,
          $scrollY: true,
          $self: true,
          $webkitIndexedDB: true,
          $webkitStorageInfo: true,
          $window: true
        };
        hasAutomationEqualityBug = function() {
          if (typeof window === "undefined") {
            return false;
          }
          for (var k in window) {
            try {
              if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
                try {
                  equalsConstructorPrototype(window[k]);
                } catch (e) {
                  return true;
                }
              }
            } catch (e) {
              return true;
            }
          }
          return false;
        }();
        equalsConstructorPrototypeIfNotBuggy = function(o) {
          if (typeof window === "undefined" || !hasAutomationEqualityBug) {
            return equalsConstructorPrototype(o);
          }
          try {
            return equalsConstructorPrototype(o);
          } catch (e) {
            return false;
          }
        };
        keysShim = function keys(object2) {
          var isObject2 = object2 !== null && typeof object2 === "object";
          var isFunction = toStr.call(object2) === "[object Function]";
          var isArguments = isArgs(object2);
          var isString = isObject2 && toStr.call(object2) === "[object String]";
          var theKeys = [];
          if (!isObject2 && !isFunction && !isArguments) {
            throw new TypeError("Object.keys called on a non-object");
          }
          var skipProto = hasProtoEnumBug && isFunction;
          if (isString && object2.length > 0 && !has.call(object2, 0)) {
            for (var i = 0; i < object2.length; ++i) {
              theKeys.push(String(i));
            }
          }
          if (isArguments && object2.length > 0) {
            for (var j = 0; j < object2.length; ++j) {
              theKeys.push(String(j));
            }
          } else {
            for (var name in object2) {
              if (!(skipProto && name === "prototype") && has.call(object2, name)) {
                theKeys.push(String(name));
              }
            }
          }
          if (hasDontEnumBug) {
            var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object2);
            for (var k = 0; k < dontEnums.length; ++k) {
              if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object2, dontEnums[k])) {
                theKeys.push(dontEnums[k]);
              }
            }
          }
          return theKeys;
        };
      }
      var has;
      var toStr;
      var isArgs;
      var isEnumerable;
      var hasDontEnumBug;
      var hasProtoEnumBug;
      var dontEnums;
      var equalsConstructorPrototype;
      var excludedKeys;
      var hasAutomationEqualityBug;
      var equalsConstructorPrototypeIfNotBuggy;
      module.exports = keysShim;
    }
  });

  // node_modules/object-keys/index.js
  var require_object_keys = __commonJS({
    "node_modules/object-keys/index.js"(exports, module) {
      "use strict";
      var slice2 = Array.prototype.slice;
      var isArgs = require_isArguments();
      var origKeys = Object.keys;
      var keysShim = origKeys ? function keys(o) {
        return origKeys(o);
      } : require_implementation();
      var originalKeys = Object.keys;
      keysShim.shim = function shimObjectKeys() {
        if (Object.keys) {
          var keysWorksWithArguments = function() {
            var args = Object.keys(arguments);
            return args && args.length === arguments.length;
          }(1, 2);
          if (!keysWorksWithArguments) {
            Object.keys = function keys(object2) {
              if (isArgs(object2)) {
                return originalKeys(slice2.call(object2));
              }
              return originalKeys(object2);
            };
          }
        } else {
          Object.keys = keysShim;
        }
        return Object.keys || keysShim;
      };
      module.exports = keysShim;
    }
  });

  // node_modules/has-symbols/shams.js
  var require_shams = __commonJS({
    "node_modules/has-symbols/shams.js"(exports, module) {
      "use strict";
      module.exports = function hasSymbols() {
        if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
          return false;
        }
        if (typeof Symbol.iterator === "symbol") {
          return true;
        }
        var obj = {};
        var sym = Symbol("test");
        var symObj = Object(sym);
        if (typeof sym === "string") {
          return false;
        }
        if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
          return false;
        }
        if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
          return false;
        }
        var symVal = 42;
        obj[sym] = symVal;
        for (sym in obj) {
          return false;
        }
        if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
          return false;
        }
        if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
          return false;
        }
        var syms = Object.getOwnPropertySymbols(obj);
        if (syms.length !== 1 || syms[0] !== sym) {
          return false;
        }
        if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
          return false;
        }
        if (typeof Object.getOwnPropertyDescriptor === "function") {
          var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
          if (descriptor.value !== symVal || descriptor.enumerable !== true) {
            return false;
          }
        }
        return true;
      };
    }
  });

  // node_modules/has-tostringtag/shams.js
  var require_shams2 = __commonJS({
    "node_modules/has-tostringtag/shams.js"(exports, module) {
      "use strict";
      var hasSymbols = require_shams();
      module.exports = function hasToStringTagShams() {
        return hasSymbols() && !!Symbol.toStringTag;
      };
    }
  });

  // node_modules/has-symbols/index.js
  var require_has_symbols = __commonJS({
    "node_modules/has-symbols/index.js"(exports, module) {
      "use strict";
      var origSymbol = typeof Symbol !== "undefined" && Symbol;
      var hasSymbolSham = require_shams();
      module.exports = function hasNativeSymbols() {
        if (typeof origSymbol !== "function") {
          return false;
        }
        if (typeof Symbol !== "function") {
          return false;
        }
        if (typeof origSymbol("foo") !== "symbol") {
          return false;
        }
        if (typeof Symbol("bar") !== "symbol") {
          return false;
        }
        return hasSymbolSham();
      };
    }
  });

  // node_modules/function-bind/implementation.js
  var require_implementation2 = __commonJS({
    "node_modules/function-bind/implementation.js"(exports, module) {
      "use strict";
      var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
      var slice2 = Array.prototype.slice;
      var toStr = Object.prototype.toString;
      var funcType = "[object Function]";
      module.exports = function bind(that) {
        var target = this;
        if (typeof target !== "function" || toStr.call(target) !== funcType) {
          throw new TypeError(ERROR_MESSAGE + target);
        }
        var args = slice2.call(arguments, 1);
        var bound;
        var binder = function() {
          if (this instanceof bound) {
            var result = target.apply(
              this,
              args.concat(slice2.call(arguments))
            );
            if (Object(result) === result) {
              return result;
            }
            return this;
          } else {
            return target.apply(
              that,
              args.concat(slice2.call(arguments))
            );
          }
        };
        var boundLength = Math.max(0, target.length - args.length);
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
          boundArgs.push("$" + i);
        }
        bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
        if (target.prototype) {
          var Empty = function Empty2() {
          };
          Empty.prototype = target.prototype;
          bound.prototype = new Empty();
          Empty.prototype = null;
        }
        return bound;
      };
    }
  });

  // node_modules/function-bind/index.js
  var require_function_bind = __commonJS({
    "node_modules/function-bind/index.js"(exports, module) {
      "use strict";
      var implementation = require_implementation2();
      module.exports = Function.prototype.bind || implementation;
    }
  });

  // node_modules/has/src/index.js
  var require_src = __commonJS({
    "node_modules/has/src/index.js"(exports, module) {
      "use strict";
      var bind = require_function_bind();
      module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
    }
  });

  // node_modules/get-intrinsic/index.js
  var require_get_intrinsic = __commonJS({
    "node_modules/get-intrinsic/index.js"(exports, module) {
      "use strict";
      var undefined2;
      var $SyntaxError = SyntaxError;
      var $Function = Function;
      var $TypeError = TypeError;
      var getEvalledConstructor = function(expressionSyntax) {
        try {
          return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
        } catch (e) {
        }
      };
      var $gOPD = Object.getOwnPropertyDescriptor;
      if ($gOPD) {
        try {
          $gOPD({}, "");
        } catch (e) {
          $gOPD = null;
        }
      }
      var throwTypeError = function() {
        throw new $TypeError();
      };
      var ThrowTypeError = $gOPD ? function() {
        try {
          arguments.callee;
          return throwTypeError;
        } catch (calleeThrows) {
          try {
            return $gOPD(arguments, "callee").get;
          } catch (gOPDthrows) {
            return throwTypeError;
          }
        }
      }() : throwTypeError;
      var hasSymbols = require_has_symbols()();
      var getProto = Object.getPrototypeOf || function(x2) {
        return x2.__proto__;
      };
      var needsEval = {};
      var TypedArray = typeof Uint8Array === "undefined" ? undefined2 : getProto(Uint8Array);
      var INTRINSICS = {
        "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
        "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined2,
        "%AsyncFromSyncIteratorPrototype%": undefined2,
        "%AsyncFunction%": needsEval,
        "%AsyncGenerator%": needsEval,
        "%AsyncGeneratorFunction%": needsEval,
        "%AsyncIteratorPrototype%": needsEval,
        "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
        "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": Error,
        "%eval%": eval,
        "%EvalError%": EvalError,
        "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
        "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
        "%Function%": $Function,
        "%GeneratorFunction%": needsEval,
        "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
        "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
        "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined2,
        "%JSON%": typeof JSON === "object" ? JSON : undefined2,
        "%Map%": typeof Map === "undefined" ? undefined2 : Map,
        "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": Object,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
        "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
        "%RangeError%": RangeError,
        "%ReferenceError%": ReferenceError,
        "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set === "undefined" ? undefined2 : Set,
        "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined2,
        "%Symbol%": hasSymbols ? Symbol : undefined2,
        "%SyntaxError%": $SyntaxError,
        "%ThrowTypeError%": ThrowTypeError,
        "%TypedArray%": TypedArray,
        "%TypeError%": $TypeError,
        "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
        "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
        "%URIError%": URIError,
        "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
        "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
        "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
      };
      var doEval = function doEval2(name) {
        var value;
        if (name === "%AsyncFunction%") {
          value = getEvalledConstructor("async function () {}");
        } else if (name === "%GeneratorFunction%") {
          value = getEvalledConstructor("function* () {}");
        } else if (name === "%AsyncGeneratorFunction%") {
          value = getEvalledConstructor("async function* () {}");
        } else if (name === "%AsyncGenerator%") {
          var fn = doEval2("%AsyncGeneratorFunction%");
          if (fn) {
            value = fn.prototype;
          }
        } else if (name === "%AsyncIteratorPrototype%") {
          var gen = doEval2("%AsyncGenerator%");
          if (gen) {
            value = getProto(gen.prototype);
          }
        }
        INTRINSICS[name] = value;
        return value;
      };
      var LEGACY_ALIASES = {
        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
        "%ArrayPrototype%": ["Array", "prototype"],
        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
        "%ArrayProto_values%": ["Array", "prototype", "values"],
        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
        "%BooleanPrototype%": ["Boolean", "prototype"],
        "%DataViewPrototype%": ["DataView", "prototype"],
        "%DatePrototype%": ["Date", "prototype"],
        "%ErrorPrototype%": ["Error", "prototype"],
        "%EvalErrorPrototype%": ["EvalError", "prototype"],
        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
        "%FunctionPrototype%": ["Function", "prototype"],
        "%Generator%": ["GeneratorFunction", "prototype"],
        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
        "%JSONParse%": ["JSON", "parse"],
        "%JSONStringify%": ["JSON", "stringify"],
        "%MapPrototype%": ["Map", "prototype"],
        "%NumberPrototype%": ["Number", "prototype"],
        "%ObjectPrototype%": ["Object", "prototype"],
        "%ObjProto_toString%": ["Object", "prototype", "toString"],
        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
        "%PromisePrototype%": ["Promise", "prototype"],
        "%PromiseProto_then%": ["Promise", "prototype", "then"],
        "%Promise_all%": ["Promise", "all"],
        "%Promise_reject%": ["Promise", "reject"],
        "%Promise_resolve%": ["Promise", "resolve"],
        "%RangeErrorPrototype%": ["RangeError", "prototype"],
        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
        "%RegExpPrototype%": ["RegExp", "prototype"],
        "%SetPrototype%": ["Set", "prototype"],
        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
        "%StringPrototype%": ["String", "prototype"],
        "%SymbolPrototype%": ["Symbol", "prototype"],
        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
        "%TypeErrorPrototype%": ["TypeError", "prototype"],
        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
        "%URIErrorPrototype%": ["URIError", "prototype"],
        "%WeakMapPrototype%": ["WeakMap", "prototype"],
        "%WeakSetPrototype%": ["WeakSet", "prototype"]
      };
      var bind = require_function_bind();
      var hasOwn = require_src();
      var $concat = bind.call(Function.call, Array.prototype.concat);
      var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
      var $replace = bind.call(Function.call, String.prototype.replace);
      var $strSlice = bind.call(Function.call, String.prototype.slice);
      var $exec = bind.call(Function.call, RegExp.prototype.exec);
      var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = function stringToPath2(string) {
        var first = $strSlice(string, 0, 1);
        var last = $strSlice(string, -1);
        if (first === "%" && last !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
        } else if (last === "%" && first !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
        }
        var result = [];
        $replace(string, rePropName, function(match, number, quote, subString) {
          result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
        });
        return result;
      };
      var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
        var intrinsicName = name;
        var alias;
        if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
          alias = LEGACY_ALIASES[intrinsicName];
          intrinsicName = "%" + alias[0] + "%";
        }
        if (hasOwn(INTRINSICS, intrinsicName)) {
          var value = INTRINSICS[intrinsicName];
          if (value === needsEval) {
            value = doEval(intrinsicName);
          }
          if (typeof value === "undefined" && !allowMissing) {
            throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
          }
          return {
            alias,
            name: intrinsicName,
            value
          };
        }
        throw new $SyntaxError("intrinsic " + name + " does not exist!");
      };
      module.exports = function GetIntrinsic(name, allowMissing) {
        if (typeof name !== "string" || name.length === 0) {
          throw new $TypeError("intrinsic name must be a non-empty string");
        }
        if (arguments.length > 1 && typeof allowMissing !== "boolean") {
          throw new $TypeError('"allowMissing" argument must be a boolean');
        }
        if ($exec(/^%?[^%]*%?$/g, name) === null) {
          throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        }
        var parts = stringToPath(name);
        var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
        var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
        var intrinsicRealName = intrinsic.name;
        var value = intrinsic.value;
        var skipFurtherCaching = false;
        var alias = intrinsic.alias;
        if (alias) {
          intrinsicBaseName = alias[0];
          $spliceApply(parts, $concat([0, 1], alias));
        }
        for (var i = 1, isOwn = true; i < parts.length; i += 1) {
          var part = parts[i];
          var first = $strSlice(part, 0, 1);
          var last = $strSlice(part, -1);
          if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
            throw new $SyntaxError("property names with quotes must have matching quotes");
          }
          if (part === "constructor" || !isOwn) {
            skipFurtherCaching = true;
          }
          intrinsicBaseName += "." + part;
          intrinsicRealName = "%" + intrinsicBaseName + "%";
          if (hasOwn(INTRINSICS, intrinsicRealName)) {
            value = INTRINSICS[intrinsicRealName];
          } else if (value != null) {
            if (!(part in value)) {
              if (!allowMissing) {
                throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
              }
              return void 0;
            }
            if ($gOPD && i + 1 >= parts.length) {
              var desc = $gOPD(value, part);
              isOwn = !!desc;
              if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
                value = desc.get;
              } else {
                value = value[part];
              }
            } else {
              isOwn = hasOwn(value, part);
              value = value[part];
            }
            if (isOwn && !skipFurtherCaching) {
              INTRINSICS[intrinsicRealName] = value;
            }
          }
        }
        return value;
      };
    }
  });

  // node_modules/call-bind/index.js
  var require_call_bind = __commonJS({
    "node_modules/call-bind/index.js"(exports, module) {
      "use strict";
      var bind = require_function_bind();
      var GetIntrinsic = require_get_intrinsic();
      var $apply = GetIntrinsic("%Function.prototype.apply%");
      var $call = GetIntrinsic("%Function.prototype.call%");
      var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
      var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
      var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
      var $max = GetIntrinsic("%Math.max%");
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
        } catch (e) {
          $defineProperty = null;
        }
      }
      module.exports = function callBind(originalFunction) {
        var func = $reflectApply(bind, $call, arguments);
        if ($gOPD && $defineProperty) {
          var desc = $gOPD(func, "length");
          if (desc.configurable) {
            $defineProperty(
              func,
              "length",
              { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
            );
          }
        }
        return func;
      };
      var applyBind = function applyBind2() {
        return $reflectApply(bind, $apply, arguments);
      };
      if ($defineProperty) {
        $defineProperty(module.exports, "apply", { value: applyBind });
      } else {
        module.exports.apply = applyBind;
      }
    }
  });

  // node_modules/call-bind/callBound.js
  var require_callBound = __commonJS({
    "node_modules/call-bind/callBound.js"(exports, module) {
      "use strict";
      var GetIntrinsic = require_get_intrinsic();
      var callBind = require_call_bind();
      var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
      module.exports = function callBoundIntrinsic(name, allowMissing) {
        var intrinsic = GetIntrinsic(name, !!allowMissing);
        if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
          return callBind(intrinsic);
        }
        return intrinsic;
      };
    }
  });

  // node_modules/is-arguments/index.js
  var require_is_arguments = __commonJS({
    "node_modules/is-arguments/index.js"(exports, module) {
      "use strict";
      var hasToStringTag = require_shams2()();
      var callBound = require_callBound();
      var $toString = callBound("Object.prototype.toString");
      var isStandardArguments = function isArguments(value) {
        if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
          return false;
        }
        return $toString(value) === "[object Arguments]";
      };
      var isLegacyArguments = function isArguments(value) {
        if (isStandardArguments(value)) {
          return true;
        }
        return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
      };
      var supportsStandardArguments = function() {
        return isStandardArguments(arguments);
      }();
      isStandardArguments.isLegacyArguments = isLegacyArguments;
      module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
    }
  });

  // node_modules/has-property-descriptors/index.js
  var require_has_property_descriptors = __commonJS({
    "node_modules/has-property-descriptors/index.js"(exports, module) {
      "use strict";
      var GetIntrinsic = require_get_intrinsic();
      var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
      var hasPropertyDescriptors = function hasPropertyDescriptors2() {
        if ($defineProperty) {
          try {
            $defineProperty({}, "a", { value: 1 });
            return true;
          } catch (e) {
            return false;
          }
        }
        return false;
      };
      hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
        if (!hasPropertyDescriptors()) {
          return null;
        }
        try {
          return $defineProperty([], "length", { value: 1 }).length !== 1;
        } catch (e) {
          return true;
        }
      };
      module.exports = hasPropertyDescriptors;
    }
  });

  // node_modules/define-properties/index.js
  var require_define_properties = __commonJS({
    "node_modules/define-properties/index.js"(exports, module) {
      "use strict";
      var keys = require_object_keys();
      var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
      var toStr = Object.prototype.toString;
      var concat = Array.prototype.concat;
      var origDefineProperty = Object.defineProperty;
      var isFunction = function(fn) {
        return typeof fn === "function" && toStr.call(fn) === "[object Function]";
      };
      var hasPropertyDescriptors = require_has_property_descriptors()();
      var supportsDescriptors = origDefineProperty && hasPropertyDescriptors;
      var defineProperty = function(object2, name, value, predicate) {
        if (name in object2 && (!isFunction(predicate) || !predicate())) {
          return;
        }
        if (supportsDescriptors) {
          origDefineProperty(object2, name, {
            configurable: true,
            enumerable: false,
            value,
            writable: true
          });
        } else {
          object2[name] = value;
        }
      };
      var defineProperties = function(object2, map5) {
        var predicates = arguments.length > 2 ? arguments[2] : {};
        var props = keys(map5);
        if (hasSymbols) {
          props = concat.call(props, Object.getOwnPropertySymbols(map5));
        }
        for (var i = 0; i < props.length; i += 1) {
          defineProperty(object2, props[i], map5[props[i]], predicates[props[i]]);
        }
      };
      defineProperties.supportsDescriptors = !!supportsDescriptors;
      module.exports = defineProperties;
    }
  });

  // node_modules/object-is/implementation.js
  var require_implementation3 = __commonJS({
    "node_modules/object-is/implementation.js"(exports, module) {
      "use strict";
      var numberIsNaN = function(value) {
        return value !== value;
      };
      module.exports = function is(a, b) {
        if (a === 0 && b === 0) {
          return 1 / a === 1 / b;
        }
        if (a === b) {
          return true;
        }
        if (numberIsNaN(a) && numberIsNaN(b)) {
          return true;
        }
        return false;
      };
    }
  });

  // node_modules/object-is/polyfill.js
  var require_polyfill = __commonJS({
    "node_modules/object-is/polyfill.js"(exports, module) {
      "use strict";
      var implementation = require_implementation3();
      module.exports = function getPolyfill() {
        return typeof Object.is === "function" ? Object.is : implementation;
      };
    }
  });

  // node_modules/object-is/shim.js
  var require_shim = __commonJS({
    "node_modules/object-is/shim.js"(exports, module) {
      "use strict";
      var getPolyfill = require_polyfill();
      var define2 = require_define_properties();
      module.exports = function shimObjectIs() {
        var polyfill = getPolyfill();
        define2(Object, { is: polyfill }, {
          is: function testObjectIs() {
            return Object.is !== polyfill;
          }
        });
        return polyfill;
      };
    }
  });

  // node_modules/object-is/index.js
  var require_object_is = __commonJS({
    "node_modules/object-is/index.js"(exports, module) {
      "use strict";
      var define2 = require_define_properties();
      var callBind = require_call_bind();
      var implementation = require_implementation3();
      var getPolyfill = require_polyfill();
      var shim = require_shim();
      var polyfill = callBind(getPolyfill(), Object);
      define2(polyfill, {
        getPolyfill,
        implementation,
        shim
      });
      module.exports = polyfill;
    }
  });

  // node_modules/is-regex/index.js
  var require_is_regex = __commonJS({
    "node_modules/is-regex/index.js"(exports, module) {
      "use strict";
      var callBound = require_callBound();
      var hasToStringTag = require_shams2()();
      var has;
      var $exec;
      var isRegexMarker;
      var badStringifier;
      if (hasToStringTag) {
        has = callBound("Object.prototype.hasOwnProperty");
        $exec = callBound("RegExp.prototype.exec");
        isRegexMarker = {};
        throwRegexMarker = function() {
          throw isRegexMarker;
        };
        badStringifier = {
          toString: throwRegexMarker,
          valueOf: throwRegexMarker
        };
        if (typeof Symbol.toPrimitive === "symbol") {
          badStringifier[Symbol.toPrimitive] = throwRegexMarker;
        }
      }
      var throwRegexMarker;
      var $toString = callBound("Object.prototype.toString");
      var gOPD = Object.getOwnPropertyDescriptor;
      var regexClass = "[object RegExp]";
      module.exports = hasToStringTag ? function isRegex(value) {
        if (!value || typeof value !== "object") {
          return false;
        }
        var descriptor = gOPD(value, "lastIndex");
        var hasLastIndexDataProperty = descriptor && has(descriptor, "value");
        if (!hasLastIndexDataProperty) {
          return false;
        }
        try {
          $exec(value, badStringifier);
        } catch (e) {
          return e === isRegexMarker;
        }
      } : function isRegex(value) {
        if (!value || typeof value !== "object" && typeof value !== "function") {
          return false;
        }
        return $toString(value) === regexClass;
      };
    }
  });

  // node_modules/functions-have-names/index.js
  var require_functions_have_names = __commonJS({
    "node_modules/functions-have-names/index.js"(exports, module) {
      "use strict";
      var functionsHaveNames = function functionsHaveNames2() {
        return typeof function f() {
        }.name === "string";
      };
      var gOPD = Object.getOwnPropertyDescriptor;
      if (gOPD) {
        try {
          gOPD([], "length");
        } catch (e) {
          gOPD = null;
        }
      }
      functionsHaveNames.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {
        if (!functionsHaveNames() || !gOPD) {
          return false;
        }
        var desc = gOPD(function() {
        }, "name");
        return !!desc && !!desc.configurable;
      };
      var $bind = Function.prototype.bind;
      functionsHaveNames.boundFunctionsHaveNames = function boundFunctionsHaveNames() {
        return functionsHaveNames() && typeof $bind === "function" && function f() {
        }.bind().name !== "";
      };
      module.exports = functionsHaveNames;
    }
  });

  // node_modules/regexp.prototype.flags/implementation.js
  var require_implementation4 = __commonJS({
    "node_modules/regexp.prototype.flags/implementation.js"(exports, module) {
      "use strict";
      var functionsHaveConfigurableNames = require_functions_have_names().functionsHaveConfigurableNames();
      var $Object = Object;
      var $TypeError = TypeError;
      module.exports = function flags() {
        if (this != null && this !== $Object(this)) {
          throw new $TypeError("RegExp.prototype.flags getter called on non-object");
        }
        var result = "";
        if (this.hasIndices) {
          result += "d";
        }
        if (this.global) {
          result += "g";
        }
        if (this.ignoreCase) {
          result += "i";
        }
        if (this.multiline) {
          result += "m";
        }
        if (this.dotAll) {
          result += "s";
        }
        if (this.unicode) {
          result += "u";
        }
        if (this.sticky) {
          result += "y";
        }
        return result;
      };
      if (functionsHaveConfigurableNames && Object.defineProperty) {
        Object.defineProperty(module.exports, "name", { value: "get flags" });
      }
    }
  });

  // node_modules/regexp.prototype.flags/polyfill.js
  var require_polyfill2 = __commonJS({
    "node_modules/regexp.prototype.flags/polyfill.js"(exports, module) {
      "use strict";
      var implementation = require_implementation4();
      var supportsDescriptors = require_define_properties().supportsDescriptors;
      var $gOPD = Object.getOwnPropertyDescriptor;
      module.exports = function getPolyfill() {
        if (supportsDescriptors && /a/mig.flags === "gim") {
          var descriptor = $gOPD(RegExp.prototype, "flags");
          if (descriptor && typeof descriptor.get === "function" && typeof RegExp.prototype.dotAll === "boolean" && typeof RegExp.prototype.hasIndices === "boolean") {
            var calls = "";
            var o = {};
            Object.defineProperty(o, "hasIndices", {
              get: function() {
                calls += "d";
              }
            });
            Object.defineProperty(o, "sticky", {
              get: function() {
                calls += "y";
              }
            });
            if (calls === "dy") {
              return descriptor.get;
            }
          }
        }
        return implementation;
      };
    }
  });

  // node_modules/regexp.prototype.flags/shim.js
  var require_shim2 = __commonJS({
    "node_modules/regexp.prototype.flags/shim.js"(exports, module) {
      "use strict";
      var supportsDescriptors = require_define_properties().supportsDescriptors;
      var getPolyfill = require_polyfill2();
      var gOPD = Object.getOwnPropertyDescriptor;
      var defineProperty = Object.defineProperty;
      var TypeErr = TypeError;
      var getProto = Object.getPrototypeOf;
      var regex = /a/;
      module.exports = function shimFlags() {
        if (!supportsDescriptors || !getProto) {
          throw new TypeErr("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
        }
        var polyfill = getPolyfill();
        var proto = getProto(regex);
        var descriptor = gOPD(proto, "flags");
        if (!descriptor || descriptor.get !== polyfill) {
          defineProperty(proto, "flags", {
            configurable: true,
            enumerable: false,
            get: polyfill
          });
        }
        return polyfill;
      };
    }
  });

  // node_modules/regexp.prototype.flags/index.js
  var require_regexp_prototype = __commonJS({
    "node_modules/regexp.prototype.flags/index.js"(exports, module) {
      "use strict";
      var define2 = require_define_properties();
      var callBind = require_call_bind();
      var implementation = require_implementation4();
      var getPolyfill = require_polyfill2();
      var shim = require_shim2();
      var flagsBound = callBind(getPolyfill());
      define2(flagsBound, {
        getPolyfill,
        implementation,
        shim
      });
      module.exports = flagsBound;
    }
  });

  // node_modules/is-date-object/index.js
  var require_is_date_object = __commonJS({
    "node_modules/is-date-object/index.js"(exports, module) {
      "use strict";
      var getDay = Date.prototype.getDay;
      var tryDateObject = function tryDateGetDayCall(value) {
        try {
          getDay.call(value);
          return true;
        } catch (e) {
          return false;
        }
      };
      var toStr = Object.prototype.toString;
      var dateClass = "[object Date]";
      var hasToStringTag = require_shams2()();
      module.exports = function isDateObject(value) {
        if (typeof value !== "object" || value === null) {
          return false;
        }
        return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
      };
    }
  });

  // node_modules/deep-equal/index.js
  var require_deep_equal = __commonJS({
    "node_modules/deep-equal/index.js"(exports, module) {
      var objectKeys = require_object_keys();
      var isArguments = require_is_arguments();
      var is = require_object_is();
      var isRegex = require_is_regex();
      var flags = require_regexp_prototype();
      var isDate = require_is_date_object();
      var getTime = Date.prototype.getTime;
      function deepEqual(actual, expected, options) {
        var opts = options || {};
        if (opts.strict ? is(actual, expected) : actual === expected) {
          return true;
        }
        if (!actual || !expected || typeof actual !== "object" && typeof expected !== "object") {
          return opts.strict ? is(actual, expected) : actual == expected;
        }
        return objEquiv(actual, expected, opts);
      }
      function isUndefinedOrNull(value) {
        return value === null || value === void 0;
      }
      function isBuffer(x2) {
        if (!x2 || typeof x2 !== "object" || typeof x2.length !== "number") {
          return false;
        }
        if (typeof x2.copy !== "function" || typeof x2.slice !== "function") {
          return false;
        }
        if (x2.length > 0 && typeof x2[0] !== "number") {
          return false;
        }
        return true;
      }
      function objEquiv(a, b, opts) {
        var i, key;
        if (typeof a !== typeof b) {
          return false;
        }
        if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) {
          return false;
        }
        if (a.prototype !== b.prototype) {
          return false;
        }
        if (isArguments(a) !== isArguments(b)) {
          return false;
        }
        var aIsRegex = isRegex(a);
        var bIsRegex = isRegex(b);
        if (aIsRegex !== bIsRegex) {
          return false;
        }
        if (aIsRegex || bIsRegex) {
          return a.source === b.source && flags(a) === flags(b);
        }
        if (isDate(a) && isDate(b)) {
          return getTime.call(a) === getTime.call(b);
        }
        var aIsBuffer = isBuffer(a);
        var bIsBuffer = isBuffer(b);
        if (aIsBuffer !== bIsBuffer) {
          return false;
        }
        if (aIsBuffer || bIsBuffer) {
          if (a.length !== b.length) {
            return false;
          }
          for (i = 0; i < a.length; i++) {
            if (a[i] !== b[i]) {
              return false;
            }
          }
          return true;
        }
        if (typeof a !== typeof b) {
          return false;
        }
        try {
          var ka = objectKeys(a);
          var kb = objectKeys(b);
        } catch (e) {
          return false;
        }
        if (ka.length !== kb.length) {
          return false;
        }
        ka.sort();
        kb.sort();
        for (i = ka.length - 1; i >= 0; i--) {
          if (ka[i] != kb[i]) {
            return false;
          }
        }
        for (i = ka.length - 1; i >= 0; i--) {
          key = ka[i];
          if (!deepEqual(a[key], b[key], opts)) {
            return false;
          }
        }
        return true;
      }
      module.exports = deepEqual;
    }
  });

  // node_modules/geojson-equality/index.js
  var require_geojson_equality = __commonJS({
    "node_modules/geojson-equality/index.js"(exports, module) {
      var deepEqual = require_deep_equal();
      var Equality = function(opt) {
        this.precision = opt && opt.precision ? opt.precision : 17;
        this.direction = opt && opt.direction ? opt.direction : false;
        this.pseudoNode = opt && opt.pseudoNode ? opt.pseudoNode : false;
        this.objectComparator = opt && opt.objectComparator ? opt.objectComparator : objectComparator;
      };
      Equality.prototype.compare = function(g1, g2) {
        if (g1.type !== g2.type || !sameLength(g1, g2))
          return false;
        switch (g1.type) {
          case "Point":
            return this.compareCoord(g1.coordinates, g2.coordinates);
            break;
          case "LineString":
            return this.compareLine(g1.coordinates, g2.coordinates, 0, false);
            break;
          case "Polygon":
            return this.comparePolygon(g1, g2);
            break;
          case "Feature":
            return this.compareFeature(g1, g2);
          default:
            if (g1.type.indexOf("Multi") === 0) {
              var context = this;
              var g1s = explode(g1);
              var g2s = explode(g2);
              return g1s.every(function(g1part) {
                return this.some(function(g2part) {
                  return context.compare(g1part, g2part);
                });
              }, g2s);
            }
        }
        return false;
      };
      function explode(g) {
        return g.coordinates.map(function(part) {
          return {
            type: g.type.replace("Multi", ""),
            coordinates: part
          };
        });
      }
      function sameLength(g1, g2) {
        return g1.hasOwnProperty("coordinates") ? g1.coordinates.length === g2.coordinates.length : g1.length === g2.length;
      }
      Equality.prototype.compareCoord = function(c1, c2) {
        if (c1.length !== c2.length) {
          return false;
        }
        for (var i = 0; i < c1.length; i++) {
          if (c1[i].toFixed(this.precision) !== c2[i].toFixed(this.precision)) {
            return false;
          }
        }
        return true;
      };
      Equality.prototype.compareLine = function(path1, path2, ind, isPoly) {
        if (!sameLength(path1, path2))
          return false;
        var p1 = this.pseudoNode ? path1 : this.removePseudo(path1);
        var p2 = this.pseudoNode ? path2 : this.removePseudo(path2);
        if (isPoly && !this.compareCoord(p1[0], p2[0])) {
          p2 = this.fixStartIndex(p2, p1);
          if (!p2)
            return;
        }
        var sameDirection = this.compareCoord(p1[ind], p2[ind]);
        if (this.direction || sameDirection) {
          return this.comparePath(p1, p2);
        } else {
          if (this.compareCoord(p1[ind], p2[p2.length - (1 + ind)])) {
            return this.comparePath(p1.slice().reverse(), p2);
          }
          return false;
        }
      };
      Equality.prototype.fixStartIndex = function(sourcePath, targetPath) {
        var correctPath, ind = -1;
        for (var i = 0; i < sourcePath.length; i++) {
          if (this.compareCoord(sourcePath[i], targetPath[0])) {
            ind = i;
            break;
          }
        }
        if (ind >= 0) {
          correctPath = [].concat(
            sourcePath.slice(ind, sourcePath.length),
            sourcePath.slice(1, ind + 1)
          );
        }
        return correctPath;
      };
      Equality.prototype.comparePath = function(p1, p2) {
        var cont = this;
        return p1.every(function(c, i) {
          return cont.compareCoord(c, this[i]);
        }, p2);
      };
      Equality.prototype.comparePolygon = function(g1, g2) {
        if (this.compareLine(g1.coordinates[0], g2.coordinates[0], 1, true)) {
          var holes1 = g1.coordinates.slice(1, g1.coordinates.length);
          var holes2 = g2.coordinates.slice(1, g2.coordinates.length);
          var cont = this;
          return holes1.every(function(h1) {
            return this.some(function(h2) {
              return cont.compareLine(h1, h2, 1, true);
            });
          }, holes2);
        } else {
          return false;
        }
      };
      Equality.prototype.compareFeature = function(g1, g2) {
        if (g1.id !== g2.id || !this.objectComparator(g1.properties, g2.properties) || !this.compareBBox(g1, g2)) {
          return false;
        }
        return this.compare(g1.geometry, g2.geometry);
      };
      Equality.prototype.compareBBox = function(g1, g2) {
        if (!g1.bbox && !g2.bbox || g1.bbox && g2.bbox && this.compareCoord(g1.bbox, g2.bbox)) {
          return true;
        }
        return false;
      };
      Equality.prototype.removePseudo = function(path) {
        return path;
      };
      function objectComparator(obj1, obj2) {
        return deepEqual(obj1, obj2, { strict: true });
      }
      module.exports = Equality;
    }
  });

  // node_modules/density-clustering/lib/DBSCAN.js
  var require_DBSCAN = __commonJS({
    "node_modules/density-clustering/lib/DBSCAN.js"(exports, module) {
      function DBSCAN(dataset, epsilon5, minPts, distanceFunction) {
        this.dataset = [];
        this.epsilon = 1;
        this.minPts = 2;
        this.distance = this._euclideanDistance;
        this.clusters = [];
        this.noise = [];
        this._visited = [];
        this._assigned = [];
        this._datasetLength = 0;
        this._init(dataset, epsilon5, minPts, distanceFunction);
      }
      DBSCAN.prototype.run = function(dataset, epsilon5, minPts, distanceFunction) {
        this._init(dataset, epsilon5, minPts, distanceFunction);
        for (var pointId = 0; pointId < this._datasetLength; pointId++) {
          if (this._visited[pointId] !== 1) {
            this._visited[pointId] = 1;
            var neighbors = this._regionQuery(pointId);
            if (neighbors.length < this.minPts) {
              this.noise.push(pointId);
            } else {
              var clusterId = this.clusters.length;
              this.clusters.push([]);
              this._addToCluster(pointId, clusterId);
              this._expandCluster(clusterId, neighbors);
            }
          }
        }
        return this.clusters;
      };
      DBSCAN.prototype._init = function(dataset, epsilon5, minPts, distance2) {
        if (dataset) {
          if (!(dataset instanceof Array)) {
            throw Error("Dataset must be of type array, " + typeof dataset + " given");
          }
          this.dataset = dataset;
          this.clusters = [];
          this.noise = [];
          this._datasetLength = dataset.length;
          this._visited = new Array(this._datasetLength);
          this._assigned = new Array(this._datasetLength);
        }
        if (epsilon5) {
          this.epsilon = epsilon5;
        }
        if (minPts) {
          this.minPts = minPts;
        }
        if (distance2) {
          this.distance = distance2;
        }
      };
      DBSCAN.prototype._expandCluster = function(clusterId, neighbors) {
        for (var i = 0; i < neighbors.length; i++) {
          var pointId2 = neighbors[i];
          if (this._visited[pointId2] !== 1) {
            this._visited[pointId2] = 1;
            var neighbors2 = this._regionQuery(pointId2);
            if (neighbors2.length >= this.minPts) {
              neighbors = this._mergeArrays(neighbors, neighbors2);
            }
          }
          if (this._assigned[pointId2] !== 1) {
            this._addToCluster(pointId2, clusterId);
          }
        }
      };
      DBSCAN.prototype._addToCluster = function(pointId, clusterId) {
        this.clusters[clusterId].push(pointId);
        this._assigned[pointId] = 1;
      };
      DBSCAN.prototype._regionQuery = function(pointId) {
        var neighbors = [];
        for (var id = 0; id < this._datasetLength; id++) {
          var dist = this.distance(this.dataset[pointId], this.dataset[id]);
          if (dist < this.epsilon) {
            neighbors.push(id);
          }
        }
        return neighbors;
      };
      DBSCAN.prototype._mergeArrays = function(a, b) {
        var len = b.length;
        for (var i = 0; i < len; i++) {
          var P = b[i];
          if (a.indexOf(P) < 0) {
            a.push(P);
          }
        }
        return a;
      };
      DBSCAN.prototype._euclideanDistance = function(p, q) {
        var sum2 = 0;
        var i = Math.min(p.length, q.length);
        while (i--) {
          sum2 += (p[i] - q[i]) * (p[i] - q[i]);
        }
        return Math.sqrt(sum2);
      };
      if (typeof module !== "undefined" && module.exports) {
        module.exports = DBSCAN;
      }
    }
  });

  // node_modules/density-clustering/lib/KMEANS.js
  var require_KMEANS = __commonJS({
    "node_modules/density-clustering/lib/KMEANS.js"(exports, module) {
      function KMEANS(dataset, k, distance2) {
        this.k = 3;
        this.dataset = [];
        this.assignments = [];
        this.centroids = [];
        this.init(dataset, k, distance2);
      }
      KMEANS.prototype.init = function(dataset, k, distance2) {
        this.assignments = [];
        this.centroids = [];
        if (typeof dataset !== "undefined") {
          this.dataset = dataset;
        }
        if (typeof k !== "undefined") {
          this.k = k;
        }
        if (typeof distance2 !== "undefined") {
          this.distance = distance2;
        }
      };
      KMEANS.prototype.run = function(dataset, k) {
        this.init(dataset, k);
        var len = this.dataset.length;
        for (var i = 0; i < this.k; i++) {
          this.centroids[i] = this.randomCentroid();
        }
        var change = true;
        while (change) {
          change = this.assign();
          for (var centroidId = 0; centroidId < this.k; centroidId++) {
            var mean = new Array(maxDim);
            var count = 0;
            for (var dim = 0; dim < maxDim; dim++) {
              mean[dim] = 0;
            }
            for (var j = 0; j < len; j++) {
              var maxDim = this.dataset[j].length;
              if (centroidId === this.assignments[j]) {
                for (var dim = 0; dim < maxDim; dim++) {
                  mean[dim] += this.dataset[j][dim];
                }
                count++;
              }
            }
            if (count > 0) {
              for (var dim = 0; dim < maxDim; dim++) {
                mean[dim] /= count;
              }
              this.centroids[centroidId] = mean;
            } else {
              this.centroids[centroidId] = this.randomCentroid();
              change = true;
            }
          }
        }
        return this.getClusters();
      };
      KMEANS.prototype.randomCentroid = function() {
        var maxId = this.dataset.length - 1;
        var centroid;
        var id;
        do {
          id = Math.round(Math.random() * maxId);
          centroid = this.dataset[id];
        } while (this.centroids.indexOf(centroid) >= 0);
        return centroid;
      };
      KMEANS.prototype.assign = function() {
        var change = false;
        var len = this.dataset.length;
        var closestCentroid;
        for (var i = 0; i < len; i++) {
          closestCentroid = this.argmin(this.dataset[i], this.centroids, this.distance);
          if (closestCentroid != this.assignments[i]) {
            this.assignments[i] = closestCentroid;
            change = true;
          }
        }
        return change;
      };
      KMEANS.prototype.getClusters = function() {
        var clusters = new Array(this.k);
        var centroidId;
        for (var pointId = 0; pointId < this.assignments.length; pointId++) {
          centroidId = this.assignments[pointId];
          if (typeof clusters[centroidId] === "undefined") {
            clusters[centroidId] = [];
          }
          clusters[centroidId].push(pointId);
        }
        return clusters;
      };
      KMEANS.prototype.argmin = function(point2, set, f) {
        var min = Number.MAX_VALUE;
        var arg = 0;
        var len = set.length;
        var d;
        for (var i = 0; i < len; i++) {
          d = f(point2, set[i]);
          if (d < min) {
            min = d;
            arg = i;
          }
        }
        return arg;
      };
      KMEANS.prototype.distance = function(p, q) {
        var sum2 = 0;
        var i = Math.min(p.length, q.length);
        while (i--) {
          var diff = p[i] - q[i];
          sum2 += diff * diff;
        }
        return Math.sqrt(sum2);
      };
      if (typeof module !== "undefined" && module.exports) {
        module.exports = KMEANS;
      }
    }
  });

  // node_modules/density-clustering/lib/PriorityQueue.js
  var require_PriorityQueue = __commonJS({
    "node_modules/density-clustering/lib/PriorityQueue.js"(exports, module) {
      function PriorityQueue(elements, priorities, sorting) {
        this._queue = [];
        this._priorities = [];
        this._sorting = "desc";
        this._init(elements, priorities, sorting);
      }
      PriorityQueue.prototype.insert = function(ele, priority) {
        var indexToInsert = this._queue.length;
        var index = indexToInsert;
        while (index--) {
          var priority2 = this._priorities[index];
          if (this._sorting === "desc") {
            if (priority > priority2) {
              indexToInsert = index;
            }
          } else {
            if (priority < priority2) {
              indexToInsert = index;
            }
          }
        }
        this._insertAt(ele, priority, indexToInsert);
      };
      PriorityQueue.prototype.remove = function(ele) {
        var index = this._queue.length;
        while (index--) {
          var ele2 = this._queue[index];
          if (ele === ele2) {
            this._queue.splice(index, 1);
            this._priorities.splice(index, 1);
            break;
          }
        }
      };
      PriorityQueue.prototype.forEach = function(func) {
        this._queue.forEach(func);
      };
      PriorityQueue.prototype.getElements = function() {
        return this._queue;
      };
      PriorityQueue.prototype.getElementPriority = function(index) {
        return this._priorities[index];
      };
      PriorityQueue.prototype.getPriorities = function() {
        return this._priorities;
      };
      PriorityQueue.prototype.getElementsWithPriorities = function() {
        var result = [];
        for (var i = 0, l = this._queue.length; i < l; i++) {
          result.push([this._queue[i], this._priorities[i]]);
        }
        return result;
      };
      PriorityQueue.prototype._init = function(elements, priorities, sorting) {
        if (elements && priorities) {
          this._queue = [];
          this._priorities = [];
          if (elements.length !== priorities.length) {
            throw new Error("Arrays must have the same length");
          }
          for (var i = 0; i < elements.length; i++) {
            this.insert(elements[i], priorities[i]);
          }
        }
        if (sorting) {
          this._sorting = sorting;
        }
      };
      PriorityQueue.prototype._insertAt = function(ele, priority, index) {
        if (this._queue.length === index) {
          this._queue.push(ele);
          this._priorities.push(priority);
        } else {
          this._queue.splice(index, 0, ele);
          this._priorities.splice(index, 0, priority);
        }
      };
      if (typeof module !== "undefined" && module.exports) {
        module.exports = PriorityQueue;
      }
    }
  });

  // node_modules/density-clustering/lib/OPTICS.js
  var require_OPTICS = __commonJS({
    "node_modules/density-clustering/lib/OPTICS.js"(exports, module) {
      if (typeof module !== "undefined" && module.exports) {
        PriorityQueue = require_PriorityQueue();
      }
      var PriorityQueue;
      function OPTICS(dataset, epsilon5, minPts, distanceFunction) {
        this.epsilon = 1;
        this.minPts = 1;
        this.distance = this._euclideanDistance;
        this._reachability = [];
        this._processed = [];
        this._coreDistance = 0;
        this._orderedList = [];
        this._init(dataset, epsilon5, minPts, distanceFunction);
      }
      OPTICS.prototype.run = function(dataset, epsilon5, minPts, distanceFunction) {
        this._init(dataset, epsilon5, minPts, distanceFunction);
        for (var pointId = 0, l = this.dataset.length; pointId < l; pointId++) {
          if (this._processed[pointId] !== 1) {
            this._processed[pointId] = 1;
            this.clusters.push([pointId]);
            var clusterId = this.clusters.length - 1;
            this._orderedList.push(pointId);
            var priorityQueue = new PriorityQueue(null, null, "asc");
            var neighbors = this._regionQuery(pointId);
            if (this._distanceToCore(pointId) !== void 0) {
              this._updateQueue(pointId, neighbors, priorityQueue);
              this._expandCluster(clusterId, priorityQueue);
            }
          }
        }
        return this.clusters;
      };
      OPTICS.prototype.getReachabilityPlot = function() {
        var reachabilityPlot = [];
        for (var i = 0, l = this._orderedList.length; i < l; i++) {
          var pointId = this._orderedList[i];
          var distance2 = this._reachability[pointId];
          reachabilityPlot.push([pointId, distance2]);
        }
        return reachabilityPlot;
      };
      OPTICS.prototype._init = function(dataset, epsilon5, minPts, distance2) {
        if (dataset) {
          if (!(dataset instanceof Array)) {
            throw Error("Dataset must be of type array, " + typeof dataset + " given");
          }
          this.dataset = dataset;
          this.clusters = [];
          this._reachability = new Array(this.dataset.length);
          this._processed = new Array(this.dataset.length);
          this._coreDistance = 0;
          this._orderedList = [];
        }
        if (epsilon5) {
          this.epsilon = epsilon5;
        }
        if (minPts) {
          this.minPts = minPts;
        }
        if (distance2) {
          this.distance = distance2;
        }
      };
      OPTICS.prototype._updateQueue = function(pointId, neighbors, queue) {
        var self2 = this;
        this._coreDistance = this._distanceToCore(pointId);
        neighbors.forEach(function(pointId2) {
          if (self2._processed[pointId2] === void 0) {
            var dist = self2.distance(self2.dataset[pointId], self2.dataset[pointId2]);
            var newReachableDistance = Math.max(self2._coreDistance, dist);
            if (self2._reachability[pointId2] === void 0) {
              self2._reachability[pointId2] = newReachableDistance;
              queue.insert(pointId2, newReachableDistance);
            } else {
              if (newReachableDistance < self2._reachability[pointId2]) {
                self2._reachability[pointId2] = newReachableDistance;
                queue.remove(pointId2);
                queue.insert(pointId2, newReachableDistance);
              }
            }
          }
        });
      };
      OPTICS.prototype._expandCluster = function(clusterId, queue) {
        var queueElements = queue.getElements();
        for (var p = 0, l = queueElements.length; p < l; p++) {
          var pointId = queueElements[p];
          if (this._processed[pointId] === void 0) {
            var neighbors = this._regionQuery(pointId);
            this._processed[pointId] = 1;
            this.clusters[clusterId].push(pointId);
            this._orderedList.push(pointId);
            if (this._distanceToCore(pointId) !== void 0) {
              this._updateQueue(pointId, neighbors, queue);
              this._expandCluster(clusterId, queue);
            }
          }
        }
      };
      OPTICS.prototype._distanceToCore = function(pointId) {
        var l = this.epsilon;
        for (var coreDistCand = 0; coreDistCand < l; coreDistCand++) {
          var neighbors = this._regionQuery(pointId, coreDistCand);
          if (neighbors.length >= this.minPts) {
            return coreDistCand;
          }
        }
        return;
      };
      OPTICS.prototype._regionQuery = function(pointId, epsilon5) {
        epsilon5 = epsilon5 || this.epsilon;
        var neighbors = [];
        for (var id = 0, l = this.dataset.length; id < l; id++) {
          if (this.distance(this.dataset[pointId], this.dataset[id]) < epsilon5) {
            neighbors.push(id);
          }
        }
        return neighbors;
      };
      OPTICS.prototype._euclideanDistance = function(p, q) {
        var sum2 = 0;
        var i = Math.min(p.length, q.length);
        while (i--) {
          sum2 += (p[i] - q[i]) * (p[i] - q[i]);
        }
        return Math.sqrt(sum2);
      };
      if (typeof module !== "undefined" && module.exports) {
        module.exports = OPTICS;
      }
    }
  });

  // node_modules/density-clustering/lib/index.js
  var require_lib = __commonJS({
    "node_modules/density-clustering/lib/index.js"(exports, module) {
      if (typeof module !== "undefined" && module.exports) {
        module.exports = {
          DBSCAN: require_DBSCAN(),
          KMEANS: require_KMEANS(),
          OPTICS: require_OPTICS(),
          PriorityQueue: require_PriorityQueue()
        };
      }
    }
  });

  // node_modules/skmeans/dist/node/distance.js
  var require_distance = __commonJS({
    "node_modules/skmeans/dist/node/distance.js"(exports, module) {
      "use strict";
      module.exports = {
        eudist: function eudist(v1, v2, sqrt3) {
          var len = v1.length;
          var sum2 = 0;
          for (var i = 0; i < len; i++) {
            var d = (v1[i] || 0) - (v2[i] || 0);
            sum2 += d * d;
          }
          return sqrt3 ? Math.sqrt(sum2) : sum2;
        },
        mandist: function mandist(v1, v2, sqrt3) {
          var len = v1.length;
          var sum2 = 0;
          for (var i = 0; i < len; i++) {
            sum2 += Math.abs((v1[i] || 0) - (v2[i] || 0));
          }
          return sqrt3 ? Math.sqrt(sum2) : sum2;
        },
        dist: function dist(v1, v2, sqrt3) {
          var d = Math.abs(v1 - v2);
          return sqrt3 ? d : d * d;
        }
      };
    }
  });

  // node_modules/skmeans/dist/node/kinit.js
  var require_kinit = __commonJS({
    "node_modules/skmeans/dist/node/kinit.js"(exports, module) {
      "use strict";
      var Distance = require_distance();
      var eudist = Distance.eudist;
      var dist = Distance.dist;
      module.exports = {
        kmrand: function kmrand(data, k) {
          var map5 = {}, ks = [], t = k << 2;
          var len = data.length;
          var multi = data[0].length > 0;
          while (ks.length < k && t-- > 0) {
            var d = data[Math.floor(Math.random() * len)];
            var key = multi ? d.join("_") : "" + d;
            if (!map5[key]) {
              map5[key] = true;
              ks.push(d);
            }
          }
          if (ks.length < k)
            throw new Error("Error initializating clusters");
          else
            return ks;
        },
        kmpp: function kmpp(data, k) {
          var distance2 = data[0].length ? eudist : dist;
          var ks = [], len = data.length;
          var multi = data[0].length > 0;
          var map5 = {};
          var c = data[Math.floor(Math.random() * len)];
          var key = multi ? c.join("_") : "" + c;
          ks.push(c);
          map5[key] = true;
          while (ks.length < k) {
            var dists = [], lk = ks.length;
            var dsum = 0, prs = [];
            for (var i = 0; i < len; i++) {
              var min = Infinity;
              for (var j = 0; j < lk; j++) {
                var _dist = distance2(data[i], ks[j]);
                if (_dist <= min)
                  min = _dist;
              }
              dists[i] = min;
            }
            for (var _i = 0; _i < len; _i++) {
              dsum += dists[_i];
            }
            for (var _i2 = 0; _i2 < len; _i2++) {
              prs[_i2] = { i: _i2, v: data[_i2], pr: dists[_i2] / dsum, cs: 0 };
            }
            prs.sort(function(a, b) {
              return a.pr - b.pr;
            });
            prs[0].cs = prs[0].pr;
            for (var _i3 = 1; _i3 < len; _i3++) {
              prs[_i3].cs = prs[_i3 - 1].cs + prs[_i3].pr;
            }
            var rnd = Math.random();
            var idx = 0;
            while (idx < len - 1 && prs[idx++].cs < rnd) {
            }
            ks.push(prs[idx - 1].v);
          }
          return ks;
        }
      };
    }
  });

  // node_modules/skmeans/dist/node/main.js
  var require_main = __commonJS({
    "node_modules/skmeans/dist/node/main.js"(exports, module) {
      "use strict";
      var Distance = require_distance();
      var ClusterInit = require_kinit();
      var eudist = Distance.eudist;
      var mandist = Distance.mandist;
      var dist = Distance.dist;
      var kmrand = ClusterInit.kmrand;
      var kmpp = ClusterInit.kmpp;
      var MAX = 1e4;
      function init(len, val, v) {
        v = v || [];
        for (var i = 0; i < len; i++) {
          v[i] = val;
        }
        return v;
      }
      function skmeans2(data, k, initial, maxit) {
        var ks = [], old = [], idxs = [], dist2 = [];
        var conv = false, it = maxit || MAX;
        var len = data.length, vlen = data[0].length, multi = vlen > 0;
        var count = [];
        if (!initial) {
          var _idxs = {};
          while (ks.length < k) {
            var idx = Math.floor(Math.random() * len);
            if (!_idxs[idx]) {
              _idxs[idx] = true;
              ks.push(data[idx]);
            }
          }
        } else if (initial == "kmrand") {
          ks = kmrand(data, k);
        } else if (initial == "kmpp") {
          ks = kmpp(data, k);
        } else {
          ks = initial;
        }
        do {
          init(k, 0, count);
          for (var i = 0; i < len; i++) {
            var min = Infinity, _idx = 0;
            for (var j = 0; j < k; j++) {
              var dist2 = multi ? eudist(data[i], ks[j]) : Math.abs(data[i] - ks[j]);
              if (dist2 <= min) {
                min = dist2;
                _idx = j;
              }
            }
            idxs[i] = _idx;
            count[_idx]++;
          }
          var sum2 = [], old = [], dif = 0;
          for (var _j = 0; _j < k; _j++) {
            sum2[_j] = multi ? init(vlen, 0, sum2[_j]) : 0;
            old[_j] = ks[_j];
          }
          if (multi) {
            for (var _j2 = 0; _j2 < k; _j2++) {
              ks[_j2] = [];
            }
            for (var _i = 0; _i < len; _i++) {
              var _idx2 = idxs[_i], vsum = sum2[_idx2], vect = data[_i];
              for (var h = 0; h < vlen; h++) {
                vsum[h] += vect[h];
              }
            }
            conv = true;
            for (var _j3 = 0; _j3 < k; _j3++) {
              var ksj = ks[_j3], sumj = sum2[_j3], oldj = old[_j3], cj = count[_j3];
              for (var _h = 0; _h < vlen; _h++) {
                ksj[_h] = sumj[_h] / cj || 0;
              }
              if (conv) {
                for (var _h2 = 0; _h2 < vlen; _h2++) {
                  if (oldj[_h2] != ksj[_h2]) {
                    conv = false;
                    break;
                  }
                }
              }
            }
          } else {
            for (var _i2 = 0; _i2 < len; _i2++) {
              var _idx3 = idxs[_i2];
              sum2[_idx3] += data[_i2];
            }
            for (var _j4 = 0; _j4 < k; _j4++) {
              ks[_j4] = sum2[_j4] / count[_j4] || 0;
            }
            conv = true;
            for (var _j5 = 0; _j5 < k; _j5++) {
              if (old[_j5] != ks[_j5]) {
                conv = false;
                break;
              }
            }
          }
          conv = conv || --it <= 0;
        } while (!conv);
        return {
          it: MAX - it,
          k,
          idxs,
          centroids: ks
        };
      }
      module.exports = skmeans2;
    }
  });

  // node_modules/polygon-clipping/dist/polygon-clipping.umd.js
  var require_polygon_clipping_umd = __commonJS({
    "node_modules/polygon-clipping/dist/polygon-clipping.umd.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.polygonClipping = factory());
      })(exports, function() {
        "use strict";
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps)
            _defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            _defineProperties(Constructor, staticProps);
          return Constructor;
        }
        var Node2 = function() {
          function Node3(key, data) {
            this.next = null;
            this.key = key;
            this.data = data;
            this.left = null;
            this.right = null;
          }
          return Node3;
        }();
        function DEFAULT_COMPARE(a, b) {
          return a > b ? 1 : a < b ? -1 : 0;
        }
        function splay(i, t, comparator) {
          var N = new Node2(null, null);
          var l = N;
          var r = N;
          while (true) {
            var cmp2 = comparator(i, t.key);
            if (cmp2 < 0) {
              if (t.left === null)
                break;
              if (comparator(i, t.left.key) < 0) {
                var y2 = t.left;
                t.left = y2.right;
                y2.right = t;
                t = y2;
                if (t.left === null)
                  break;
              }
              r.left = t;
              r = t;
              t = t.left;
            } else if (cmp2 > 0) {
              if (t.right === null)
                break;
              if (comparator(i, t.right.key) > 0) {
                var y2 = t.right;
                t.right = y2.left;
                y2.left = t;
                t = y2;
                if (t.right === null)
                  break;
              }
              l.right = t;
              l = t;
              t = t.right;
            } else
              break;
          }
          l.right = t.left;
          r.left = t.right;
          t.left = N.right;
          t.right = N.left;
          return t;
        }
        function insert(i, data, t, comparator) {
          var node = new Node2(i, data);
          if (t === null) {
            node.left = node.right = null;
            return node;
          }
          t = splay(i, t, comparator);
          var cmp2 = comparator(i, t.key);
          if (cmp2 < 0) {
            node.left = t.left;
            node.right = t;
            t.left = null;
          } else if (cmp2 >= 0) {
            node.right = t.right;
            node.left = t;
            t.right = null;
          }
          return node;
        }
        function split(key, v, comparator) {
          var left = null;
          var right = null;
          if (v) {
            v = splay(key, v, comparator);
            var cmp2 = comparator(v.key, key);
            if (cmp2 === 0) {
              left = v.left;
              right = v.right;
            } else if (cmp2 < 0) {
              right = v.right;
              v.right = null;
              left = v;
            } else {
              left = v.left;
              v.left = null;
              right = v;
            }
          }
          return {
            left,
            right
          };
        }
        function merge(left, right, comparator) {
          if (right === null)
            return left;
          if (left === null)
            return right;
          right = splay(left.key, right, comparator);
          right.left = left;
          return right;
        }
        function printRow(root, prefix, isTail, out, printNode) {
          if (root) {
            out("" + prefix + (isTail ? "\u2514\u2500\u2500 " : "\u251C\u2500\u2500 ") + printNode(root) + "\n");
            var indent = prefix + (isTail ? "    " : "\u2502   ");
            if (root.left)
              printRow(root.left, indent, false, out, printNode);
            if (root.right)
              printRow(root.right, indent, true, out, printNode);
          }
        }
        var Tree = function() {
          function Tree2(comparator) {
            if (comparator === void 0) {
              comparator = DEFAULT_COMPARE;
            }
            this._root = null;
            this._size = 0;
            this._comparator = comparator;
          }
          Tree2.prototype.insert = function(key, data) {
            this._size++;
            return this._root = insert(key, data, this._root, this._comparator);
          };
          Tree2.prototype.add = function(key, data) {
            var node = new Node2(key, data);
            if (this._root === null) {
              node.left = node.right = null;
              this._size++;
              this._root = node;
            }
            var comparator = this._comparator;
            var t = splay(key, this._root, comparator);
            var cmp2 = comparator(key, t.key);
            if (cmp2 === 0)
              this._root = t;
            else {
              if (cmp2 < 0) {
                node.left = t.left;
                node.right = t;
                t.left = null;
              } else if (cmp2 > 0) {
                node.right = t.right;
                node.left = t;
                t.right = null;
              }
              this._size++;
              this._root = node;
            }
            return this._root;
          };
          Tree2.prototype.remove = function(key) {
            this._root = this._remove(key, this._root, this._comparator);
          };
          Tree2.prototype._remove = function(i, t, comparator) {
            var x2;
            if (t === null)
              return null;
            t = splay(i, t, comparator);
            var cmp2 = comparator(i, t.key);
            if (cmp2 === 0) {
              if (t.left === null) {
                x2 = t.right;
              } else {
                x2 = splay(i, t.left, comparator);
                x2.right = t.right;
              }
              this._size--;
              return x2;
            }
            return t;
          };
          Tree2.prototype.pop = function() {
            var node = this._root;
            if (node) {
              while (node.left) {
                node = node.left;
              }
              this._root = splay(node.key, this._root, this._comparator);
              this._root = this._remove(node.key, this._root, this._comparator);
              return {
                key: node.key,
                data: node.data
              };
            }
            return null;
          };
          Tree2.prototype.findStatic = function(key) {
            var current = this._root;
            var compare = this._comparator;
            while (current) {
              var cmp2 = compare(key, current.key);
              if (cmp2 === 0)
                return current;
              else if (cmp2 < 0)
                current = current.left;
              else
                current = current.right;
            }
            return null;
          };
          Tree2.prototype.find = function(key) {
            if (this._root) {
              this._root = splay(key, this._root, this._comparator);
              if (this._comparator(key, this._root.key) !== 0)
                return null;
            }
            return this._root;
          };
          Tree2.prototype.contains = function(key) {
            var current = this._root;
            var compare = this._comparator;
            while (current) {
              var cmp2 = compare(key, current.key);
              if (cmp2 === 0)
                return true;
              else if (cmp2 < 0)
                current = current.left;
              else
                current = current.right;
            }
            return false;
          };
          Tree2.prototype.forEach = function(visitor, ctx) {
            var current = this._root;
            var Q = [];
            var done = false;
            while (!done) {
              if (current !== null) {
                Q.push(current);
                current = current.left;
              } else {
                if (Q.length !== 0) {
                  current = Q.pop();
                  visitor.call(ctx, current);
                  current = current.right;
                } else
                  done = true;
              }
            }
            return this;
          };
          Tree2.prototype.range = function(low, high, fn, ctx) {
            var Q = [];
            var compare = this._comparator;
            var node = this._root;
            var cmp2;
            while (Q.length !== 0 || node) {
              if (node) {
                Q.push(node);
                node = node.left;
              } else {
                node = Q.pop();
                cmp2 = compare(node.key, high);
                if (cmp2 > 0) {
                  break;
                } else if (compare(node.key, low) >= 0) {
                  if (fn.call(ctx, node))
                    return this;
                }
                node = node.right;
              }
            }
            return this;
          };
          Tree2.prototype.keys = function() {
            var keys = [];
            this.forEach(function(_a) {
              var key = _a.key;
              return keys.push(key);
            });
            return keys;
          };
          Tree2.prototype.values = function() {
            var values = [];
            this.forEach(function(_a) {
              var data = _a.data;
              return values.push(data);
            });
            return values;
          };
          Tree2.prototype.min = function() {
            if (this._root)
              return this.minNode(this._root).key;
            return null;
          };
          Tree2.prototype.max = function() {
            if (this._root)
              return this.maxNode(this._root).key;
            return null;
          };
          Tree2.prototype.minNode = function(t) {
            if (t === void 0) {
              t = this._root;
            }
            if (t)
              while (t.left) {
                t = t.left;
              }
            return t;
          };
          Tree2.prototype.maxNode = function(t) {
            if (t === void 0) {
              t = this._root;
            }
            if (t)
              while (t.right) {
                t = t.right;
              }
            return t;
          };
          Tree2.prototype.at = function(index2) {
            var current = this._root;
            var done = false;
            var i = 0;
            var Q = [];
            while (!done) {
              if (current) {
                Q.push(current);
                current = current.left;
              } else {
                if (Q.length > 0) {
                  current = Q.pop();
                  if (i === index2)
                    return current;
                  i++;
                  current = current.right;
                } else
                  done = true;
              }
            }
            return null;
          };
          Tree2.prototype.next = function(d) {
            var root = this._root;
            var successor = null;
            if (d.right) {
              successor = d.right;
              while (successor.left) {
                successor = successor.left;
              }
              return successor;
            }
            var comparator = this._comparator;
            while (root) {
              var cmp2 = comparator(d.key, root.key);
              if (cmp2 === 0)
                break;
              else if (cmp2 < 0) {
                successor = root;
                root = root.left;
              } else
                root = root.right;
            }
            return successor;
          };
          Tree2.prototype.prev = function(d) {
            var root = this._root;
            var predecessor = null;
            if (d.left !== null) {
              predecessor = d.left;
              while (predecessor.right) {
                predecessor = predecessor.right;
              }
              return predecessor;
            }
            var comparator = this._comparator;
            while (root) {
              var cmp2 = comparator(d.key, root.key);
              if (cmp2 === 0)
                break;
              else if (cmp2 < 0)
                root = root.left;
              else {
                predecessor = root;
                root = root.right;
              }
            }
            return predecessor;
          };
          Tree2.prototype.clear = function() {
            this._root = null;
            this._size = 0;
            return this;
          };
          Tree2.prototype.toList = function() {
            return toList(this._root);
          };
          Tree2.prototype.load = function(keys, values, presort) {
            if (values === void 0) {
              values = [];
            }
            if (presort === void 0) {
              presort = false;
            }
            var size = keys.length;
            var comparator = this._comparator;
            if (presort)
              sort(keys, values, 0, size - 1, comparator);
            if (this._root === null) {
              this._root = loadRecursive(keys, values, 0, size);
              this._size = size;
            } else {
              var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);
              size = this._size + size;
              this._root = sortedListToBST({
                head: mergedList
              }, 0, size);
            }
            return this;
          };
          Tree2.prototype.isEmpty = function() {
            return this._root === null;
          };
          Object.defineProperty(Tree2.prototype, "size", {
            get: function get() {
              return this._size;
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(Tree2.prototype, "root", {
            get: function get() {
              return this._root;
            },
            enumerable: true,
            configurable: true
          });
          Tree2.prototype.toString = function(printNode) {
            if (printNode === void 0) {
              printNode = function printNode2(n) {
                return String(n.key);
              };
            }
            var out = [];
            printRow(this._root, "", true, function(v) {
              return out.push(v);
            }, printNode);
            return out.join("");
          };
          Tree2.prototype.update = function(key, newKey, newData) {
            var comparator = this._comparator;
            var _a = split(key, this._root, comparator), left = _a.left, right = _a.right;
            if (comparator(key, newKey) < 0) {
              right = insert(newKey, newData, right, comparator);
            } else {
              left = insert(newKey, newData, left, comparator);
            }
            this._root = merge(left, right, comparator);
          };
          Tree2.prototype.split = function(key) {
            return split(key, this._root, this._comparator);
          };
          return Tree2;
        }();
        function loadRecursive(keys, values, start, end) {
          var size = end - start;
          if (size > 0) {
            var middle = start + Math.floor(size / 2);
            var key = keys[middle];
            var data = values[middle];
            var node = new Node2(key, data);
            node.left = loadRecursive(keys, values, start, middle);
            node.right = loadRecursive(keys, values, middle + 1, end);
            return node;
          }
          return null;
        }
        function createList(keys, values) {
          var head = new Node2(null, null);
          var p = head;
          for (var i = 0; i < keys.length; i++) {
            p = p.next = new Node2(keys[i], values[i]);
          }
          p.next = null;
          return head.next;
        }
        function toList(root) {
          var current = root;
          var Q = [];
          var done = false;
          var head = new Node2(null, null);
          var p = head;
          while (!done) {
            if (current) {
              Q.push(current);
              current = current.left;
            } else {
              if (Q.length > 0) {
                current = p = p.next = Q.pop();
                current = current.right;
              } else
                done = true;
            }
          }
          p.next = null;
          return head.next;
        }
        function sortedListToBST(list, start, end) {
          var size = end - start;
          if (size > 0) {
            var middle = start + Math.floor(size / 2);
            var left = sortedListToBST(list, start, middle);
            var root = list.head;
            root.left = left;
            list.head = list.head.next;
            root.right = sortedListToBST(list, middle + 1, end);
            return root;
          }
          return null;
        }
        function mergeLists(l1, l2, compare) {
          var head = new Node2(null, null);
          var p = head;
          var p1 = l1;
          var p2 = l2;
          while (p1 !== null && p2 !== null) {
            if (compare(p1.key, p2.key) < 0) {
              p.next = p1;
              p1 = p1.next;
            } else {
              p.next = p2;
              p2 = p2.next;
            }
            p = p.next;
          }
          if (p1 !== null) {
            p.next = p1;
          } else if (p2 !== null) {
            p.next = p2;
          }
          return head.next;
        }
        function sort(keys, values, left, right, compare) {
          if (left >= right)
            return;
          var pivot = keys[left + right >> 1];
          var i = left - 1;
          var j = right + 1;
          while (true) {
            do {
              i++;
            } while (compare(keys[i], pivot) < 0);
            do {
              j--;
            } while (compare(keys[j], pivot) > 0);
            if (i >= j)
              break;
            var tmp = keys[i];
            keys[i] = keys[j];
            keys[j] = tmp;
            tmp = values[i];
            values[i] = values[j];
            values[j] = tmp;
          }
          sort(keys, values, left, j, compare);
          sort(keys, values, j + 1, right, compare);
        }
        var isInBbox = function isInBbox2(bbox3, point2) {
          return bbox3.ll.x <= point2.x && point2.x <= bbox3.ur.x && bbox3.ll.y <= point2.y && point2.y <= bbox3.ur.y;
        };
        var getBboxOverlap = function getBboxOverlap2(b1, b2) {
          if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y)
            return null;
          var lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;
          var upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x;
          var lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;
          var upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y;
          return {
            ll: {
              x: lowerX,
              y: lowerY
            },
            ur: {
              x: upperX,
              y: upperY
            }
          };
        };
        var epsilon5 = Number.EPSILON;
        if (epsilon5 === void 0)
          epsilon5 = Math.pow(2, -52);
        var EPSILON_SQ = epsilon5 * epsilon5;
        var cmp = function cmp2(a, b) {
          if (-epsilon5 < a && a < epsilon5) {
            if (-epsilon5 < b && b < epsilon5) {
              return 0;
            }
          }
          var ab = a - b;
          if (ab * ab < EPSILON_SQ * a * b) {
            return 0;
          }
          return a < b ? -1 : 1;
        };
        var PtRounder = /* @__PURE__ */ function() {
          function PtRounder2() {
            _classCallCheck(this, PtRounder2);
            this.reset();
          }
          _createClass(PtRounder2, [{
            key: "reset",
            value: function reset() {
              this.xRounder = new CoordRounder();
              this.yRounder = new CoordRounder();
            }
          }, {
            key: "round",
            value: function round(x2, y2) {
              return {
                x: this.xRounder.round(x2),
                y: this.yRounder.round(y2)
              };
            }
          }]);
          return PtRounder2;
        }();
        var CoordRounder = /* @__PURE__ */ function() {
          function CoordRounder2() {
            _classCallCheck(this, CoordRounder2);
            this.tree = new Tree();
            this.round(0);
          }
          _createClass(CoordRounder2, [{
            key: "round",
            value: function round(coord) {
              var node = this.tree.add(coord);
              var prevNode = this.tree.prev(node);
              if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {
                this.tree.remove(coord);
                return prevNode.key;
              }
              var nextNode = this.tree.next(node);
              if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {
                this.tree.remove(coord);
                return nextNode.key;
              }
              return coord;
            }
          }]);
          return CoordRounder2;
        }();
        var rounder = new PtRounder();
        var crossProduct = function crossProduct2(a, b) {
          return a.x * b.y - a.y * b.x;
        };
        var dotProduct = function dotProduct2(a, b) {
          return a.x * b.x + a.y * b.y;
        };
        var compareVectorAngles = function compareVectorAngles2(basePt, endPt1, endPt2) {
          var v1 = {
            x: endPt1.x - basePt.x,
            y: endPt1.y - basePt.y
          };
          var v2 = {
            x: endPt2.x - basePt.x,
            y: endPt2.y - basePt.y
          };
          var kross = crossProduct(v1, v2);
          return cmp(kross, 0);
        };
        var length2 = function length3(v) {
          return Math.sqrt(dotProduct(v, v));
        };
        var sineOfAngle = function sineOfAngle2(pShared, pBase, pAngle) {
          var vBase = {
            x: pBase.x - pShared.x,
            y: pBase.y - pShared.y
          };
          var vAngle = {
            x: pAngle.x - pShared.x,
            y: pAngle.y - pShared.y
          };
          return crossProduct(vAngle, vBase) / length2(vAngle) / length2(vBase);
        };
        var cosineOfAngle = function cosineOfAngle2(pShared, pBase, pAngle) {
          var vBase = {
            x: pBase.x - pShared.x,
            y: pBase.y - pShared.y
          };
          var vAngle = {
            x: pAngle.x - pShared.x,
            y: pAngle.y - pShared.y
          };
          return dotProduct(vAngle, vBase) / length2(vAngle) / length2(vBase);
        };
        var horizontalIntersection = function horizontalIntersection2(pt, v, y2) {
          if (v.y === 0)
            return null;
          return {
            x: pt.x + v.x / v.y * (y2 - pt.y),
            y: y2
          };
        };
        var verticalIntersection = function verticalIntersection2(pt, v, x2) {
          if (v.x === 0)
            return null;
          return {
            x: x2,
            y: pt.y + v.y / v.x * (x2 - pt.x)
          };
        };
        var intersection = function intersection2(pt1, v1, pt2, v2) {
          if (v1.x === 0)
            return verticalIntersection(pt2, v2, pt1.x);
          if (v2.x === 0)
            return verticalIntersection(pt1, v1, pt2.x);
          if (v1.y === 0)
            return horizontalIntersection(pt2, v2, pt1.y);
          if (v2.y === 0)
            return horizontalIntersection(pt1, v1, pt2.y);
          var kross = crossProduct(v1, v2);
          if (kross == 0)
            return null;
          var ve = {
            x: pt2.x - pt1.x,
            y: pt2.y - pt1.y
          };
          var d1 = crossProduct(ve, v1) / kross;
          var d2 = crossProduct(ve, v2) / kross;
          var x12 = pt1.x + d2 * v1.x, x2 = pt2.x + d1 * v2.x;
          var y1 = pt1.y + d2 * v1.y, y2 = pt2.y + d1 * v2.y;
          var x3 = (x12 + x2) / 2;
          var y3 = (y1 + y2) / 2;
          return {
            x: x3,
            y: y3
          };
        };
        var SweepEvent = /* @__PURE__ */ function() {
          _createClass(SweepEvent2, null, [{
            key: "compare",
            value: function compare(a, b) {
              var ptCmp = SweepEvent2.comparePoints(a.point, b.point);
              if (ptCmp !== 0)
                return ptCmp;
              if (a.point !== b.point)
                a.link(b);
              if (a.isLeft !== b.isLeft)
                return a.isLeft ? 1 : -1;
              return Segment.compare(a.segment, b.segment);
            }
          }, {
            key: "comparePoints",
            value: function comparePoints(aPt, bPt) {
              if (aPt.x < bPt.x)
                return -1;
              if (aPt.x > bPt.x)
                return 1;
              if (aPt.y < bPt.y)
                return -1;
              if (aPt.y > bPt.y)
                return 1;
              return 0;
            }
          }]);
          function SweepEvent2(point2, isLeft) {
            _classCallCheck(this, SweepEvent2);
            if (point2.events === void 0)
              point2.events = [this];
            else
              point2.events.push(this);
            this.point = point2;
            this.isLeft = isLeft;
          }
          _createClass(SweepEvent2, [{
            key: "link",
            value: function link2(other) {
              if (other.point === this.point) {
                throw new Error("Tried to link already linked events");
              }
              var otherEvents = other.point.events;
              for (var i = 0, iMax = otherEvents.length; i < iMax; i++) {
                var evt = otherEvents[i];
                this.point.events.push(evt);
                evt.point = this.point;
              }
              this.checkForConsuming();
            }
          }, {
            key: "checkForConsuming",
            value: function checkForConsuming() {
              var numEvents = this.point.events.length;
              for (var i = 0; i < numEvents; i++) {
                var evt1 = this.point.events[i];
                if (evt1.segment.consumedBy !== void 0)
                  continue;
                for (var j = i + 1; j < numEvents; j++) {
                  var evt2 = this.point.events[j];
                  if (evt2.consumedBy !== void 0)
                    continue;
                  if (evt1.otherSE.point.events !== evt2.otherSE.point.events)
                    continue;
                  evt1.segment.consume(evt2.segment);
                }
              }
            }
          }, {
            key: "getAvailableLinkedEvents",
            value: function getAvailableLinkedEvents() {
              var events = [];
              for (var i = 0, iMax = this.point.events.length; i < iMax; i++) {
                var evt = this.point.events[i];
                if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {
                  events.push(evt);
                }
              }
              return events;
            }
          }, {
            key: "getLeftmostComparator",
            value: function getLeftmostComparator(baseEvent) {
              var _this = this;
              var cache = /* @__PURE__ */ new Map();
              var fillCache = function fillCache2(linkedEvent) {
                var nextEvent = linkedEvent.otherSE;
                cache.set(linkedEvent, {
                  sine: sineOfAngle(_this.point, baseEvent.point, nextEvent.point),
                  cosine: cosineOfAngle(_this.point, baseEvent.point, nextEvent.point)
                });
              };
              return function(a, b) {
                if (!cache.has(a))
                  fillCache(a);
                if (!cache.has(b))
                  fillCache(b);
                var _cache$get = cache.get(a), asine = _cache$get.sine, acosine = _cache$get.cosine;
                var _cache$get2 = cache.get(b), bsine = _cache$get2.sine, bcosine = _cache$get2.cosine;
                if (asine >= 0 && bsine >= 0) {
                  if (acosine < bcosine)
                    return 1;
                  if (acosine > bcosine)
                    return -1;
                  return 0;
                }
                if (asine < 0 && bsine < 0) {
                  if (acosine < bcosine)
                    return -1;
                  if (acosine > bcosine)
                    return 1;
                  return 0;
                }
                if (bsine < asine)
                  return -1;
                if (bsine > asine)
                  return 1;
                return 0;
              };
            }
          }]);
          return SweepEvent2;
        }();
        var segmentId = 0;
        var Segment = /* @__PURE__ */ function() {
          _createClass(Segment2, null, [{
            key: "compare",
            value: function compare(a, b) {
              var alx = a.leftSE.point.x;
              var blx = b.leftSE.point.x;
              var arx = a.rightSE.point.x;
              var brx = b.rightSE.point.x;
              if (brx < alx)
                return 1;
              if (arx < blx)
                return -1;
              var aly = a.leftSE.point.y;
              var bly = b.leftSE.point.y;
              var ary = a.rightSE.point.y;
              var bry = b.rightSE.point.y;
              if (alx < blx) {
                if (bly < aly && bly < ary)
                  return 1;
                if (bly > aly && bly > ary)
                  return -1;
                var aCmpBLeft = a.comparePoint(b.leftSE.point);
                if (aCmpBLeft < 0)
                  return 1;
                if (aCmpBLeft > 0)
                  return -1;
                var bCmpARight = b.comparePoint(a.rightSE.point);
                if (bCmpARight !== 0)
                  return bCmpARight;
                return -1;
              }
              if (alx > blx) {
                if (aly < bly && aly < bry)
                  return -1;
                if (aly > bly && aly > bry)
                  return 1;
                var bCmpALeft = b.comparePoint(a.leftSE.point);
                if (bCmpALeft !== 0)
                  return bCmpALeft;
                var aCmpBRight = a.comparePoint(b.rightSE.point);
                if (aCmpBRight < 0)
                  return 1;
                if (aCmpBRight > 0)
                  return -1;
                return 1;
              }
              if (aly < bly)
                return -1;
              if (aly > bly)
                return 1;
              if (arx < brx) {
                var _bCmpARight = b.comparePoint(a.rightSE.point);
                if (_bCmpARight !== 0)
                  return _bCmpARight;
              }
              if (arx > brx) {
                var _aCmpBRight = a.comparePoint(b.rightSE.point);
                if (_aCmpBRight < 0)
                  return 1;
                if (_aCmpBRight > 0)
                  return -1;
              }
              if (arx !== brx) {
                var ay = ary - aly;
                var ax = arx - alx;
                var by = bry - bly;
                var bx = brx - blx;
                if (ay > ax && by < bx)
                  return 1;
                if (ay < ax && by > bx)
                  return -1;
              }
              if (arx > brx)
                return 1;
              if (arx < brx)
                return -1;
              if (ary < bry)
                return -1;
              if (ary > bry)
                return 1;
              if (a.id < b.id)
                return -1;
              if (a.id > b.id)
                return 1;
              return 0;
            }
          }]);
          function Segment2(leftSE, rightSE, rings, windings) {
            _classCallCheck(this, Segment2);
            this.id = ++segmentId;
            this.leftSE = leftSE;
            leftSE.segment = this;
            leftSE.otherSE = rightSE;
            this.rightSE = rightSE;
            rightSE.segment = this;
            rightSE.otherSE = leftSE;
            this.rings = rings;
            this.windings = windings;
          }
          _createClass(Segment2, [{
            key: "replaceRightSE",
            value: function replaceRightSE(newRightSE) {
              this.rightSE = newRightSE;
              this.rightSE.segment = this;
              this.rightSE.otherSE = this.leftSE;
              this.leftSE.otherSE = this.rightSE;
            }
          }, {
            key: "bbox",
            value: function bbox3() {
              var y1 = this.leftSE.point.y;
              var y2 = this.rightSE.point.y;
              return {
                ll: {
                  x: this.leftSE.point.x,
                  y: y1 < y2 ? y1 : y2
                },
                ur: {
                  x: this.rightSE.point.x,
                  y: y1 > y2 ? y1 : y2
                }
              };
            }
          }, {
            key: "vector",
            value: function vector() {
              return {
                x: this.rightSE.point.x - this.leftSE.point.x,
                y: this.rightSE.point.y - this.leftSE.point.y
              };
            }
          }, {
            key: "isAnEndpoint",
            value: function isAnEndpoint(pt) {
              return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;
            }
          }, {
            key: "comparePoint",
            value: function comparePoint(point2) {
              if (this.isAnEndpoint(point2))
                return 0;
              var lPt = this.leftSE.point;
              var rPt = this.rightSE.point;
              var v = this.vector();
              if (lPt.x === rPt.x) {
                if (point2.x === lPt.x)
                  return 0;
                return point2.x < lPt.x ? 1 : -1;
              }
              var yDist = (point2.y - lPt.y) / v.y;
              var xFromYDist = lPt.x + yDist * v.x;
              if (point2.x === xFromYDist)
                return 0;
              var xDist = (point2.x - lPt.x) / v.x;
              var yFromXDist = lPt.y + xDist * v.y;
              if (point2.y === yFromXDist)
                return 0;
              return point2.y < yFromXDist ? -1 : 1;
            }
          }, {
            key: "getIntersection",
            value: function getIntersection(other) {
              var tBbox = this.bbox();
              var oBbox = other.bbox();
              var bboxOverlap = getBboxOverlap(tBbox, oBbox);
              if (bboxOverlap === null)
                return null;
              var tlp = this.leftSE.point;
              var trp = this.rightSE.point;
              var olp = other.leftSE.point;
              var orp = other.rightSE.point;
              var touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;
              var touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;
              var touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;
              var touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0;
              if (touchesThisLSE && touchesOtherLSE) {
                if (touchesThisRSE && !touchesOtherRSE)
                  return trp;
                if (!touchesThisRSE && touchesOtherRSE)
                  return orp;
                return null;
              }
              if (touchesThisLSE) {
                if (touchesOtherRSE) {
                  if (tlp.x === orp.x && tlp.y === orp.y)
                    return null;
                }
                return tlp;
              }
              if (touchesOtherLSE) {
                if (touchesThisRSE) {
                  if (trp.x === olp.x && trp.y === olp.y)
                    return null;
                }
                return olp;
              }
              if (touchesThisRSE && touchesOtherRSE)
                return null;
              if (touchesThisRSE)
                return trp;
              if (touchesOtherRSE)
                return orp;
              var pt = intersection(tlp, this.vector(), olp, other.vector());
              if (pt === null)
                return null;
              if (!isInBbox(bboxOverlap, pt))
                return null;
              return rounder.round(pt.x, pt.y);
            }
          }, {
            key: "split",
            value: function split2(point2) {
              var newEvents = [];
              var alreadyLinked = point2.events !== void 0;
              var newLeftSE = new SweepEvent(point2, true);
              var newRightSE = new SweepEvent(point2, false);
              var oldRightSE = this.rightSE;
              this.replaceRightSE(newRightSE);
              newEvents.push(newRightSE);
              newEvents.push(newLeftSE);
              var newSeg = new Segment2(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice());
              if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {
                newSeg.swapEvents();
              }
              if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {
                this.swapEvents();
              }
              if (alreadyLinked) {
                newLeftSE.checkForConsuming();
                newRightSE.checkForConsuming();
              }
              return newEvents;
            }
          }, {
            key: "swapEvents",
            value: function swapEvents() {
              var tmpEvt = this.rightSE;
              this.rightSE = this.leftSE;
              this.leftSE = tmpEvt;
              this.leftSE.isLeft = true;
              this.rightSE.isLeft = false;
              for (var i = 0, iMax = this.windings.length; i < iMax; i++) {
                this.windings[i] *= -1;
              }
            }
          }, {
            key: "consume",
            value: function consume(other) {
              var consumer = this;
              var consumee = other;
              while (consumer.consumedBy) {
                consumer = consumer.consumedBy;
              }
              while (consumee.consumedBy) {
                consumee = consumee.consumedBy;
              }
              var cmp2 = Segment2.compare(consumer, consumee);
              if (cmp2 === 0)
                return;
              if (cmp2 > 0) {
                var tmp = consumer;
                consumer = consumee;
                consumee = tmp;
              }
              if (consumer.prev === consumee) {
                var _tmp = consumer;
                consumer = consumee;
                consumee = _tmp;
              }
              for (var i = 0, iMax = consumee.rings.length; i < iMax; i++) {
                var ring = consumee.rings[i];
                var winding = consumee.windings[i];
                var index2 = consumer.rings.indexOf(ring);
                if (index2 === -1) {
                  consumer.rings.push(ring);
                  consumer.windings.push(winding);
                } else
                  consumer.windings[index2] += winding;
              }
              consumee.rings = null;
              consumee.windings = null;
              consumee.consumedBy = consumer;
              consumee.leftSE.consumedBy = consumer.leftSE;
              consumee.rightSE.consumedBy = consumer.rightSE;
            }
          }, {
            key: "prevInResult",
            value: function prevInResult() {
              if (this._prevInResult !== void 0)
                return this._prevInResult;
              if (!this.prev)
                this._prevInResult = null;
              else if (this.prev.isInResult())
                this._prevInResult = this.prev;
              else
                this._prevInResult = this.prev.prevInResult();
              return this._prevInResult;
            }
          }, {
            key: "beforeState",
            value: function beforeState() {
              if (this._beforeState !== void 0)
                return this._beforeState;
              if (!this.prev)
                this._beforeState = {
                  rings: [],
                  windings: [],
                  multiPolys: []
                };
              else {
                var seg = this.prev.consumedBy || this.prev;
                this._beforeState = seg.afterState();
              }
              return this._beforeState;
            }
          }, {
            key: "afterState",
            value: function afterState() {
              if (this._afterState !== void 0)
                return this._afterState;
              var beforeState = this.beforeState();
              this._afterState = {
                rings: beforeState.rings.slice(0),
                windings: beforeState.windings.slice(0),
                multiPolys: []
              };
              var ringsAfter = this._afterState.rings;
              var windingsAfter = this._afterState.windings;
              var mpsAfter = this._afterState.multiPolys;
              for (var i = 0, iMax = this.rings.length; i < iMax; i++) {
                var ring = this.rings[i];
                var winding = this.windings[i];
                var index2 = ringsAfter.indexOf(ring);
                if (index2 === -1) {
                  ringsAfter.push(ring);
                  windingsAfter.push(winding);
                } else
                  windingsAfter[index2] += winding;
              }
              var polysAfter = [];
              var polysExclude = [];
              for (var _i = 0, _iMax = ringsAfter.length; _i < _iMax; _i++) {
                if (windingsAfter[_i] === 0)
                  continue;
                var _ring = ringsAfter[_i];
                var poly = _ring.poly;
                if (polysExclude.indexOf(poly) !== -1)
                  continue;
                if (_ring.isExterior)
                  polysAfter.push(poly);
                else {
                  if (polysExclude.indexOf(poly) === -1)
                    polysExclude.push(poly);
                  var _index = polysAfter.indexOf(_ring.poly);
                  if (_index !== -1)
                    polysAfter.splice(_index, 1);
                }
              }
              for (var _i2 = 0, _iMax2 = polysAfter.length; _i2 < _iMax2; _i2++) {
                var mp = polysAfter[_i2].multiPoly;
                if (mpsAfter.indexOf(mp) === -1)
                  mpsAfter.push(mp);
              }
              return this._afterState;
            }
          }, {
            key: "isInResult",
            value: function isInResult() {
              if (this.consumedBy)
                return false;
              if (this._isInResult !== void 0)
                return this._isInResult;
              var mpsBefore = this.beforeState().multiPolys;
              var mpsAfter = this.afterState().multiPolys;
              switch (operation.type) {
                case "union": {
                  var noBefores = mpsBefore.length === 0;
                  var noAfters = mpsAfter.length === 0;
                  this._isInResult = noBefores !== noAfters;
                  break;
                }
                case "intersection": {
                  var least;
                  var most;
                  if (mpsBefore.length < mpsAfter.length) {
                    least = mpsBefore.length;
                    most = mpsAfter.length;
                  } else {
                    least = mpsAfter.length;
                    most = mpsBefore.length;
                  }
                  this._isInResult = most === operation.numMultiPolys && least < most;
                  break;
                }
                case "xor": {
                  var diff = Math.abs(mpsBefore.length - mpsAfter.length);
                  this._isInResult = diff % 2 === 1;
                  break;
                }
                case "difference": {
                  var isJustSubject = function isJustSubject2(mps) {
                    return mps.length === 1 && mps[0].isSubject;
                  };
                  this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);
                  break;
                }
                default:
                  throw new Error("Unrecognized operation type found ".concat(operation.type));
              }
              return this._isInResult;
            }
          }], [{
            key: "fromRing",
            value: function fromRing(pt1, pt2, ring) {
              var leftPt, rightPt, winding;
              var cmpPts = SweepEvent.comparePoints(pt1, pt2);
              if (cmpPts < 0) {
                leftPt = pt1;
                rightPt = pt2;
                winding = 1;
              } else if (cmpPts > 0) {
                leftPt = pt2;
                rightPt = pt1;
                winding = -1;
              } else
                throw new Error("Tried to create degenerate segment at [".concat(pt1.x, ", ").concat(pt1.y, "]"));
              var leftSE = new SweepEvent(leftPt, true);
              var rightSE = new SweepEvent(rightPt, false);
              return new Segment2(leftSE, rightSE, [ring], [winding]);
            }
          }]);
          return Segment2;
        }();
        var RingIn = /* @__PURE__ */ function() {
          function RingIn2(geomRing, poly, isExterior) {
            _classCallCheck(this, RingIn2);
            if (!Array.isArray(geomRing) || geomRing.length === 0) {
              throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
            }
            this.poly = poly;
            this.isExterior = isExterior;
            this.segments = [];
            if (typeof geomRing[0][0] !== "number" || typeof geomRing[0][1] !== "number") {
              throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
            }
            var firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);
            this.bbox = {
              ll: {
                x: firstPoint.x,
                y: firstPoint.y
              },
              ur: {
                x: firstPoint.x,
                y: firstPoint.y
              }
            };
            var prevPoint = firstPoint;
            for (var i = 1, iMax = geomRing.length; i < iMax; i++) {
              if (typeof geomRing[i][0] !== "number" || typeof geomRing[i][1] !== "number") {
                throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
              }
              var point2 = rounder.round(geomRing[i][0], geomRing[i][1]);
              if (point2.x === prevPoint.x && point2.y === prevPoint.y)
                continue;
              this.segments.push(Segment.fromRing(prevPoint, point2, this));
              if (point2.x < this.bbox.ll.x)
                this.bbox.ll.x = point2.x;
              if (point2.y < this.bbox.ll.y)
                this.bbox.ll.y = point2.y;
              if (point2.x > this.bbox.ur.x)
                this.bbox.ur.x = point2.x;
              if (point2.y > this.bbox.ur.y)
                this.bbox.ur.y = point2.y;
              prevPoint = point2;
            }
            if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {
              this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));
            }
          }
          _createClass(RingIn2, [{
            key: "getSweepEvents",
            value: function getSweepEvents() {
              var sweepEvents = [];
              for (var i = 0, iMax = this.segments.length; i < iMax; i++) {
                var segment = this.segments[i];
                sweepEvents.push(segment.leftSE);
                sweepEvents.push(segment.rightSE);
              }
              return sweepEvents;
            }
          }]);
          return RingIn2;
        }();
        var PolyIn = /* @__PURE__ */ function() {
          function PolyIn2(geomPoly, multiPoly) {
            _classCallCheck(this, PolyIn2);
            if (!Array.isArray(geomPoly)) {
              throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
            }
            this.exteriorRing = new RingIn(geomPoly[0], this, true);
            this.bbox = {
              ll: {
                x: this.exteriorRing.bbox.ll.x,
                y: this.exteriorRing.bbox.ll.y
              },
              ur: {
                x: this.exteriorRing.bbox.ur.x,
                y: this.exteriorRing.bbox.ur.y
              }
            };
            this.interiorRings = [];
            for (var i = 1, iMax = geomPoly.length; i < iMax; i++) {
              var ring = new RingIn(geomPoly[i], this, false);
              if (ring.bbox.ll.x < this.bbox.ll.x)
                this.bbox.ll.x = ring.bbox.ll.x;
              if (ring.bbox.ll.y < this.bbox.ll.y)
                this.bbox.ll.y = ring.bbox.ll.y;
              if (ring.bbox.ur.x > this.bbox.ur.x)
                this.bbox.ur.x = ring.bbox.ur.x;
              if (ring.bbox.ur.y > this.bbox.ur.y)
                this.bbox.ur.y = ring.bbox.ur.y;
              this.interiorRings.push(ring);
            }
            this.multiPoly = multiPoly;
          }
          _createClass(PolyIn2, [{
            key: "getSweepEvents",
            value: function getSweepEvents() {
              var sweepEvents = this.exteriorRing.getSweepEvents();
              for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
                var ringSweepEvents = this.interiorRings[i].getSweepEvents();
                for (var j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {
                  sweepEvents.push(ringSweepEvents[j]);
                }
              }
              return sweepEvents;
            }
          }]);
          return PolyIn2;
        }();
        var MultiPolyIn = /* @__PURE__ */ function() {
          function MultiPolyIn2(geom, isSubject) {
            _classCallCheck(this, MultiPolyIn2);
            if (!Array.isArray(geom)) {
              throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
            }
            try {
              if (typeof geom[0][0][0] === "number")
                geom = [geom];
            } catch (ex) {
            }
            this.polys = [];
            this.bbox = {
              ll: {
                x: Number.POSITIVE_INFINITY,
                y: Number.POSITIVE_INFINITY
              },
              ur: {
                x: Number.NEGATIVE_INFINITY,
                y: Number.NEGATIVE_INFINITY
              }
            };
            for (var i = 0, iMax = geom.length; i < iMax; i++) {
              var poly = new PolyIn(geom[i], this);
              if (poly.bbox.ll.x < this.bbox.ll.x)
                this.bbox.ll.x = poly.bbox.ll.x;
              if (poly.bbox.ll.y < this.bbox.ll.y)
                this.bbox.ll.y = poly.bbox.ll.y;
              if (poly.bbox.ur.x > this.bbox.ur.x)
                this.bbox.ur.x = poly.bbox.ur.x;
              if (poly.bbox.ur.y > this.bbox.ur.y)
                this.bbox.ur.y = poly.bbox.ur.y;
              this.polys.push(poly);
            }
            this.isSubject = isSubject;
          }
          _createClass(MultiPolyIn2, [{
            key: "getSweepEvents",
            value: function getSweepEvents() {
              var sweepEvents = [];
              for (var i = 0, iMax = this.polys.length; i < iMax; i++) {
                var polySweepEvents = this.polys[i].getSweepEvents();
                for (var j = 0, jMax = polySweepEvents.length; j < jMax; j++) {
                  sweepEvents.push(polySweepEvents[j]);
                }
              }
              return sweepEvents;
            }
          }]);
          return MultiPolyIn2;
        }();
        var RingOut = /* @__PURE__ */ function() {
          _createClass(RingOut2, null, [{
            key: "factory",
            value: function factory(allSegments) {
              var ringsOut = [];
              for (var i = 0, iMax = allSegments.length; i < iMax; i++) {
                var segment = allSegments[i];
                if (!segment.isInResult() || segment.ringOut)
                  continue;
                var prevEvent = null;
                var event = segment.leftSE;
                var nextEvent = segment.rightSE;
                var events = [event];
                var startingPoint = event.point;
                var intersectionLEs = [];
                while (true) {
                  prevEvent = event;
                  event = nextEvent;
                  events.push(event);
                  if (event.point === startingPoint)
                    break;
                  while (true) {
                    var availableLEs = event.getAvailableLinkedEvents();
                    if (availableLEs.length === 0) {
                      var firstPt = events[0].point;
                      var lastPt = events[events.length - 1].point;
                      throw new Error("Unable to complete output ring starting at [".concat(firstPt.x, ",") + " ".concat(firstPt.y, "]. Last matching segment found ends at") + " [".concat(lastPt.x, ", ").concat(lastPt.y, "]."));
                    }
                    if (availableLEs.length === 1) {
                      nextEvent = availableLEs[0].otherSE;
                      break;
                    }
                    var indexLE = null;
                    for (var j = 0, jMax = intersectionLEs.length; j < jMax; j++) {
                      if (intersectionLEs[j].point === event.point) {
                        indexLE = j;
                        break;
                      }
                    }
                    if (indexLE !== null) {
                      var intersectionLE = intersectionLEs.splice(indexLE)[0];
                      var ringEvents = events.splice(intersectionLE.index);
                      ringEvents.unshift(ringEvents[0].otherSE);
                      ringsOut.push(new RingOut2(ringEvents.reverse()));
                      continue;
                    }
                    intersectionLEs.push({
                      index: events.length,
                      point: event.point
                    });
                    var comparator = event.getLeftmostComparator(prevEvent);
                    nextEvent = availableLEs.sort(comparator)[0].otherSE;
                    break;
                  }
                }
                ringsOut.push(new RingOut2(events));
              }
              return ringsOut;
            }
          }]);
          function RingOut2(events) {
            _classCallCheck(this, RingOut2);
            this.events = events;
            for (var i = 0, iMax = events.length; i < iMax; i++) {
              events[i].segment.ringOut = this;
            }
            this.poly = null;
          }
          _createClass(RingOut2, [{
            key: "getGeom",
            value: function getGeom2() {
              var prevPt = this.events[0].point;
              var points = [prevPt];
              for (var i = 1, iMax = this.events.length - 1; i < iMax; i++) {
                var _pt = this.events[i].point;
                var _nextPt = this.events[i + 1].point;
                if (compareVectorAngles(_pt, prevPt, _nextPt) === 0)
                  continue;
                points.push(_pt);
                prevPt = _pt;
              }
              if (points.length === 1)
                return null;
              var pt = points[0];
              var nextPt = points[1];
              if (compareVectorAngles(pt, prevPt, nextPt) === 0)
                points.shift();
              points.push(points[0]);
              var step = this.isExteriorRing() ? 1 : -1;
              var iStart = this.isExteriorRing() ? 0 : points.length - 1;
              var iEnd = this.isExteriorRing() ? points.length : -1;
              var orderedPoints = [];
              for (var _i = iStart; _i != iEnd; _i += step) {
                orderedPoints.push([points[_i].x, points[_i].y]);
              }
              return orderedPoints;
            }
          }, {
            key: "isExteriorRing",
            value: function isExteriorRing() {
              if (this._isExteriorRing === void 0) {
                var enclosing = this.enclosingRing();
                this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;
              }
              return this._isExteriorRing;
            }
          }, {
            key: "enclosingRing",
            value: function enclosingRing() {
              if (this._enclosingRing === void 0) {
                this._enclosingRing = this._calcEnclosingRing();
              }
              return this._enclosingRing;
            }
          }, {
            key: "_calcEnclosingRing",
            value: function _calcEnclosingRing() {
              var leftMostEvt = this.events[0];
              for (var i = 1, iMax = this.events.length; i < iMax; i++) {
                var evt = this.events[i];
                if (SweepEvent.compare(leftMostEvt, evt) > 0)
                  leftMostEvt = evt;
              }
              var prevSeg = leftMostEvt.segment.prevInResult();
              var prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
              while (true) {
                if (!prevSeg)
                  return null;
                if (!prevPrevSeg)
                  return prevSeg.ringOut;
                if (prevPrevSeg.ringOut !== prevSeg.ringOut) {
                  if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {
                    return prevSeg.ringOut;
                  } else
                    return prevSeg.ringOut.enclosingRing();
                }
                prevSeg = prevPrevSeg.prevInResult();
                prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
              }
            }
          }]);
          return RingOut2;
        }();
        var PolyOut = /* @__PURE__ */ function() {
          function PolyOut2(exteriorRing) {
            _classCallCheck(this, PolyOut2);
            this.exteriorRing = exteriorRing;
            exteriorRing.poly = this;
            this.interiorRings = [];
          }
          _createClass(PolyOut2, [{
            key: "addInterior",
            value: function addInterior(ring) {
              this.interiorRings.push(ring);
              ring.poly = this;
            }
          }, {
            key: "getGeom",
            value: function getGeom2() {
              var geom = [this.exteriorRing.getGeom()];
              if (geom[0] === null)
                return null;
              for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
                var ringGeom = this.interiorRings[i].getGeom();
                if (ringGeom === null)
                  continue;
                geom.push(ringGeom);
              }
              return geom;
            }
          }]);
          return PolyOut2;
        }();
        var MultiPolyOut = /* @__PURE__ */ function() {
          function MultiPolyOut2(rings) {
            _classCallCheck(this, MultiPolyOut2);
            this.rings = rings;
            this.polys = this._composePolys(rings);
          }
          _createClass(MultiPolyOut2, [{
            key: "getGeom",
            value: function getGeom2() {
              var geom = [];
              for (var i = 0, iMax = this.polys.length; i < iMax; i++) {
                var polyGeom = this.polys[i].getGeom();
                if (polyGeom === null)
                  continue;
                geom.push(polyGeom);
              }
              return geom;
            }
          }, {
            key: "_composePolys",
            value: function _composePolys(rings) {
              var polys = [];
              for (var i = 0, iMax = rings.length; i < iMax; i++) {
                var ring = rings[i];
                if (ring.poly)
                  continue;
                if (ring.isExteriorRing())
                  polys.push(new PolyOut(ring));
                else {
                  var enclosingRing = ring.enclosingRing();
                  if (!enclosingRing.poly)
                    polys.push(new PolyOut(enclosingRing));
                  enclosingRing.poly.addInterior(ring);
                }
              }
              return polys;
            }
          }]);
          return MultiPolyOut2;
        }();
        var SweepLine = /* @__PURE__ */ function() {
          function SweepLine2(queue) {
            var comparator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Segment.compare;
            _classCallCheck(this, SweepLine2);
            this.queue = queue;
            this.tree = new Tree(comparator);
            this.segments = [];
          }
          _createClass(SweepLine2, [{
            key: "process",
            value: function process2(event) {
              var segment = event.segment;
              var newEvents = [];
              if (event.consumedBy) {
                if (event.isLeft)
                  this.queue.remove(event.otherSE);
                else
                  this.tree.remove(segment);
                return newEvents;
              }
              var node = event.isLeft ? this.tree.insert(segment) : this.tree.find(segment);
              if (!node)
                throw new Error("Unable to find segment #".concat(segment.id, " ") + "[".concat(segment.leftSE.point.x, ", ").concat(segment.leftSE.point.y, "] -> ") + "[".concat(segment.rightSE.point.x, ", ").concat(segment.rightSE.point.y, "] ") + "in SweepLine tree. Please submit a bug report.");
              var prevNode = node;
              var nextNode = node;
              var prevSeg = void 0;
              var nextSeg = void 0;
              while (prevSeg === void 0) {
                prevNode = this.tree.prev(prevNode);
                if (prevNode === null)
                  prevSeg = null;
                else if (prevNode.key.consumedBy === void 0)
                  prevSeg = prevNode.key;
              }
              while (nextSeg === void 0) {
                nextNode = this.tree.next(nextNode);
                if (nextNode === null)
                  nextSeg = null;
                else if (nextNode.key.consumedBy === void 0)
                  nextSeg = nextNode.key;
              }
              if (event.isLeft) {
                var prevMySplitter = null;
                if (prevSeg) {
                  var prevInter = prevSeg.getIntersection(segment);
                  if (prevInter !== null) {
                    if (!segment.isAnEndpoint(prevInter))
                      prevMySplitter = prevInter;
                    if (!prevSeg.isAnEndpoint(prevInter)) {
                      var newEventsFromSplit = this._splitSafely(prevSeg, prevInter);
                      for (var i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
                        newEvents.push(newEventsFromSplit[i]);
                      }
                    }
                  }
                }
                var nextMySplitter = null;
                if (nextSeg) {
                  var nextInter = nextSeg.getIntersection(segment);
                  if (nextInter !== null) {
                    if (!segment.isAnEndpoint(nextInter))
                      nextMySplitter = nextInter;
                    if (!nextSeg.isAnEndpoint(nextInter)) {
                      var _newEventsFromSplit = this._splitSafely(nextSeg, nextInter);
                      for (var _i = 0, _iMax = _newEventsFromSplit.length; _i < _iMax; _i++) {
                        newEvents.push(_newEventsFromSplit[_i]);
                      }
                    }
                  }
                }
                if (prevMySplitter !== null || nextMySplitter !== null) {
                  var mySplitter = null;
                  if (prevMySplitter === null)
                    mySplitter = nextMySplitter;
                  else if (nextMySplitter === null)
                    mySplitter = prevMySplitter;
                  else {
                    var cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);
                    mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;
                  }
                  this.queue.remove(segment.rightSE);
                  newEvents.push(segment.rightSE);
                  var _newEventsFromSplit2 = segment.split(mySplitter);
                  for (var _i2 = 0, _iMax2 = _newEventsFromSplit2.length; _i2 < _iMax2; _i2++) {
                    newEvents.push(_newEventsFromSplit2[_i2]);
                  }
                }
                if (newEvents.length > 0) {
                  this.tree.remove(segment);
                  newEvents.push(event);
                } else {
                  this.segments.push(segment);
                  segment.prev = prevSeg;
                }
              } else {
                if (prevSeg && nextSeg) {
                  var inter = prevSeg.getIntersection(nextSeg);
                  if (inter !== null) {
                    if (!prevSeg.isAnEndpoint(inter)) {
                      var _newEventsFromSplit3 = this._splitSafely(prevSeg, inter);
                      for (var _i3 = 0, _iMax3 = _newEventsFromSplit3.length; _i3 < _iMax3; _i3++) {
                        newEvents.push(_newEventsFromSplit3[_i3]);
                      }
                    }
                    if (!nextSeg.isAnEndpoint(inter)) {
                      var _newEventsFromSplit4 = this._splitSafely(nextSeg, inter);
                      for (var _i4 = 0, _iMax4 = _newEventsFromSplit4.length; _i4 < _iMax4; _i4++) {
                        newEvents.push(_newEventsFromSplit4[_i4]);
                      }
                    }
                  }
                }
                this.tree.remove(segment);
              }
              return newEvents;
            }
          }, {
            key: "_splitSafely",
            value: function _splitSafely(seg, pt) {
              this.tree.remove(seg);
              var rightSE = seg.rightSE;
              this.queue.remove(rightSE);
              var newEvents = seg.split(pt);
              newEvents.push(rightSE);
              if (seg.consumedBy === void 0)
                this.tree.insert(seg);
              return newEvents;
            }
          }]);
          return SweepLine2;
        }();
        var POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof process !== "undefined" && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1e6;
        var POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof process !== "undefined" && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1e6;
        var Operation = /* @__PURE__ */ function() {
          function Operation2() {
            _classCallCheck(this, Operation2);
          }
          _createClass(Operation2, [{
            key: "run",
            value: function run(type, geom, moreGeoms) {
              operation.type = type;
              rounder.reset();
              var multipolys = [new MultiPolyIn(geom, true)];
              for (var i = 0, iMax = moreGeoms.length; i < iMax; i++) {
                multipolys.push(new MultiPolyIn(moreGeoms[i], false));
              }
              operation.numMultiPolys = multipolys.length;
              if (operation.type === "difference") {
                var subject = multipolys[0];
                var _i = 1;
                while (_i < multipolys.length) {
                  if (getBboxOverlap(multipolys[_i].bbox, subject.bbox) !== null)
                    _i++;
                  else
                    multipolys.splice(_i, 1);
                }
              }
              if (operation.type === "intersection") {
                for (var _i2 = 0, _iMax = multipolys.length; _i2 < _iMax; _i2++) {
                  var mpA = multipolys[_i2];
                  for (var j = _i2 + 1, jMax = multipolys.length; j < jMax; j++) {
                    if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null)
                      return [];
                  }
                }
              }
              var queue = new Tree(SweepEvent.compare);
              for (var _i3 = 0, _iMax2 = multipolys.length; _i3 < _iMax2; _i3++) {
                var sweepEvents = multipolys[_i3].getSweepEvents();
                for (var _j = 0, _jMax = sweepEvents.length; _j < _jMax; _j++) {
                  queue.insert(sweepEvents[_j]);
                  if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {
                    throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big). Please file a bug report.");
                  }
                }
              }
              var sweepLine = new SweepLine(queue);
              var prevQueueSize = queue.size;
              var node = queue.pop();
              while (node) {
                var evt = node.key;
                if (queue.size === prevQueueSize) {
                  var seg = evt.segment;
                  throw new Error("Unable to pop() ".concat(evt.isLeft ? "left" : "right", " SweepEvent ") + "[".concat(evt.point.x, ", ").concat(evt.point.y, "] from segment #").concat(seg.id, " ") + "[".concat(seg.leftSE.point.x, ", ").concat(seg.leftSE.point.y, "] -> ") + "[".concat(seg.rightSE.point.x, ", ").concat(seg.rightSE.point.y, "] from queue. ") + "Please file a bug report.");
                }
                if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {
                  throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big). Please file a bug report.");
                }
                if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {
                  throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments). Please file a bug report.");
                }
                var newEvents = sweepLine.process(evt);
                for (var _i4 = 0, _iMax3 = newEvents.length; _i4 < _iMax3; _i4++) {
                  var _evt = newEvents[_i4];
                  if (_evt.consumedBy === void 0)
                    queue.insert(_evt);
                }
                prevQueueSize = queue.size;
                node = queue.pop();
              }
              rounder.reset();
              var ringsOut = RingOut.factory(sweepLine.segments);
              var result = new MultiPolyOut(ringsOut);
              return result.getGeom();
            }
          }]);
          return Operation2;
        }();
        var operation = new Operation();
        var union = function union2(geom) {
          for (var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            moreGeoms[_key - 1] = arguments[_key];
          }
          return operation.run("union", geom, moreGeoms);
        };
        var intersection$1 = function intersection2(geom) {
          for (var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            moreGeoms[_key2 - 1] = arguments[_key2];
          }
          return operation.run("intersection", geom, moreGeoms);
        };
        var xor = function xor2(geom) {
          for (var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
            moreGeoms[_key3 - 1] = arguments[_key3];
          }
          return operation.run("xor", geom, moreGeoms);
        };
        var difference = function difference2(subjectGeom) {
          for (var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
            clippingGeoms[_key4 - 1] = arguments[_key4];
          }
          return operation.run("difference", subjectGeom, clippingGeoms);
        };
        var index = {
          union,
          intersection: intersection$1,
          xor,
          difference
        };
        return index;
      });
    }
  });

  // node_modules/turf-jsts/jsts.min.js
  var require_jsts_min = __commonJS({
    "node_modules/turf-jsts/jsts.min.js"(exports, module) {
      !function(t, e) {
        "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e(t.jsts = {});
      }(exports, function(t) {
        "use strict";
        function e() {
        }
        function n(t2) {
          this.message = t2 || "";
        }
        function i(t2) {
          this.message = t2 || "";
        }
        function r(t2) {
          this.message = t2 || "";
        }
        function o() {
        }
        function s(t2) {
          return null === t2 ? Mt : t2.color;
        }
        function a(t2) {
          return null === t2 ? null : t2.parent;
        }
        function u(t2, e3) {
          null !== t2 && (t2.color = e3);
        }
        function l(t2) {
          return null === t2 ? null : t2.left;
        }
        function c(t2) {
          return null === t2 ? null : t2.right;
        }
        function p() {
          this.root_ = null, this.size_ = 0;
        }
        function h() {
        }
        function f() {
          this.array_ = [], arguments[0] instanceof It && this.addAll(arguments[0]);
        }
        function g() {
        }
        function d(t2) {
          this.message = t2 || "";
        }
        function y2() {
          this.array_ = [];
        }
        "fill" in Array.prototype || Object.defineProperty(Array.prototype, "fill", { configurable: true, value: function(t2) {
          if (void 0 === this || null === this)
            throw new TypeError(this + " is not an object");
          var e3 = Object(this), n2 = Math.max(Math.min(e3.length, 9007199254740991), 0) || 0, i2 = 1 in arguments ? parseInt(Number(arguments[1]), 10) || 0 : 0;
          i2 = i2 < 0 ? Math.max(n2 + i2, 0) : Math.min(i2, n2);
          var r2 = 2 in arguments && void 0 !== arguments[2] ? parseInt(Number(arguments[2]), 10) || 0 : n2;
          for (r2 = r2 < 0 ? Math.max(n2 + arguments[2], 0) : Math.min(r2, n2); i2 < r2; )
            e3[i2] = t2, ++i2;
          return e3;
        }, writable: true }), Number.isFinite = Number.isFinite || function(t2) {
          return "number" == typeof t2 && isFinite(t2);
        }, Number.isInteger = Number.isInteger || function(t2) {
          return "number" == typeof t2 && isFinite(t2) && Math.floor(t2) === t2;
        }, Number.parseFloat = Number.parseFloat || parseFloat, Number.isNaN = Number.isNaN || function(t2) {
          return t2 != t2;
        }, Math.trunc = Math.trunc || function(t2) {
          return t2 < 0 ? Math.ceil(t2) : Math.floor(t2);
        };
        var _ = function() {
        };
        _.prototype.interfaces_ = function() {
          return [];
        }, _.prototype.getClass = function() {
          return _;
        }, _.prototype.equalsWithTolerance = function(t2, e3, n2) {
          return Math.abs(t2 - e3) <= n2;
        };
        var m = function(t2) {
          function e3(e4) {
            t2.call(this, e4), this.name = "IllegalArgumentException", this.message = e4, this.stack = new t2().stack;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3;
        }(Error), v = function() {
        }, I = { MAX_VALUE: { configurable: true } };
        v.isNaN = function(t2) {
          return Number.isNaN(t2);
        }, v.doubleToLongBits = function(t2) {
          return t2;
        }, v.longBitsToDouble = function(t2) {
          return t2;
        }, v.isInfinite = function(t2) {
          return !Number.isFinite(t2);
        }, I.MAX_VALUE.get = function() {
          return Number.MAX_VALUE;
        }, Object.defineProperties(v, I);
        var E = function() {
        }, x2 = function() {
        }, N = function() {
        }, C = function t2() {
          if (this.x = null, this.y = null, this.z = null, 0 === arguments.length)
            this.x = 0, this.y = 0, this.z = t2.NULL_ORDINATE;
          else if (1 === arguments.length) {
            var e3 = arguments[0];
            this.x = e3.x, this.y = e3.y, this.z = e3.z;
          } else
            2 === arguments.length ? (this.x = arguments[0], this.y = arguments[1], this.z = t2.NULL_ORDINATE) : 3 === arguments.length && (this.x = arguments[0], this.y = arguments[1], this.z = arguments[2]);
        }, S = { DimensionalComparator: { configurable: true }, serialVersionUID: { configurable: true }, NULL_ORDINATE: { configurable: true }, X: { configurable: true }, Y: { configurable: true }, Z: { configurable: true } };
        C.prototype.setOrdinate = function(t2, e3) {
          switch (t2) {
            case C.X:
              this.x = e3;
              break;
            case C.Y:
              this.y = e3;
              break;
            case C.Z:
              this.z = e3;
              break;
            default:
              throw new m("Invalid ordinate index: " + t2);
          }
        }, C.prototype.equals2D = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return this.x === t2.x && this.y === t2.y;
          }
          if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            return !!_.equalsWithTolerance(this.x, e3.x, n2) && !!_.equalsWithTolerance(this.y, e3.y, n2);
          }
        }, C.prototype.getOrdinate = function(t2) {
          switch (t2) {
            case C.X:
              return this.x;
            case C.Y:
              return this.y;
            case C.Z:
              return this.z;
          }
          throw new m("Invalid ordinate index: " + t2);
        }, C.prototype.equals3D = function(t2) {
          return this.x === t2.x && this.y === t2.y && (this.z === t2.z || v.isNaN(this.z)) && v.isNaN(t2.z);
        }, C.prototype.equals = function(t2) {
          return t2 instanceof C && this.equals2D(t2);
        }, C.prototype.equalInZ = function(t2, e3) {
          return _.equalsWithTolerance(this.z, t2.z, e3);
        }, C.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this.x < e3.x ? -1 : this.x > e3.x ? 1 : this.y < e3.y ? -1 : this.y > e3.y ? 1 : 0;
        }, C.prototype.clone = function() {
        }, C.prototype.copy = function() {
          return new C(this);
        }, C.prototype.toString = function() {
          return "(" + this.x + ", " + this.y + ", " + this.z + ")";
        }, C.prototype.distance3D = function(t2) {
          var e3 = this.x - t2.x, n2 = this.y - t2.y, i2 = this.z - t2.z;
          return Math.sqrt(e3 * e3 + n2 * n2 + i2 * i2);
        }, C.prototype.distance = function(t2) {
          var e3 = this.x - t2.x, n2 = this.y - t2.y;
          return Math.sqrt(e3 * e3 + n2 * n2);
        }, C.prototype.hashCode = function() {
          var t2 = 17;
          return t2 = 37 * t2 + C.hashCode(this.x), t2 = 37 * t2 + C.hashCode(this.y);
        }, C.prototype.setCoordinate = function(t2) {
          this.x = t2.x, this.y = t2.y, this.z = t2.z;
        }, C.prototype.interfaces_ = function() {
          return [E, x2, e];
        }, C.prototype.getClass = function() {
          return C;
        }, C.hashCode = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0], e3 = v.doubleToLongBits(t2);
            return Math.trunc((e3 ^ e3) >>> 32);
          }
        }, S.DimensionalComparator.get = function() {
          return L;
        }, S.serialVersionUID.get = function() {
          return 6683108902428367e3;
        }, S.NULL_ORDINATE.get = function() {
          return v.NaN;
        }, S.X.get = function() {
          return 0;
        }, S.Y.get = function() {
          return 1;
        }, S.Z.get = function() {
          return 2;
        }, Object.defineProperties(C, S);
        var L = function(t2) {
          if (this._dimensionsToTest = 2, 0 === arguments.length)
            ;
          else if (1 === arguments.length) {
            var e3 = arguments[0];
            if (2 !== e3 && 3 !== e3)
              throw new m("only 2 or 3 dimensions may be specified");
            this._dimensionsToTest = e3;
          }
        };
        L.prototype.compare = function(t2, e3) {
          var n2 = t2, i2 = e3, r2 = L.compare(n2.x, i2.x);
          if (0 !== r2)
            return r2;
          var o2 = L.compare(n2.y, i2.y);
          if (0 !== o2)
            return o2;
          if (this._dimensionsToTest <= 2)
            return 0;
          return L.compare(n2.z, i2.z);
        }, L.prototype.interfaces_ = function() {
          return [N];
        }, L.prototype.getClass = function() {
          return L;
        }, L.compare = function(t2, e3) {
          return t2 < e3 ? -1 : t2 > e3 ? 1 : v.isNaN(t2) ? v.isNaN(e3) ? 0 : -1 : v.isNaN(e3) ? 1 : 0;
        };
        var b = function() {
        };
        b.prototype.create = function() {
        }, b.prototype.interfaces_ = function() {
          return [];
        }, b.prototype.getClass = function() {
          return b;
        };
        var w = function() {
        }, O2 = { INTERIOR: { configurable: true }, BOUNDARY: { configurable: true }, EXTERIOR: { configurable: true }, NONE: { configurable: true } };
        w.prototype.interfaces_ = function() {
          return [];
        }, w.prototype.getClass = function() {
          return w;
        }, w.toLocationSymbol = function(t2) {
          switch (t2) {
            case w.EXTERIOR:
              return "e";
            case w.BOUNDARY:
              return "b";
            case w.INTERIOR:
              return "i";
            case w.NONE:
              return "-";
          }
          throw new m("Unknown location value: " + t2);
        }, O2.INTERIOR.get = function() {
          return 0;
        }, O2.BOUNDARY.get = function() {
          return 1;
        }, O2.EXTERIOR.get = function() {
          return 2;
        }, O2.NONE.get = function() {
          return -1;
        }, Object.defineProperties(w, O2);
        var T = function(t2, e3) {
          return t2.interfaces_ && t2.interfaces_().indexOf(e3) > -1;
        }, R = function() {
        }, P = { LOG_10: { configurable: true } };
        R.prototype.interfaces_ = function() {
          return [];
        }, R.prototype.getClass = function() {
          return R;
        }, R.log10 = function(t2) {
          var e3 = Math.log(t2);
          return v.isInfinite(e3) ? e3 : v.isNaN(e3) ? e3 : e3 / R.LOG_10;
        }, R.min = function(t2, e3, n2, i2) {
          var r2 = t2;
          return e3 < r2 && (r2 = e3), n2 < r2 && (r2 = n2), i2 < r2 && (r2 = i2), r2;
        }, R.clamp = function() {
          if ("number" == typeof arguments[2] && "number" == typeof arguments[0] && "number" == typeof arguments[1]) {
            var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
            return t2 < e3 ? e3 : t2 > n2 ? n2 : t2;
          }
          if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
            var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2];
            return i2 < r2 ? r2 : i2 > o2 ? o2 : i2;
          }
        }, R.wrap = function(t2, e3) {
          return t2 < 0 ? e3 - -t2 % e3 : t2 % e3;
        }, R.max = function() {
          if (3 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2], i2 = t2;
            return e3 > i2 && (i2 = e3), n2 > i2 && (i2 = n2), i2;
          }
          if (4 === arguments.length) {
            var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2], a2 = arguments[3], u2 = r2;
            return o2 > u2 && (u2 = o2), s2 > u2 && (u2 = s2), a2 > u2 && (u2 = a2), u2;
          }
        }, R.average = function(t2, e3) {
          return (t2 + e3) / 2;
        }, P.LOG_10.get = function() {
          return Math.log(10);
        }, Object.defineProperties(R, P);
        var D = function(t2) {
          this.str = t2;
        };
        D.prototype.append = function(t2) {
          this.str += t2;
        }, D.prototype.setCharAt = function(t2, e3) {
          this.str = this.str.substr(0, t2) + e3 + this.str.substr(t2 + 1);
        }, D.prototype.toString = function(t2) {
          return this.str;
        };
        var M = function(t2) {
          this.value = t2;
        };
        M.prototype.intValue = function() {
          return this.value;
        }, M.prototype.compareTo = function(t2) {
          return this.value < t2 ? -1 : this.value > t2 ? 1 : 0;
        }, M.isNaN = function(t2) {
          return Number.isNaN(t2);
        };
        var A = function() {
        };
        A.isWhitespace = function(t2) {
          return t2 <= 32 && t2 >= 0 || 127 === t2;
        }, A.toUpperCase = function(t2) {
          return t2.toUpperCase();
        };
        var F = function t2() {
          if (this._hi = 0, this._lo = 0, 0 === arguments.length)
            this.init(0);
          else if (1 === arguments.length) {
            if ("number" == typeof arguments[0]) {
              var e3 = arguments[0];
              this.init(e3);
            } else if (arguments[0] instanceof t2) {
              var n2 = arguments[0];
              this.init(n2);
            } else if ("string" == typeof arguments[0]) {
              var i2 = arguments[0];
              t2.call(this, t2.parse(i2));
            }
          } else if (2 === arguments.length) {
            var r2 = arguments[0], o2 = arguments[1];
            this.init(r2, o2);
          }
        }, G = { PI: { configurable: true }, TWO_PI: { configurable: true }, PI_2: { configurable: true }, E: { configurable: true }, NaN: { configurable: true }, EPS: { configurable: true }, SPLIT: { configurable: true }, MAX_PRINT_DIGITS: { configurable: true }, TEN: { configurable: true }, ONE: { configurable: true }, SCI_NOT_EXPONENT_CHAR: { configurable: true }, SCI_NOT_ZERO: { configurable: true } };
        F.prototype.le = function(t2) {
          return (this._hi < t2._hi || this._hi === t2._hi) && this._lo <= t2._lo;
        }, F.prototype.extractSignificantDigits = function(t2, e3) {
          var n2 = this.abs(), i2 = F.magnitude(n2._hi), r2 = F.TEN.pow(i2);
          (n2 = n2.divide(r2)).gt(F.TEN) ? (n2 = n2.divide(F.TEN), i2 += 1) : n2.lt(F.ONE) && (n2 = n2.multiply(F.TEN), i2 -= 1);
          for (var o2 = i2 + 1, s2 = new D(), a2 = F.MAX_PRINT_DIGITS - 1, u2 = 0; u2 <= a2; u2++) {
            t2 && u2 === o2 && s2.append(".");
            var l2 = Math.trunc(n2._hi);
            if (l2 < 0)
              break;
            var c2 = false, p2 = 0;
            l2 > 9 ? (c2 = true, p2 = "9") : p2 = "0" + l2, s2.append(p2), n2 = n2.subtract(F.valueOf(l2)).multiply(F.TEN), c2 && n2.selfAdd(F.TEN);
            var h2 = true, f2 = F.magnitude(n2._hi);
            if (f2 < 0 && Math.abs(f2) >= a2 - u2 && (h2 = false), !h2)
              break;
          }
          return e3[0] = i2, s2.toString();
        }, F.prototype.sqr = function() {
          return this.multiply(this);
        }, F.prototype.doubleValue = function() {
          return this._hi + this._lo;
        }, F.prototype.subtract = function() {
          if (arguments[0] instanceof F) {
            var t2 = arguments[0];
            return this.add(t2.negate());
          }
          if ("number" == typeof arguments[0]) {
            var e3 = arguments[0];
            return this.add(-e3);
          }
        }, F.prototype.equals = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return this._hi === t2._hi && this._lo === t2._lo;
          }
        }, F.prototype.isZero = function() {
          return 0 === this._hi && 0 === this._lo;
        }, F.prototype.selfSubtract = function() {
          if (arguments[0] instanceof F) {
            var t2 = arguments[0];
            return this.isNaN() ? this : this.selfAdd(-t2._hi, -t2._lo);
          }
          if ("number" == typeof arguments[0]) {
            var e3 = arguments[0];
            return this.isNaN() ? this : this.selfAdd(-e3, 0);
          }
        }, F.prototype.getSpecialNumberString = function() {
          return this.isZero() ? "0.0" : this.isNaN() ? "NaN " : null;
        }, F.prototype.min = function(t2) {
          return this.le(t2) ? this : t2;
        }, F.prototype.selfDivide = function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof F) {
              var t2 = arguments[0];
              return this.selfDivide(t2._hi, t2._lo);
            }
            if ("number" == typeof arguments[0]) {
              var e3 = arguments[0];
              return this.selfDivide(e3, 0);
            }
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = null, o2 = null, s2 = null, a2 = null, u2 = null, l2 = null, c2 = null, p2 = null;
            return u2 = this._hi / n2, l2 = F.SPLIT * u2, r2 = l2 - u2, p2 = F.SPLIT * n2, r2 = l2 - r2, o2 = u2 - r2, s2 = p2 - n2, c2 = u2 * n2, s2 = p2 - s2, a2 = n2 - s2, p2 = r2 * s2 - c2 + r2 * a2 + o2 * s2 + o2 * a2, l2 = (this._hi - c2 - p2 + this._lo - u2 * i2) / n2, p2 = u2 + l2, this._hi = p2, this._lo = u2 - p2 + l2, this;
          }
        }, F.prototype.dump = function() {
          return "DD<" + this._hi + ", " + this._lo + ">";
        }, F.prototype.divide = function() {
          if (arguments[0] instanceof F) {
            var t2 = arguments[0], e3 = null, n2 = null, i2 = null, r2 = null, o2 = null, s2 = null, a2 = null, u2 = null;
            n2 = (o2 = this._hi / t2._hi) - (e3 = (s2 = F.SPLIT * o2) - (e3 = s2 - o2)), u2 = e3 * (i2 = (u2 = F.SPLIT * t2._hi) - (i2 = u2 - t2._hi)) - (a2 = o2 * t2._hi) + e3 * (r2 = t2._hi - i2) + n2 * i2 + n2 * r2, s2 = (this._hi - a2 - u2 + this._lo - o2 * t2._lo) / t2._hi;
            return new F(u2 = o2 + s2, o2 - u2 + s2);
          }
          if ("number" == typeof arguments[0]) {
            var l2 = arguments[0];
            return v.isNaN(l2) ? F.createNaN() : F.copy(this).selfDivide(l2, 0);
          }
        }, F.prototype.ge = function(t2) {
          return (this._hi > t2._hi || this._hi === t2._hi) && this._lo >= t2._lo;
        }, F.prototype.pow = function(t2) {
          if (0 === t2)
            return F.valueOf(1);
          var e3 = new F(this), n2 = F.valueOf(1), i2 = Math.abs(t2);
          if (i2 > 1)
            for (; i2 > 0; )
              i2 % 2 == 1 && n2.selfMultiply(e3), (i2 /= 2) > 0 && (e3 = e3.sqr());
          else
            n2 = e3;
          return t2 < 0 ? n2.reciprocal() : n2;
        }, F.prototype.ceil = function() {
          if (this.isNaN())
            return F.NaN;
          var t2 = Math.ceil(this._hi), e3 = 0;
          return t2 === this._hi && (e3 = Math.ceil(this._lo)), new F(t2, e3);
        }, F.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this._hi < e3._hi ? -1 : this._hi > e3._hi ? 1 : this._lo < e3._lo ? -1 : this._lo > e3._lo ? 1 : 0;
        }, F.prototype.rint = function() {
          if (this.isNaN())
            return this;
          return this.add(0.5).floor();
        }, F.prototype.setValue = function() {
          if (arguments[0] instanceof F) {
            var t2 = arguments[0];
            return this.init(t2), this;
          }
          if ("number" == typeof arguments[0]) {
            var e3 = arguments[0];
            return this.init(e3), this;
          }
        }, F.prototype.max = function(t2) {
          return this.ge(t2) ? this : t2;
        }, F.prototype.sqrt = function() {
          if (this.isZero())
            return F.valueOf(0);
          if (this.isNegative())
            return F.NaN;
          var t2 = 1 / Math.sqrt(this._hi), e3 = this._hi * t2, n2 = F.valueOf(e3), i2 = this.subtract(n2.sqr())._hi * (0.5 * t2);
          return n2.add(i2);
        }, F.prototype.selfAdd = function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof F) {
              var t2 = arguments[0];
              return this.selfAdd(t2._hi, t2._lo);
            }
            if ("number" == typeof arguments[0]) {
              var e3 = arguments[0], n2 = null, i2 = null, r2 = null, o2 = null, s2 = null, a2 = null;
              return r2 = this._hi + e3, s2 = r2 - this._hi, o2 = r2 - s2, o2 = e3 - s2 + (this._hi - o2), a2 = o2 + this._lo, n2 = r2 + a2, i2 = a2 + (r2 - n2), this._hi = n2 + i2, this._lo = i2 + (n2 - this._hi), this;
            }
          } else if (2 === arguments.length) {
            var u2 = arguments[0], l2 = arguments[1], c2 = null, p2 = null, h2 = null, f2 = null, g2 = null, d2 = null, y3 = null;
            f2 = this._hi + u2, p2 = this._lo + l2, g2 = f2 - (d2 = f2 - this._hi), h2 = p2 - (y3 = p2 - this._lo);
            var _2 = (c2 = f2 + (d2 = (g2 = u2 - d2 + (this._hi - g2)) + p2)) + (d2 = (h2 = l2 - y3 + (this._lo - h2)) + (d2 + (f2 - c2))), m2 = d2 + (c2 - _2);
            return this._hi = _2, this._lo = m2, this;
          }
        }, F.prototype.selfMultiply = function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof F) {
              var t2 = arguments[0];
              return this.selfMultiply(t2._hi, t2._lo);
            }
            if ("number" == typeof arguments[0]) {
              var e3 = arguments[0];
              return this.selfMultiply(e3, 0);
            }
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = null, o2 = null, s2 = null, a2 = null, u2 = null, l2 = null;
            r2 = (u2 = F.SPLIT * this._hi) - this._hi, l2 = F.SPLIT * n2, r2 = u2 - r2, o2 = this._hi - r2, s2 = l2 - n2;
            var c2 = (u2 = this._hi * n2) + (l2 = r2 * (s2 = l2 - s2) - u2 + r2 * (a2 = n2 - s2) + o2 * s2 + o2 * a2 + (this._hi * i2 + this._lo * n2)), p2 = l2 + (r2 = u2 - c2);
            return this._hi = c2, this._lo = p2, this;
          }
        }, F.prototype.selfSqr = function() {
          return this.selfMultiply(this);
        }, F.prototype.floor = function() {
          if (this.isNaN())
            return F.NaN;
          var t2 = Math.floor(this._hi), e3 = 0;
          return t2 === this._hi && (e3 = Math.floor(this._lo)), new F(t2, e3);
        }, F.prototype.negate = function() {
          return this.isNaN() ? this : new F(-this._hi, -this._lo);
        }, F.prototype.clone = function() {
        }, F.prototype.multiply = function() {
          if (arguments[0] instanceof F) {
            var t2 = arguments[0];
            return t2.isNaN() ? F.createNaN() : F.copy(this).selfMultiply(t2);
          }
          if ("number" == typeof arguments[0]) {
            var e3 = arguments[0];
            return v.isNaN(e3) ? F.createNaN() : F.copy(this).selfMultiply(e3, 0);
          }
        }, F.prototype.isNaN = function() {
          return v.isNaN(this._hi);
        }, F.prototype.intValue = function() {
          return Math.trunc(this._hi);
        }, F.prototype.toString = function() {
          var t2 = F.magnitude(this._hi);
          return t2 >= -3 && t2 <= 20 ? this.toStandardNotation() : this.toSciNotation();
        }, F.prototype.toStandardNotation = function() {
          var t2 = this.getSpecialNumberString();
          if (null !== t2)
            return t2;
          var e3 = new Array(1).fill(null), n2 = this.extractSignificantDigits(true, e3), i2 = e3[0] + 1, r2 = n2;
          if ("." === n2.charAt(0))
            r2 = "0" + n2;
          else if (i2 < 0)
            r2 = "0." + F.stringOfChar("0", -i2) + n2;
          else if (-1 === n2.indexOf(".")) {
            var o2 = i2 - n2.length;
            r2 = n2 + F.stringOfChar("0", o2) + ".0";
          }
          return this.isNegative() ? "-" + r2 : r2;
        }, F.prototype.reciprocal = function() {
          var t2 = null, e3 = null, n2 = null, i2 = null, r2 = null, o2 = null, s2 = null, a2 = null;
          e3 = (r2 = 1 / this._hi) - (t2 = (o2 = F.SPLIT * r2) - (t2 = o2 - r2)), n2 = (a2 = F.SPLIT * this._hi) - this._hi;
          var u2 = r2 + (o2 = (1 - (s2 = r2 * this._hi) - (a2 = t2 * (n2 = a2 - n2) - s2 + t2 * (i2 = this._hi - n2) + e3 * n2 + e3 * i2) - r2 * this._lo) / this._hi);
          return new F(u2, r2 - u2 + o2);
        }, F.prototype.toSciNotation = function() {
          if (this.isZero())
            return F.SCI_NOT_ZERO;
          var t2 = this.getSpecialNumberString();
          if (null !== t2)
            return t2;
          var e3 = new Array(1).fill(null), n2 = this.extractSignificantDigits(false, e3), i2 = F.SCI_NOT_EXPONENT_CHAR + e3[0];
          if ("0" === n2.charAt(0))
            throw new Error("Found leading zero: " + n2);
          var r2 = "";
          n2.length > 1 && (r2 = n2.substring(1));
          var o2 = n2.charAt(0) + "." + r2;
          return this.isNegative() ? "-" + o2 + i2 : o2 + i2;
        }, F.prototype.abs = function() {
          return this.isNaN() ? F.NaN : this.isNegative() ? this.negate() : new F(this);
        }, F.prototype.isPositive = function() {
          return (this._hi > 0 || 0 === this._hi) && this._lo > 0;
        }, F.prototype.lt = function(t2) {
          return (this._hi < t2._hi || this._hi === t2._hi) && this._lo < t2._lo;
        }, F.prototype.add = function() {
          if (arguments[0] instanceof F) {
            var t2 = arguments[0];
            return F.copy(this).selfAdd(t2);
          }
          if ("number" == typeof arguments[0]) {
            var e3 = arguments[0];
            return F.copy(this).selfAdd(e3);
          }
        }, F.prototype.init = function() {
          if (1 === arguments.length) {
            if ("number" == typeof arguments[0]) {
              var t2 = arguments[0];
              this._hi = t2, this._lo = 0;
            } else if (arguments[0] instanceof F) {
              var e3 = arguments[0];
              this._hi = e3._hi, this._lo = e3._lo;
            }
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            this._hi = n2, this._lo = i2;
          }
        }, F.prototype.gt = function(t2) {
          return (this._hi > t2._hi || this._hi === t2._hi) && this._lo > t2._lo;
        }, F.prototype.isNegative = function() {
          return (this._hi < 0 || 0 === this._hi) && this._lo < 0;
        }, F.prototype.trunc = function() {
          return this.isNaN() ? F.NaN : this.isPositive() ? this.floor() : this.ceil();
        }, F.prototype.signum = function() {
          return this._hi > 0 ? 1 : this._hi < 0 ? -1 : this._lo > 0 ? 1 : this._lo < 0 ? -1 : 0;
        }, F.prototype.interfaces_ = function() {
          return [e, E, x2];
        }, F.prototype.getClass = function() {
          return F;
        }, F.sqr = function(t2) {
          return F.valueOf(t2).selfMultiply(t2);
        }, F.valueOf = function() {
          if ("string" == typeof arguments[0]) {
            var t2 = arguments[0];
            return F.parse(t2);
          }
          if ("number" == typeof arguments[0]) {
            var e3 = arguments[0];
            return new F(e3);
          }
        }, F.sqrt = function(t2) {
          return F.valueOf(t2).sqrt();
        }, F.parse = function(t2) {
          for (var e3 = 0, n2 = t2.length; A.isWhitespace(t2.charAt(e3)); )
            e3++;
          var i2 = false;
          if (e3 < n2) {
            var r2 = t2.charAt(e3);
            "-" !== r2 && "+" !== r2 || (e3++, "-" === r2 && (i2 = true));
          }
          for (var o2 = new F(), s2 = 0, a2 = 0, u2 = 0; !(e3 >= n2); ) {
            var l2 = t2.charAt(e3);
            if (e3++, A.isDigit(l2)) {
              var c2 = l2 - "0";
              o2.selfMultiply(F.TEN), o2.selfAdd(c2), s2++;
            } else {
              if ("." !== l2) {
                if ("e" === l2 || "E" === l2) {
                  var p2 = t2.substring(e3);
                  try {
                    u2 = M.parseInt(p2);
                  } catch (e4) {
                    throw e4 instanceof Error ? new Error("Invalid exponent " + p2 + " in string " + t2) : e4;
                  }
                  break;
                }
                throw new Error("Unexpected character '" + l2 + "' at position " + e3 + " in string " + t2);
              }
              a2 = s2;
            }
          }
          var h2 = o2, f2 = s2 - a2 - u2;
          if (0 === f2)
            h2 = o2;
          else if (f2 > 0) {
            var g2 = F.TEN.pow(f2);
            h2 = o2.divide(g2);
          } else if (f2 < 0) {
            var d2 = F.TEN.pow(-f2);
            h2 = o2.multiply(d2);
          }
          return i2 ? h2.negate() : h2;
        }, F.createNaN = function() {
          return new F(v.NaN, v.NaN);
        }, F.copy = function(t2) {
          return new F(t2);
        }, F.magnitude = function(t2) {
          var e3 = Math.abs(t2), n2 = Math.log(e3) / Math.log(10), i2 = Math.trunc(Math.floor(n2));
          return 10 * Math.pow(10, i2) <= e3 && (i2 += 1), i2;
        }, F.stringOfChar = function(t2, e3) {
          for (var n2 = new D(), i2 = 0; i2 < e3; i2++)
            n2.append(t2);
          return n2.toString();
        }, G.PI.get = function() {
          return new F(3.141592653589793, 12246467991473532e-32);
        }, G.TWO_PI.get = function() {
          return new F(6.283185307179586, 24492935982947064e-32);
        }, G.PI_2.get = function() {
          return new F(1.5707963267948966, 6123233995736766e-32);
        }, G.E.get = function() {
          return new F(2.718281828459045, 14456468917292502e-32);
        }, G.NaN.get = function() {
          return new F(v.NaN, v.NaN);
        }, G.EPS.get = function() {
          return 123259516440783e-46;
        }, G.SPLIT.get = function() {
          return 134217729;
        }, G.MAX_PRINT_DIGITS.get = function() {
          return 32;
        }, G.TEN.get = function() {
          return F.valueOf(10);
        }, G.ONE.get = function() {
          return F.valueOf(1);
        }, G.SCI_NOT_EXPONENT_CHAR.get = function() {
          return "E";
        }, G.SCI_NOT_ZERO.get = function() {
          return "0.0E0";
        }, Object.defineProperties(F, G);
        var q = function() {
        }, B2 = { DP_SAFE_EPSILON: { configurable: true } };
        q.prototype.interfaces_ = function() {
          return [];
        }, q.prototype.getClass = function() {
          return q;
        }, q.orientationIndex = function(t2, e3, n2) {
          var i2 = q.orientationIndexFilter(t2, e3, n2);
          if (i2 <= 1)
            return i2;
          var r2 = F.valueOf(e3.x).selfAdd(-t2.x), o2 = F.valueOf(e3.y).selfAdd(-t2.y), s2 = F.valueOf(n2.x).selfAdd(-e3.x), a2 = F.valueOf(n2.y).selfAdd(-e3.y);
          return r2.selfMultiply(a2).selfSubtract(o2.selfMultiply(s2)).signum();
        }, q.signOfDet2x2 = function(t2, e3, n2, i2) {
          return t2.multiply(i2).selfSubtract(e3.multiply(n2)).signum();
        }, q.intersection = function(t2, e3, n2, i2) {
          var r2 = F.valueOf(i2.y).selfSubtract(n2.y).selfMultiply(F.valueOf(e3.x).selfSubtract(t2.x)), o2 = F.valueOf(i2.x).selfSubtract(n2.x).selfMultiply(F.valueOf(e3.y).selfSubtract(t2.y)), s2 = r2.subtract(o2), a2 = F.valueOf(i2.x).selfSubtract(n2.x).selfMultiply(F.valueOf(t2.y).selfSubtract(n2.y)), u2 = F.valueOf(i2.y).selfSubtract(n2.y).selfMultiply(F.valueOf(t2.x).selfSubtract(n2.x)), l2 = a2.subtract(u2).selfDivide(s2).doubleValue(), c2 = F.valueOf(t2.x).selfAdd(F.valueOf(e3.x).selfSubtract(t2.x).selfMultiply(l2)).doubleValue(), p2 = F.valueOf(e3.x).selfSubtract(t2.x).selfMultiply(F.valueOf(t2.y).selfSubtract(n2.y)), h2 = F.valueOf(e3.y).selfSubtract(t2.y).selfMultiply(F.valueOf(t2.x).selfSubtract(n2.x)), f2 = p2.subtract(h2).selfDivide(s2).doubleValue(), g2 = F.valueOf(n2.y).selfAdd(F.valueOf(i2.y).selfSubtract(n2.y).selfMultiply(f2)).doubleValue();
          return new C(c2, g2);
        }, q.orientationIndexFilter = function(t2, e3, n2) {
          var i2 = null, r2 = (t2.x - n2.x) * (e3.y - n2.y), o2 = (t2.y - n2.y) * (e3.x - n2.x), s2 = r2 - o2;
          if (r2 > 0) {
            if (o2 <= 0)
              return q.signum(s2);
            i2 = r2 + o2;
          } else {
            if (!(r2 < 0))
              return q.signum(s2);
            if (o2 >= 0)
              return q.signum(s2);
            i2 = -r2 - o2;
          }
          var a2 = q.DP_SAFE_EPSILON * i2;
          return s2 >= a2 || -s2 >= a2 ? q.signum(s2) : 2;
        }, q.signum = function(t2) {
          return t2 > 0 ? 1 : t2 < 0 ? -1 : 0;
        }, B2.DP_SAFE_EPSILON.get = function() {
          return 1e-15;
        }, Object.defineProperties(q, B2);
        var V = function() {
        }, U = { X: { configurable: true }, Y: { configurable: true }, Z: { configurable: true }, M: { configurable: true } };
        U.X.get = function() {
          return 0;
        }, U.Y.get = function() {
          return 1;
        }, U.Z.get = function() {
          return 2;
        }, U.M.get = function() {
          return 3;
        }, V.prototype.setOrdinate = function(t2, e3, n2) {
        }, V.prototype.size = function() {
        }, V.prototype.getOrdinate = function(t2, e3) {
        }, V.prototype.getCoordinate = function() {
        }, V.prototype.getCoordinateCopy = function(t2) {
        }, V.prototype.getDimension = function() {
        }, V.prototype.getX = function(t2) {
        }, V.prototype.clone = function() {
        }, V.prototype.expandEnvelope = function(t2) {
        }, V.prototype.copy = function() {
        }, V.prototype.getY = function(t2) {
        }, V.prototype.toCoordinateArray = function() {
        }, V.prototype.interfaces_ = function() {
          return [x2];
        }, V.prototype.getClass = function() {
          return V;
        }, Object.defineProperties(V, U);
        var z = function() {
        }, X = function(t2) {
          function e3() {
            t2.call(this, "Projective point not representable on the Cartesian plane.");
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(z), Y = function() {
        };
        Y.arraycopy = function(t2, e3, n2, i2, r2) {
          for (var o2 = 0, s2 = e3; s2 < e3 + r2; s2++)
            n2[i2 + o2] = t2[s2], o2++;
        }, Y.getProperty = function(t2) {
          return { "line.separator": "\n" }[t2];
        };
        var k = function t2() {
          if (this.x = null, this.y = null, this.w = null, 0 === arguments.length)
            this.x = 0, this.y = 0, this.w = 1;
          else if (1 === arguments.length) {
            var e3 = arguments[0];
            this.x = e3.x, this.y = e3.y, this.w = 1;
          } else if (2 === arguments.length) {
            if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
              var n2 = arguments[0], i2 = arguments[1];
              this.x = n2, this.y = i2, this.w = 1;
            } else if (arguments[0] instanceof t2 && arguments[1] instanceof t2) {
              var r2 = arguments[0], o2 = arguments[1];
              this.x = r2.y * o2.w - o2.y * r2.w, this.y = o2.x * r2.w - r2.x * o2.w, this.w = r2.x * o2.y - o2.x * r2.y;
            } else if (arguments[0] instanceof C && arguments[1] instanceof C) {
              var s2 = arguments[0], a2 = arguments[1];
              this.x = s2.y - a2.y, this.y = a2.x - s2.x, this.w = s2.x * a2.y - a2.x * s2.y;
            }
          } else if (3 === arguments.length) {
            var u2 = arguments[0], l2 = arguments[1], c2 = arguments[2];
            this.x = u2, this.y = l2, this.w = c2;
          } else if (4 === arguments.length) {
            var p2 = arguments[0], h2 = arguments[1], f2 = arguments[2], g2 = arguments[3], d2 = p2.y - h2.y, y3 = h2.x - p2.x, _2 = p2.x * h2.y - h2.x * p2.y, m2 = f2.y - g2.y, v2 = g2.x - f2.x, I2 = f2.x * g2.y - g2.x * f2.y;
            this.x = y3 * I2 - v2 * _2, this.y = m2 * _2 - d2 * I2, this.w = d2 * v2 - m2 * y3;
          }
        };
        k.prototype.getY = function() {
          var t2 = this.y / this.w;
          if (v.isNaN(t2) || v.isInfinite(t2))
            throw new X();
          return t2;
        }, k.prototype.getX = function() {
          var t2 = this.x / this.w;
          if (v.isNaN(t2) || v.isInfinite(t2))
            throw new X();
          return t2;
        }, k.prototype.getCoordinate = function() {
          var t2 = new C();
          return t2.x = this.getX(), t2.y = this.getY(), t2;
        }, k.prototype.interfaces_ = function() {
          return [];
        }, k.prototype.getClass = function() {
          return k;
        }, k.intersection = function(t2, e3, n2, i2) {
          var r2 = t2.y - e3.y, o2 = e3.x - t2.x, s2 = t2.x * e3.y - e3.x * t2.y, a2 = n2.y - i2.y, u2 = i2.x - n2.x, l2 = n2.x * i2.y - i2.x * n2.y, c2 = r2 * u2 - a2 * o2, p2 = (o2 * l2 - u2 * s2) / c2, h2 = (a2 * s2 - r2 * l2) / c2;
          if (v.isNaN(p2) || v.isInfinite(p2) || v.isNaN(h2) || v.isInfinite(h2))
            throw new X();
          return new C(p2, h2);
        };
        var j = function t2() {
          if (this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, 0 === arguments.length)
            this.init();
          else if (1 === arguments.length) {
            if (arguments[0] instanceof C) {
              var e3 = arguments[0];
              this.init(e3.x, e3.x, e3.y, e3.y);
            } else if (arguments[0] instanceof t2) {
              var n2 = arguments[0];
              this.init(n2);
            }
          } else if (2 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1];
            this.init(i2.x, r2.x, i2.y, r2.y);
          } else if (4 === arguments.length) {
            var o2 = arguments[0], s2 = arguments[1], a2 = arguments[2], u2 = arguments[3];
            this.init(o2, s2, a2, u2);
          }
        }, H = { serialVersionUID: { configurable: true } };
        j.prototype.getArea = function() {
          return this.getWidth() * this.getHeight();
        }, j.prototype.equals = function(t2) {
          if (!(t2 instanceof j))
            return false;
          var e3 = t2;
          return this.isNull() ? e3.isNull() : this._maxx === e3.getMaxX() && this._maxy === e3.getMaxY() && this._minx === e3.getMinX() && this._miny === e3.getMinY();
        }, j.prototype.intersection = function(t2) {
          if (this.isNull() || t2.isNull() || !this.intersects(t2))
            return new j();
          var e3 = this._minx > t2._minx ? this._minx : t2._minx, n2 = this._miny > t2._miny ? this._miny : t2._miny, i2 = this._maxx < t2._maxx ? this._maxx : t2._maxx, r2 = this._maxy < t2._maxy ? this._maxy : t2._maxy;
          return new j(e3, i2, n2, r2);
        }, j.prototype.isNull = function() {
          return this._maxx < this._minx;
        }, j.prototype.getMaxX = function() {
          return this._maxx;
        }, j.prototype.covers = function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof C) {
              var t2 = arguments[0];
              return this.covers(t2.x, t2.y);
            }
            if (arguments[0] instanceof j) {
              var e3 = arguments[0];
              return !this.isNull() && !e3.isNull() && (e3.getMinX() >= this._minx && e3.getMaxX() <= this._maxx && e3.getMinY() >= this._miny && e3.getMaxY() <= this._maxy);
            }
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            return !this.isNull() && (n2 >= this._minx && n2 <= this._maxx && i2 >= this._miny && i2 <= this._maxy);
          }
        }, j.prototype.intersects = function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof j) {
              var t2 = arguments[0];
              return !this.isNull() && !t2.isNull() && !(t2._minx > this._maxx || t2._maxx < this._minx || t2._miny > this._maxy || t2._maxy < this._miny);
            }
            if (arguments[0] instanceof C) {
              var e3 = arguments[0];
              return this.intersects(e3.x, e3.y);
            }
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            return !this.isNull() && !(n2 > this._maxx || n2 < this._minx || i2 > this._maxy || i2 < this._miny);
          }
        }, j.prototype.getMinY = function() {
          return this._miny;
        }, j.prototype.getMinX = function() {
          return this._minx;
        }, j.prototype.expandToInclude = function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof C) {
              var t2 = arguments[0];
              this.expandToInclude(t2.x, t2.y);
            } else if (arguments[0] instanceof j) {
              var e3 = arguments[0];
              if (e3.isNull())
                return null;
              this.isNull() ? (this._minx = e3.getMinX(), this._maxx = e3.getMaxX(), this._miny = e3.getMinY(), this._maxy = e3.getMaxY()) : (e3._minx < this._minx && (this._minx = e3._minx), e3._maxx > this._maxx && (this._maxx = e3._maxx), e3._miny < this._miny && (this._miny = e3._miny), e3._maxy > this._maxy && (this._maxy = e3._maxy));
            }
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            this.isNull() ? (this._minx = n2, this._maxx = n2, this._miny = i2, this._maxy = i2) : (n2 < this._minx && (this._minx = n2), n2 > this._maxx && (this._maxx = n2), i2 < this._miny && (this._miny = i2), i2 > this._maxy && (this._maxy = i2));
          }
        }, j.prototype.minExtent = function() {
          if (this.isNull())
            return 0;
          var t2 = this.getWidth(), e3 = this.getHeight();
          return t2 < e3 ? t2 : e3;
        }, j.prototype.getWidth = function() {
          return this.isNull() ? 0 : this._maxx - this._minx;
        }, j.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this.isNull() ? e3.isNull() ? 0 : -1 : e3.isNull() ? 1 : this._minx < e3._minx ? -1 : this._minx > e3._minx ? 1 : this._miny < e3._miny ? -1 : this._miny > e3._miny ? 1 : this._maxx < e3._maxx ? -1 : this._maxx > e3._maxx ? 1 : this._maxy < e3._maxy ? -1 : this._maxy > e3._maxy ? 1 : 0;
        }, j.prototype.translate = function(t2, e3) {
          if (this.isNull())
            return null;
          this.init(this.getMinX() + t2, this.getMaxX() + t2, this.getMinY() + e3, this.getMaxY() + e3);
        }, j.prototype.toString = function() {
          return "Env[" + this._minx + " : " + this._maxx + ", " + this._miny + " : " + this._maxy + "]";
        }, j.prototype.setToNull = function() {
          this._minx = 0, this._maxx = -1, this._miny = 0, this._maxy = -1;
        }, j.prototype.getHeight = function() {
          return this.isNull() ? 0 : this._maxy - this._miny;
        }, j.prototype.maxExtent = function() {
          if (this.isNull())
            return 0;
          var t2 = this.getWidth(), e3 = this.getHeight();
          return t2 > e3 ? t2 : e3;
        }, j.prototype.expandBy = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.expandBy(t2, t2);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            if (this.isNull())
              return null;
            this._minx -= e3, this._maxx += e3, this._miny -= n2, this._maxy += n2, (this._minx > this._maxx || this._miny > this._maxy) && this.setToNull();
          }
        }, j.prototype.contains = function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof j) {
              var t2 = arguments[0];
              return this.covers(t2);
            }
            if (arguments[0] instanceof C) {
              var e3 = arguments[0];
              return this.covers(e3);
            }
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            return this.covers(n2, i2);
          }
        }, j.prototype.centre = function() {
          return this.isNull() ? null : new C((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2);
        }, j.prototype.init = function() {
          if (0 === arguments.length)
            this.setToNull();
          else if (1 === arguments.length) {
            if (arguments[0] instanceof C) {
              var t2 = arguments[0];
              this.init(t2.x, t2.x, t2.y, t2.y);
            } else if (arguments[0] instanceof j) {
              var e3 = arguments[0];
              this._minx = e3._minx, this._maxx = e3._maxx, this._miny = e3._miny, this._maxy = e3._maxy;
            }
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            this.init(n2.x, i2.x, n2.y, i2.y);
          } else if (4 === arguments.length) {
            var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2], a2 = arguments[3];
            r2 < o2 ? (this._minx = r2, this._maxx = o2) : (this._minx = o2, this._maxx = r2), s2 < a2 ? (this._miny = s2, this._maxy = a2) : (this._miny = a2, this._maxy = s2);
          }
        }, j.prototype.getMaxY = function() {
          return this._maxy;
        }, j.prototype.distance = function(t2) {
          if (this.intersects(t2))
            return 0;
          var e3 = 0;
          this._maxx < t2._minx ? e3 = t2._minx - this._maxx : this._minx > t2._maxx && (e3 = this._minx - t2._maxx);
          var n2 = 0;
          return this._maxy < t2._miny ? n2 = t2._miny - this._maxy : this._miny > t2._maxy && (n2 = this._miny - t2._maxy), 0 === e3 ? n2 : 0 === n2 ? e3 : Math.sqrt(e3 * e3 + n2 * n2);
        }, j.prototype.hashCode = function() {
          var t2 = 17;
          return t2 = 37 * t2 + C.hashCode(this._minx), t2 = 37 * t2 + C.hashCode(this._maxx), t2 = 37 * t2 + C.hashCode(this._miny), t2 = 37 * t2 + C.hashCode(this._maxy);
        }, j.prototype.interfaces_ = function() {
          return [E, e];
        }, j.prototype.getClass = function() {
          return j;
        }, j.intersects = function() {
          if (3 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
            return n2.x >= (t2.x < e3.x ? t2.x : e3.x) && n2.x <= (t2.x > e3.x ? t2.x : e3.x) && n2.y >= (t2.y < e3.y ? t2.y : e3.y) && n2.y <= (t2.y > e3.y ? t2.y : e3.y);
          }
          if (4 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2], s2 = arguments[3], a2 = Math.min(o2.x, s2.x), u2 = Math.max(o2.x, s2.x), l2 = Math.min(i2.x, r2.x), c2 = Math.max(i2.x, r2.x);
            return !(l2 > u2) && (!(c2 < a2) && (a2 = Math.min(o2.y, s2.y), u2 = Math.max(o2.y, s2.y), l2 = Math.min(i2.y, r2.y), c2 = Math.max(i2.y, r2.y), !(l2 > u2) && !(c2 < a2)));
          }
        }, H.serialVersionUID.get = function() {
          return 5873921885273102e3;
        }, Object.defineProperties(j, H);
        var W = { typeStr: /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/, emptyTypeStr: /^\s*(\w+)\s*EMPTY\s*$/, spaces: /\s+/, parenComma: /\)\s*,\s*\(/, doubleParenComma: /\)\s*\)\s*,\s*\(\s*\(/, trimParens: /^\s*\(?(.*?)\)?\s*$/ }, K = function(t2) {
          this.geometryFactory = t2 || new _e();
        };
        K.prototype.read = function(t2) {
          var e3, n2, i2;
          t2 = t2.replace(/[\n\r]/g, " ");
          var r2 = W.typeStr.exec(t2);
          if (-1 !== t2.search("EMPTY") && ((r2 = W.emptyTypeStr.exec(t2))[2] = void 0), r2 && (n2 = r2[1].toLowerCase(), i2 = r2[2], Q[n2] && (e3 = Q[n2].apply(this, [i2]))), void 0 === e3)
            throw new Error("Could not parse WKT " + t2);
          return e3;
        }, K.prototype.write = function(t2) {
          return this.extractGeometry(t2);
        }, K.prototype.extractGeometry = function(t2) {
          var e3 = t2.getGeometryType().toLowerCase();
          if (!J[e3])
            return null;
          var n2 = e3.toUpperCase();
          return t2.isEmpty() ? n2 + " EMPTY" : n2 + "(" + J[e3].apply(this, [t2]) + ")";
        };
        var J = { coordinate: function(t2) {
          return t2.x + " " + t2.y;
        }, point: function(t2) {
          return J.coordinate.call(this, t2._coordinates._coordinates[0]);
        }, multipoint: function(t2) {
          for (var e3 = [], n2 = 0, i2 = t2._geometries.length; n2 < i2; ++n2)
            e3.push("(" + J.point.apply(this, [t2._geometries[n2]]) + ")");
          return e3.join(",");
        }, linestring: function(t2) {
          for (var e3 = [], n2 = 0, i2 = t2._points._coordinates.length; n2 < i2; ++n2)
            e3.push(J.coordinate.apply(this, [t2._points._coordinates[n2]]));
          return e3.join(",");
        }, linearring: function(t2) {
          for (var e3 = [], n2 = 0, i2 = t2._points._coordinates.length; n2 < i2; ++n2)
            e3.push(J.coordinate.apply(this, [t2._points._coordinates[n2]]));
          return e3.join(",");
        }, multilinestring: function(t2) {
          for (var e3 = [], n2 = 0, i2 = t2._geometries.length; n2 < i2; ++n2)
            e3.push("(" + J.linestring.apply(this, [t2._geometries[n2]]) + ")");
          return e3.join(",");
        }, polygon: function(t2) {
          var e3 = [];
          e3.push("(" + J.linestring.apply(this, [t2._shell]) + ")");
          for (var n2 = 0, i2 = t2._holes.length; n2 < i2; ++n2)
            e3.push("(" + J.linestring.apply(this, [t2._holes[n2]]) + ")");
          return e3.join(",");
        }, multipolygon: function(t2) {
          for (var e3 = [], n2 = 0, i2 = t2._geometries.length; n2 < i2; ++n2)
            e3.push("(" + J.polygon.apply(this, [t2._geometries[n2]]) + ")");
          return e3.join(",");
        }, geometrycollection: function(t2) {
          for (var e3 = [], n2 = 0, i2 = t2._geometries.length; n2 < i2; ++n2)
            e3.push(this.extractGeometry(t2._geometries[n2]));
          return e3.join(",");
        } }, Q = { point: function(t2) {
          if (void 0 === t2)
            return this.geometryFactory.createPoint();
          var e3 = t2.trim().split(W.spaces);
          return this.geometryFactory.createPoint(new C(Number.parseFloat(e3[0]), Number.parseFloat(e3[1])));
        }, multipoint: function(t2) {
          if (void 0 === t2)
            return this.geometryFactory.createMultiPoint();
          for (var e3, n2 = t2.trim().split(","), i2 = [], r2 = 0, o2 = n2.length; r2 < o2; ++r2)
            e3 = n2[r2].replace(W.trimParens, "$1"), i2.push(Q.point.apply(this, [e3]));
          return this.geometryFactory.createMultiPoint(i2);
        }, linestring: function(t2) {
          if (void 0 === t2)
            return this.geometryFactory.createLineString();
          for (var e3, n2 = t2.trim().split(","), i2 = [], r2 = 0, o2 = n2.length; r2 < o2; ++r2)
            e3 = n2[r2].trim().split(W.spaces), i2.push(new C(Number.parseFloat(e3[0]), Number.parseFloat(e3[1])));
          return this.geometryFactory.createLineString(i2);
        }, linearring: function(t2) {
          if (void 0 === t2)
            return this.geometryFactory.createLinearRing();
          for (var e3, n2 = t2.trim().split(","), i2 = [], r2 = 0, o2 = n2.length; r2 < o2; ++r2)
            e3 = n2[r2].trim().split(W.spaces), i2.push(new C(Number.parseFloat(e3[0]), Number.parseFloat(e3[1])));
          return this.geometryFactory.createLinearRing(i2);
        }, multilinestring: function(t2) {
          if (void 0 === t2)
            return this.geometryFactory.createMultiLineString();
          for (var e3, n2 = t2.trim().split(W.parenComma), i2 = [], r2 = 0, o2 = n2.length; r2 < o2; ++r2)
            e3 = n2[r2].replace(W.trimParens, "$1"), i2.push(Q.linestring.apply(this, [e3]));
          return this.geometryFactory.createMultiLineString(i2);
        }, polygon: function(t2) {
          if (void 0 === t2)
            return this.geometryFactory.createPolygon();
          for (var e3, n2, i2, r2, o2 = t2.trim().split(W.parenComma), s2 = [], a2 = 0, u2 = o2.length; a2 < u2; ++a2)
            e3 = o2[a2].replace(W.trimParens, "$1"), n2 = Q.linestring.apply(this, [e3]), i2 = this.geometryFactory.createLinearRing(n2._points), 0 === a2 ? r2 = i2 : s2.push(i2);
          return this.geometryFactory.createPolygon(r2, s2);
        }, multipolygon: function(t2) {
          if (void 0 === t2)
            return this.geometryFactory.createMultiPolygon();
          for (var e3, n2 = t2.trim().split(W.doubleParenComma), i2 = [], r2 = 0, o2 = n2.length; r2 < o2; ++r2)
            e3 = n2[r2].replace(W.trimParens, "$1"), i2.push(Q.polygon.apply(this, [e3]));
          return this.geometryFactory.createMultiPolygon(i2);
        }, geometrycollection: function(t2) {
          if (void 0 === t2)
            return this.geometryFactory.createGeometryCollection();
          for (var e3 = (t2 = t2.replace(/,\s*([A-Za-z])/g, "|$1")).trim().split("|"), n2 = [], i2 = 0, r2 = e3.length; i2 < r2; ++i2)
            n2.push(this.read(e3[i2]));
          return this.geometryFactory.createGeometryCollection(n2);
        } }, Z = function(t2) {
          this.parser = new K(t2);
        };
        Z.prototype.write = function(t2) {
          return this.parser.write(t2);
        }, Z.toLineString = function(t2, e3) {
          if (2 !== arguments.length)
            throw new Error("Not implemented");
          return "LINESTRING ( " + t2.x + " " + t2.y + ", " + e3.x + " " + e3.y + " )";
        };
        var $ = function(t2) {
          function e3(e4) {
            t2.call(this, e4), this.name = "RuntimeException", this.message = e4, this.stack = new t2().stack;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3;
        }(Error), tt = function(t2) {
          function e3() {
            if (t2.call(this), 0 === arguments.length)
              t2.call(this);
            else if (1 === arguments.length) {
              var e4 = arguments[0];
              t2.call(this, e4);
            }
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }($), et = function() {
        };
        et.prototype.interfaces_ = function() {
          return [];
        }, et.prototype.getClass = function() {
          return et;
        }, et.shouldNeverReachHere = function() {
          if (0 === arguments.length)
            et.shouldNeverReachHere(null);
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            throw new tt("Should never reach here" + (null !== t2 ? ": " + t2 : ""));
          }
        }, et.isTrue = function() {
          var t2, e3;
          if (1 === arguments.length)
            t2 = arguments[0], et.isTrue(t2, null);
          else if (2 === arguments.length && (t2 = arguments[0], e3 = arguments[1], !t2))
            throw null === e3 ? new tt() : new tt(e3);
        }, et.equals = function() {
          var t2, e3, n2;
          if (2 === arguments.length)
            t2 = arguments[0], e3 = arguments[1], et.equals(t2, e3, null);
          else if (3 === arguments.length && (t2 = arguments[0], e3 = arguments[1], n2 = arguments[2], !e3.equals(t2)))
            throw new tt("Expected " + t2 + " but encountered " + e3 + (null !== n2 ? ": " + n2 : ""));
        };
        var nt = function() {
          this._result = null, this._inputLines = Array(2).fill().map(function() {
            return Array(2);
          }), this._intPt = new Array(2).fill(null), this._intLineIndex = null, this._isProper = null, this._pa = null, this._pb = null, this._precisionModel = null, this._intPt[0] = new C(), this._intPt[1] = new C(), this._pa = this._intPt[0], this._pb = this._intPt[1], this._result = 0;
        }, it = { DONT_INTERSECT: { configurable: true }, DO_INTERSECT: { configurable: true }, COLLINEAR: { configurable: true }, NO_INTERSECTION: { configurable: true }, POINT_INTERSECTION: { configurable: true }, COLLINEAR_INTERSECTION: { configurable: true } };
        nt.prototype.getIndexAlongSegment = function(t2, e3) {
          return this.computeIntLineIndex(), this._intLineIndex[t2][e3];
        }, nt.prototype.getTopologySummary = function() {
          var t2 = new D();
          return this.isEndPoint() && t2.append(" endpoint"), this._isProper && t2.append(" proper"), this.isCollinear() && t2.append(" collinear"), t2.toString();
        }, nt.prototype.computeIntersection = function(t2, e3, n2, i2) {
          this._inputLines[0][0] = t2, this._inputLines[0][1] = e3, this._inputLines[1][0] = n2, this._inputLines[1][1] = i2, this._result = this.computeIntersect(t2, e3, n2, i2);
        }, nt.prototype.getIntersectionNum = function() {
          return this._result;
        }, nt.prototype.computeIntLineIndex = function() {
          if (0 === arguments.length)
            null === this._intLineIndex && (this._intLineIndex = Array(2).fill().map(function() {
              return Array(2);
            }), this.computeIntLineIndex(0), this.computeIntLineIndex(1));
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            this.getEdgeDistance(t2, 0) > this.getEdgeDistance(t2, 1) ? (this._intLineIndex[t2][0] = 0, this._intLineIndex[t2][1] = 1) : (this._intLineIndex[t2][0] = 1, this._intLineIndex[t2][1] = 0);
          }
        }, nt.prototype.isProper = function() {
          return this.hasIntersection() && this._isProper;
        }, nt.prototype.setPrecisionModel = function(t2) {
          this._precisionModel = t2;
        }, nt.prototype.isInteriorIntersection = function() {
          if (0 === arguments.length)
            return !!this.isInteriorIntersection(0) || !!this.isInteriorIntersection(1);
          if (1 === arguments.length) {
            for (var t2 = arguments[0], e3 = 0; e3 < this._result; e3++)
              if (!this._intPt[e3].equals2D(this._inputLines[t2][0]) && !this._intPt[e3].equals2D(this._inputLines[t2][1]))
                return true;
            return false;
          }
        }, nt.prototype.getIntersection = function(t2) {
          return this._intPt[t2];
        }, nt.prototype.isEndPoint = function() {
          return this.hasIntersection() && !this._isProper;
        }, nt.prototype.hasIntersection = function() {
          return this._result !== nt.NO_INTERSECTION;
        }, nt.prototype.getEdgeDistance = function(t2, e3) {
          return nt.computeEdgeDistance(this._intPt[e3], this._inputLines[t2][0], this._inputLines[t2][1]);
        }, nt.prototype.isCollinear = function() {
          return this._result === nt.COLLINEAR_INTERSECTION;
        }, nt.prototype.toString = function() {
          return Z.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + " - " + Z.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary();
        }, nt.prototype.getEndpoint = function(t2, e3) {
          return this._inputLines[t2][e3];
        }, nt.prototype.isIntersection = function(t2) {
          for (var e3 = 0; e3 < this._result; e3++)
            if (this._intPt[e3].equals2D(t2))
              return true;
          return false;
        }, nt.prototype.getIntersectionAlongSegment = function(t2, e3) {
          return this.computeIntLineIndex(), this._intPt[this._intLineIndex[t2][e3]];
        }, nt.prototype.interfaces_ = function() {
          return [];
        }, nt.prototype.getClass = function() {
          return nt;
        }, nt.computeEdgeDistance = function(t2, e3, n2) {
          var i2 = Math.abs(n2.x - e3.x), r2 = Math.abs(n2.y - e3.y), o2 = -1;
          if (t2.equals(e3))
            o2 = 0;
          else if (t2.equals(n2))
            o2 = i2 > r2 ? i2 : r2;
          else {
            var s2 = Math.abs(t2.x - e3.x), a2 = Math.abs(t2.y - e3.y);
            0 !== (o2 = i2 > r2 ? s2 : a2) || t2.equals(e3) || (o2 = Math.max(s2, a2));
          }
          return et.isTrue(!(0 === o2 && !t2.equals(e3)), "Bad distance calculation"), o2;
        }, nt.nonRobustComputeEdgeDistance = function(t2, e3, n2) {
          var i2 = t2.x - e3.x, r2 = t2.y - e3.y, o2 = Math.sqrt(i2 * i2 + r2 * r2);
          return et.isTrue(!(0 === o2 && !t2.equals(e3)), "Invalid distance calculation"), o2;
        }, it.DONT_INTERSECT.get = function() {
          return 0;
        }, it.DO_INTERSECT.get = function() {
          return 1;
        }, it.COLLINEAR.get = function() {
          return 2;
        }, it.NO_INTERSECTION.get = function() {
          return 0;
        }, it.POINT_INTERSECTION.get = function() {
          return 1;
        }, it.COLLINEAR_INTERSECTION.get = function() {
          return 2;
        }, Object.defineProperties(nt, it);
        var rt = function(t2) {
          function e3() {
            t2.apply(this, arguments);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.isInSegmentEnvelopes = function(t3) {
            var e4 = new j(this._inputLines[0][0], this._inputLines[0][1]), n2 = new j(this._inputLines[1][0], this._inputLines[1][1]);
            return e4.contains(t3) && n2.contains(t3);
          }, e3.prototype.computeIntersection = function() {
            if (3 !== arguments.length)
              return t2.prototype.computeIntersection.apply(this, arguments);
            var e4 = arguments[0], n2 = arguments[1], i2 = arguments[2];
            if (this._isProper = false, j.intersects(n2, i2, e4) && 0 === at.orientationIndex(n2, i2, e4) && 0 === at.orientationIndex(i2, n2, e4))
              return this._isProper = true, (e4.equals(n2) || e4.equals(i2)) && (this._isProper = false), this._result = t2.POINT_INTERSECTION, null;
            this._result = t2.NO_INTERSECTION;
          }, e3.prototype.normalizeToMinimum = function(t3, e4, n2, i2, r2) {
            r2.x = this.smallestInAbsValue(t3.x, e4.x, n2.x, i2.x), r2.y = this.smallestInAbsValue(t3.y, e4.y, n2.y, i2.y), t3.x -= r2.x, t3.y -= r2.y, e4.x -= r2.x, e4.y -= r2.y, n2.x -= r2.x, n2.y -= r2.y, i2.x -= r2.x, i2.y -= r2.y;
          }, e3.prototype.safeHCoordinateIntersection = function(t3, n2, i2, r2) {
            var o2 = null;
            try {
              o2 = k.intersection(t3, n2, i2, r2);
            } catch (s2) {
              if (!(s2 instanceof X))
                throw s2;
              o2 = e3.nearestEndpoint(t3, n2, i2, r2);
            }
            return o2;
          }, e3.prototype.intersection = function(t3, n2, i2, r2) {
            var o2 = this.intersectionWithNormalization(t3, n2, i2, r2);
            return this.isInSegmentEnvelopes(o2) || (o2 = new C(e3.nearestEndpoint(t3, n2, i2, r2))), null !== this._precisionModel && this._precisionModel.makePrecise(o2), o2;
          }, e3.prototype.smallestInAbsValue = function(t3, e4, n2, i2) {
            var r2 = t3, o2 = Math.abs(r2);
            return Math.abs(e4) < o2 && (r2 = e4, o2 = Math.abs(e4)), Math.abs(n2) < o2 && (r2 = n2, o2 = Math.abs(n2)), Math.abs(i2) < o2 && (r2 = i2), r2;
          }, e3.prototype.checkDD = function(t3, e4, n2, i2, r2) {
            var o2 = q.intersection(t3, e4, n2, i2), s2 = this.isInSegmentEnvelopes(o2);
            Y.out.println("DD in env = " + s2 + "  --------------------- " + o2), r2.distance(o2) > 1e-4 && Y.out.println("Distance = " + r2.distance(o2));
          }, e3.prototype.intersectionWithNormalization = function(t3, e4, n2, i2) {
            var r2 = new C(t3), o2 = new C(e4), s2 = new C(n2), a2 = new C(i2), u2 = new C();
            this.normalizeToEnvCentre(r2, o2, s2, a2, u2);
            var l2 = this.safeHCoordinateIntersection(r2, o2, s2, a2);
            return l2.x += u2.x, l2.y += u2.y, l2;
          }, e3.prototype.computeCollinearIntersection = function(e4, n2, i2, r2) {
            var o2 = j.intersects(e4, n2, i2), s2 = j.intersects(e4, n2, r2), a2 = j.intersects(i2, r2, e4), u2 = j.intersects(i2, r2, n2);
            return o2 && s2 ? (this._intPt[0] = i2, this._intPt[1] = r2, t2.COLLINEAR_INTERSECTION) : a2 && u2 ? (this._intPt[0] = e4, this._intPt[1] = n2, t2.COLLINEAR_INTERSECTION) : o2 && a2 ? (this._intPt[0] = i2, this._intPt[1] = e4, !i2.equals(e4) || s2 || u2 ? t2.COLLINEAR_INTERSECTION : t2.POINT_INTERSECTION) : o2 && u2 ? (this._intPt[0] = i2, this._intPt[1] = n2, !i2.equals(n2) || s2 || a2 ? t2.COLLINEAR_INTERSECTION : t2.POINT_INTERSECTION) : s2 && a2 ? (this._intPt[0] = r2, this._intPt[1] = e4, !r2.equals(e4) || o2 || u2 ? t2.COLLINEAR_INTERSECTION : t2.POINT_INTERSECTION) : s2 && u2 ? (this._intPt[0] = r2, this._intPt[1] = n2, !r2.equals(n2) || o2 || a2 ? t2.COLLINEAR_INTERSECTION : t2.POINT_INTERSECTION) : t2.NO_INTERSECTION;
          }, e3.prototype.normalizeToEnvCentre = function(t3, e4, n2, i2, r2) {
            var o2 = t3.x < e4.x ? t3.x : e4.x, s2 = t3.y < e4.y ? t3.y : e4.y, a2 = t3.x > e4.x ? t3.x : e4.x, u2 = t3.y > e4.y ? t3.y : e4.y, l2 = n2.x < i2.x ? n2.x : i2.x, c2 = n2.y < i2.y ? n2.y : i2.y, p2 = n2.x > i2.x ? n2.x : i2.x, h2 = n2.y > i2.y ? n2.y : i2.y, f2 = ((o2 > l2 ? o2 : l2) + (a2 < p2 ? a2 : p2)) / 2, g2 = ((s2 > c2 ? s2 : c2) + (u2 < h2 ? u2 : h2)) / 2;
            r2.x = f2, r2.y = g2, t3.x -= r2.x, t3.y -= r2.y, e4.x -= r2.x, e4.y -= r2.y, n2.x -= r2.x, n2.y -= r2.y, i2.x -= r2.x, i2.y -= r2.y;
          }, e3.prototype.computeIntersect = function(e4, n2, i2, r2) {
            if (this._isProper = false, !j.intersects(e4, n2, i2, r2))
              return t2.NO_INTERSECTION;
            var o2 = at.orientationIndex(e4, n2, i2), s2 = at.orientationIndex(e4, n2, r2);
            if (o2 > 0 && s2 > 0 || o2 < 0 && s2 < 0)
              return t2.NO_INTERSECTION;
            var a2 = at.orientationIndex(i2, r2, e4), u2 = at.orientationIndex(i2, r2, n2);
            if (a2 > 0 && u2 > 0 || a2 < 0 && u2 < 0)
              return t2.NO_INTERSECTION;
            return 0 === o2 && 0 === s2 && 0 === a2 && 0 === u2 ? this.computeCollinearIntersection(e4, n2, i2, r2) : (0 === o2 || 0 === s2 || 0 === a2 || 0 === u2 ? (this._isProper = false, e4.equals2D(i2) || e4.equals2D(r2) ? this._intPt[0] = e4 : n2.equals2D(i2) || n2.equals2D(r2) ? this._intPt[0] = n2 : 0 === o2 ? this._intPt[0] = new C(i2) : 0 === s2 ? this._intPt[0] = new C(r2) : 0 === a2 ? this._intPt[0] = new C(e4) : 0 === u2 && (this._intPt[0] = new C(n2))) : (this._isProper = true, this._intPt[0] = this.intersection(e4, n2, i2, r2)), t2.POINT_INTERSECTION);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3.nearestEndpoint = function(t3, e4, n2, i2) {
            var r2 = t3, o2 = at.distancePointLine(t3, n2, i2), s2 = at.distancePointLine(e4, n2, i2);
            return s2 < o2 && (o2 = s2, r2 = e4), (s2 = at.distancePointLine(n2, t3, e4)) < o2 && (o2 = s2, r2 = n2), (s2 = at.distancePointLine(i2, t3, e4)) < o2 && (o2 = s2, r2 = i2), r2;
          }, e3;
        }(nt), ot = function() {
        };
        ot.prototype.interfaces_ = function() {
          return [];
        }, ot.prototype.getClass = function() {
          return ot;
        }, ot.orientationIndex = function(t2, e3, n2) {
          var i2 = e3.x - t2.x, r2 = e3.y - t2.y, o2 = n2.x - e3.x, s2 = n2.y - e3.y;
          return ot.signOfDet2x2(i2, r2, o2, s2);
        }, ot.signOfDet2x2 = function(t2, e3, n2, i2) {
          var r2 = null, o2 = null, s2 = null;
          if (r2 = 1, 0 === t2 || 0 === i2)
            return 0 === e3 || 0 === n2 ? 0 : e3 > 0 ? n2 > 0 ? -r2 : r2 : n2 > 0 ? r2 : -r2;
          if (0 === e3 || 0 === n2)
            return i2 > 0 ? t2 > 0 ? r2 : -r2 : t2 > 0 ? -r2 : r2;
          if (e3 > 0 ? i2 > 0 ? e3 <= i2 || (r2 = -r2, o2 = t2, t2 = n2, n2 = o2, o2 = e3, e3 = i2, i2 = o2) : e3 <= -i2 ? (r2 = -r2, n2 = -n2, i2 = -i2) : (o2 = t2, t2 = -n2, n2 = o2, o2 = e3, e3 = -i2, i2 = o2) : i2 > 0 ? -e3 <= i2 ? (r2 = -r2, t2 = -t2, e3 = -e3) : (o2 = -t2, t2 = n2, n2 = o2, o2 = -e3, e3 = i2, i2 = o2) : e3 >= i2 ? (t2 = -t2, e3 = -e3, n2 = -n2, i2 = -i2) : (r2 = -r2, o2 = -t2, t2 = -n2, n2 = o2, o2 = -e3, e3 = -i2, i2 = o2), t2 > 0) {
            if (!(n2 > 0))
              return r2;
            if (!(t2 <= n2))
              return r2;
          } else {
            if (n2 > 0)
              return -r2;
            if (!(t2 >= n2))
              return -r2;
            r2 = -r2, t2 = -t2, n2 = -n2;
          }
          for (; ; ) {
            if (s2 = Math.floor(n2 / t2), n2 -= s2 * t2, (i2 -= s2 * e3) < 0)
              return -r2;
            if (i2 > e3)
              return r2;
            if (t2 > n2 + n2) {
              if (e3 < i2 + i2)
                return r2;
            } else {
              if (e3 > i2 + i2)
                return -r2;
              n2 = t2 - n2, i2 = e3 - i2, r2 = -r2;
            }
            if (0 === i2)
              return 0 === n2 ? 0 : -r2;
            if (0 === n2)
              return r2;
            if (s2 = Math.floor(t2 / n2), t2 -= s2 * n2, (e3 -= s2 * i2) < 0)
              return r2;
            if (e3 > i2)
              return -r2;
            if (n2 > t2 + t2) {
              if (i2 < e3 + e3)
                return -r2;
            } else {
              if (i2 > e3 + e3)
                return r2;
              t2 = n2 - t2, e3 = i2 - e3, r2 = -r2;
            }
            if (0 === e3)
              return 0 === t2 ? 0 : r2;
            if (0 === t2)
              return -r2;
          }
        };
        var st = function() {
          this._p = null, this._crossingCount = 0, this._isPointOnSegment = false;
          var t2 = arguments[0];
          this._p = t2;
        };
        st.prototype.countSegment = function(t2, e3) {
          if (t2.x < this._p.x && e3.x < this._p.x)
            return null;
          if (this._p.x === e3.x && this._p.y === e3.y)
            return this._isPointOnSegment = true, null;
          if (t2.y === this._p.y && e3.y === this._p.y) {
            var n2 = t2.x, i2 = e3.x;
            return n2 > i2 && (n2 = e3.x, i2 = t2.x), this._p.x >= n2 && this._p.x <= i2 && (this._isPointOnSegment = true), null;
          }
          if (t2.y > this._p.y && e3.y <= this._p.y || e3.y > this._p.y && t2.y <= this._p.y) {
            var r2 = t2.x - this._p.x, o2 = t2.y - this._p.y, s2 = e3.x - this._p.x, a2 = e3.y - this._p.y, u2 = ot.signOfDet2x2(r2, o2, s2, a2);
            if (0 === u2)
              return this._isPointOnSegment = true, null;
            a2 < o2 && (u2 = -u2), u2 > 0 && this._crossingCount++;
          }
        }, st.prototype.isPointInPolygon = function() {
          return this.getLocation() !== w.EXTERIOR;
        }, st.prototype.getLocation = function() {
          return this._isPointOnSegment ? w.BOUNDARY : this._crossingCount % 2 == 1 ? w.INTERIOR : w.EXTERIOR;
        }, st.prototype.isOnSegment = function() {
          return this._isPointOnSegment;
        }, st.prototype.interfaces_ = function() {
          return [];
        }, st.prototype.getClass = function() {
          return st;
        }, st.locatePointInRing = function() {
          if (arguments[0] instanceof C && T(arguments[1], V)) {
            for (var t2 = arguments[0], e3 = arguments[1], n2 = new st(t2), i2 = new C(), r2 = new C(), o2 = 1; o2 < e3.size(); o2++)
              if (e3.getCoordinate(o2, i2), e3.getCoordinate(o2 - 1, r2), n2.countSegment(i2, r2), n2.isOnSegment())
                return n2.getLocation();
            return n2.getLocation();
          }
          if (arguments[0] instanceof C && arguments[1] instanceof Array) {
            for (var s2 = arguments[0], a2 = arguments[1], u2 = new st(s2), l2 = 1; l2 < a2.length; l2++) {
              var c2 = a2[l2], p2 = a2[l2 - 1];
              if (u2.countSegment(c2, p2), u2.isOnSegment())
                return u2.getLocation();
            }
            return u2.getLocation();
          }
        };
        var at = function() {
        }, ut = { CLOCKWISE: { configurable: true }, RIGHT: { configurable: true }, COUNTERCLOCKWISE: { configurable: true }, LEFT: { configurable: true }, COLLINEAR: { configurable: true }, STRAIGHT: { configurable: true } };
        at.prototype.interfaces_ = function() {
          return [];
        }, at.prototype.getClass = function() {
          return at;
        }, at.orientationIndex = function(t2, e3, n2) {
          return q.orientationIndex(t2, e3, n2);
        }, at.signedArea = function() {
          if (arguments[0] instanceof Array) {
            var t2 = arguments[0];
            if (t2.length < 3)
              return 0;
            for (var e3 = 0, n2 = t2[0].x, i2 = 1; i2 < t2.length - 1; i2++) {
              var r2 = t2[i2].x - n2, o2 = t2[i2 + 1].y;
              e3 += r2 * (t2[i2 - 1].y - o2);
            }
            return e3 / 2;
          }
          if (T(arguments[0], V)) {
            var s2 = arguments[0], a2 = s2.size();
            if (a2 < 3)
              return 0;
            var u2 = new C(), l2 = new C(), c2 = new C();
            s2.getCoordinate(0, l2), s2.getCoordinate(1, c2);
            var p2 = l2.x;
            c2.x -= p2;
            for (var h2 = 0, f2 = 1; f2 < a2 - 1; f2++)
              u2.y = l2.y, l2.x = c2.x, l2.y = c2.y, s2.getCoordinate(f2 + 1, c2), c2.x -= p2, h2 += l2.x * (u2.y - c2.y);
            return h2 / 2;
          }
        }, at.distanceLineLine = function(t2, e3, n2, i2) {
          if (t2.equals(e3))
            return at.distancePointLine(t2, n2, i2);
          if (n2.equals(i2))
            return at.distancePointLine(i2, t2, e3);
          var r2 = false;
          if (j.intersects(t2, e3, n2, i2)) {
            var o2 = (e3.x - t2.x) * (i2.y - n2.y) - (e3.y - t2.y) * (i2.x - n2.x);
            if (0 === o2)
              r2 = true;
            else {
              var s2 = (t2.y - n2.y) * (i2.x - n2.x) - (t2.x - n2.x) * (i2.y - n2.y), a2 = ((t2.y - n2.y) * (e3.x - t2.x) - (t2.x - n2.x) * (e3.y - t2.y)) / o2, u2 = s2 / o2;
              (u2 < 0 || u2 > 1 || a2 < 0 || a2 > 1) && (r2 = true);
            }
          } else
            r2 = true;
          return r2 ? R.min(at.distancePointLine(t2, n2, i2), at.distancePointLine(e3, n2, i2), at.distancePointLine(n2, t2, e3), at.distancePointLine(i2, t2, e3)) : 0;
        }, at.isPointInRing = function(t2, e3) {
          return at.locatePointInRing(t2, e3) !== w.EXTERIOR;
        }, at.computeLength = function(t2) {
          var e3 = t2.size();
          if (e3 <= 1)
            return 0;
          var n2 = 0, i2 = new C();
          t2.getCoordinate(0, i2);
          for (var r2 = i2.x, o2 = i2.y, s2 = 1; s2 < e3; s2++) {
            t2.getCoordinate(s2, i2);
            var a2 = i2.x, u2 = i2.y, l2 = a2 - r2, c2 = u2 - o2;
            n2 += Math.sqrt(l2 * l2 + c2 * c2), r2 = a2, o2 = u2;
          }
          return n2;
        }, at.isCCW = function(t2) {
          var e3 = t2.length - 1;
          if (e3 < 3)
            throw new m("Ring has fewer than 4 points, so orientation cannot be determined");
          for (var n2 = t2[0], i2 = 0, r2 = 1; r2 <= e3; r2++) {
            var o2 = t2[r2];
            o2.y > n2.y && (n2 = o2, i2 = r2);
          }
          var s2 = i2;
          do {
            (s2 -= 1) < 0 && (s2 = e3);
          } while (t2[s2].equals2D(n2) && s2 !== i2);
          var a2 = i2;
          do {
            a2 = (a2 + 1) % e3;
          } while (t2[a2].equals2D(n2) && a2 !== i2);
          var u2 = t2[s2], l2 = t2[a2];
          if (u2.equals2D(n2) || l2.equals2D(n2) || u2.equals2D(l2))
            return false;
          var c2 = at.computeOrientation(u2, n2, l2), p2 = false;
          return p2 = 0 === c2 ? u2.x > l2.x : c2 > 0, p2;
        }, at.locatePointInRing = function(t2, e3) {
          return st.locatePointInRing(t2, e3);
        }, at.distancePointLinePerpendicular = function(t2, e3, n2) {
          var i2 = (n2.x - e3.x) * (n2.x - e3.x) + (n2.y - e3.y) * (n2.y - e3.y), r2 = ((e3.y - t2.y) * (n2.x - e3.x) - (e3.x - t2.x) * (n2.y - e3.y)) / i2;
          return Math.abs(r2) * Math.sqrt(i2);
        }, at.computeOrientation = function(t2, e3, n2) {
          return at.orientationIndex(t2, e3, n2);
        }, at.distancePointLine = function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            if (0 === e3.length)
              throw new m("Line array must contain at least one vertex");
            for (var n2 = t2.distance(e3[0]), i2 = 0; i2 < e3.length - 1; i2++) {
              var r2 = at.distancePointLine(t2, e3[i2], e3[i2 + 1]);
              r2 < n2 && (n2 = r2);
            }
            return n2;
          }
          if (3 === arguments.length) {
            var o2 = arguments[0], s2 = arguments[1], a2 = arguments[2];
            if (s2.x === a2.x && s2.y === a2.y)
              return o2.distance(s2);
            var u2 = (a2.x - s2.x) * (a2.x - s2.x) + (a2.y - s2.y) * (a2.y - s2.y), l2 = ((o2.x - s2.x) * (a2.x - s2.x) + (o2.y - s2.y) * (a2.y - s2.y)) / u2;
            if (l2 <= 0)
              return o2.distance(s2);
            if (l2 >= 1)
              return o2.distance(a2);
            var c2 = ((s2.y - o2.y) * (a2.x - s2.x) - (s2.x - o2.x) * (a2.y - s2.y)) / u2;
            return Math.abs(c2) * Math.sqrt(u2);
          }
        }, at.isOnLine = function(t2, e3) {
          for (var n2 = new rt(), i2 = 1; i2 < e3.length; i2++) {
            var r2 = e3[i2 - 1], o2 = e3[i2];
            if (n2.computeIntersection(t2, r2, o2), n2.hasIntersection())
              return true;
          }
          return false;
        }, ut.CLOCKWISE.get = function() {
          return -1;
        }, ut.RIGHT.get = function() {
          return at.CLOCKWISE;
        }, ut.COUNTERCLOCKWISE.get = function() {
          return 1;
        }, ut.LEFT.get = function() {
          return at.COUNTERCLOCKWISE;
        }, ut.COLLINEAR.get = function() {
          return 0;
        }, ut.STRAIGHT.get = function() {
          return at.COLLINEAR;
        }, Object.defineProperties(at, ut);
        var lt = function() {
        };
        lt.prototype.filter = function(t2) {
        }, lt.prototype.interfaces_ = function() {
          return [];
        }, lt.prototype.getClass = function() {
          return lt;
        };
        var ct = function() {
          var t2 = arguments[0];
          this._envelope = null, this._factory = null, this._SRID = null, this._userData = null, this._factory = t2, this._SRID = t2.getSRID();
        }, pt = { serialVersionUID: { configurable: true }, SORTINDEX_POINT: { configurable: true }, SORTINDEX_MULTIPOINT: { configurable: true }, SORTINDEX_LINESTRING: { configurable: true }, SORTINDEX_LINEARRING: { configurable: true }, SORTINDEX_MULTILINESTRING: { configurable: true }, SORTINDEX_POLYGON: { configurable: true }, SORTINDEX_MULTIPOLYGON: { configurable: true }, SORTINDEX_GEOMETRYCOLLECTION: { configurable: true }, geometryChangedFilter: { configurable: true } };
        ct.prototype.isGeometryCollection = function() {
          return this.getSortIndex() === ct.SORTINDEX_GEOMETRYCOLLECTION;
        }, ct.prototype.getFactory = function() {
          return this._factory;
        }, ct.prototype.getGeometryN = function(t2) {
          return this;
        }, ct.prototype.getArea = function() {
          return 0;
        }, ct.prototype.isRectangle = function() {
          return false;
        }, ct.prototype.equals = function() {
          if (arguments[0] instanceof ct) {
            var t2 = arguments[0];
            return null !== t2 && this.equalsTopo(t2);
          }
          if (arguments[0] instanceof Object) {
            var e3 = arguments[0];
            if (!(e3 instanceof ct))
              return false;
            var n2 = e3;
            return this.equalsExact(n2);
          }
        }, ct.prototype.equalsExact = function(t2) {
          return this === t2 || this.equalsExact(t2, 0);
        }, ct.prototype.geometryChanged = function() {
          this.apply(ct.geometryChangedFilter);
        }, ct.prototype.geometryChangedAction = function() {
          this._envelope = null;
        }, ct.prototype.equalsNorm = function(t2) {
          return null !== t2 && this.norm().equalsExact(t2.norm());
        }, ct.prototype.getLength = function() {
          return 0;
        }, ct.prototype.getNumGeometries = function() {
          return 1;
        }, ct.prototype.compareTo = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0], e3 = t2;
            return this.getSortIndex() !== e3.getSortIndex() ? this.getSortIndex() - e3.getSortIndex() : this.isEmpty() && e3.isEmpty() ? 0 : this.isEmpty() ? -1 : e3.isEmpty() ? 1 : this.compareToSameClass(t2);
          }
          if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            return this.getSortIndex() !== n2.getSortIndex() ? this.getSortIndex() - n2.getSortIndex() : this.isEmpty() && n2.isEmpty() ? 0 : this.isEmpty() ? -1 : n2.isEmpty() ? 1 : this.compareToSameClass(n2, i2);
          }
        }, ct.prototype.getUserData = function() {
          return this._userData;
        }, ct.prototype.getSRID = function() {
          return this._SRID;
        }, ct.prototype.getEnvelope = function() {
          return this.getFactory().toGeometry(this.getEnvelopeInternal());
        }, ct.prototype.checkNotGeometryCollection = function(t2) {
          if (t2.getSortIndex() === ct.SORTINDEX_GEOMETRYCOLLECTION)
            throw new m("This method does not support GeometryCollection arguments");
        }, ct.prototype.equal = function(t2, e3, n2) {
          return 0 === n2 ? t2.equals(e3) : t2.distance(e3) <= n2;
        }, ct.prototype.norm = function() {
          var t2 = this.copy();
          return t2.normalize(), t2;
        }, ct.prototype.getPrecisionModel = function() {
          return this._factory.getPrecisionModel();
        }, ct.prototype.getEnvelopeInternal = function() {
          return null === this._envelope && (this._envelope = this.computeEnvelopeInternal()), new j(this._envelope);
        }, ct.prototype.setSRID = function(t2) {
          this._SRID = t2;
        }, ct.prototype.setUserData = function(t2) {
          this._userData = t2;
        }, ct.prototype.compare = function(t2, e3) {
          for (var n2 = t2.iterator(), i2 = e3.iterator(); n2.hasNext() && i2.hasNext(); ) {
            var r2 = n2.next(), o2 = i2.next(), s2 = r2.compareTo(o2);
            if (0 !== s2)
              return s2;
          }
          return n2.hasNext() ? 1 : i2.hasNext() ? -1 : 0;
        }, ct.prototype.hashCode = function() {
          return this.getEnvelopeInternal().hashCode();
        }, ct.prototype.isGeometryCollectionOrDerived = function() {
          return this.getSortIndex() === ct.SORTINDEX_GEOMETRYCOLLECTION || this.getSortIndex() === ct.SORTINDEX_MULTIPOINT || this.getSortIndex() === ct.SORTINDEX_MULTILINESTRING || this.getSortIndex() === ct.SORTINDEX_MULTIPOLYGON;
        }, ct.prototype.interfaces_ = function() {
          return [x2, E, e];
        }, ct.prototype.getClass = function() {
          return ct;
        }, ct.hasNonEmptyElements = function(t2) {
          for (var e3 = 0; e3 < t2.length; e3++)
            if (!t2[e3].isEmpty())
              return true;
          return false;
        }, ct.hasNullElements = function(t2) {
          for (var e3 = 0; e3 < t2.length; e3++)
            if (null === t2[e3])
              return true;
          return false;
        }, pt.serialVersionUID.get = function() {
          return 8763622679187377e3;
        }, pt.SORTINDEX_POINT.get = function() {
          return 0;
        }, pt.SORTINDEX_MULTIPOINT.get = function() {
          return 1;
        }, pt.SORTINDEX_LINESTRING.get = function() {
          return 2;
        }, pt.SORTINDEX_LINEARRING.get = function() {
          return 3;
        }, pt.SORTINDEX_MULTILINESTRING.get = function() {
          return 4;
        }, pt.SORTINDEX_POLYGON.get = function() {
          return 5;
        }, pt.SORTINDEX_MULTIPOLYGON.get = function() {
          return 6;
        }, pt.SORTINDEX_GEOMETRYCOLLECTION.get = function() {
          return 7;
        }, pt.geometryChangedFilter.get = function() {
          return ht;
        }, Object.defineProperties(ct, pt);
        var ht = function() {
        };
        ht.interfaces_ = function() {
          return [lt];
        }, ht.filter = function(t2) {
          t2.geometryChangedAction();
        };
        var ft = function() {
        };
        ft.prototype.filter = function(t2) {
        }, ft.prototype.interfaces_ = function() {
          return [];
        }, ft.prototype.getClass = function() {
          return ft;
        };
        var gt = function() {
        }, dt = { Mod2BoundaryNodeRule: { configurable: true }, EndPointBoundaryNodeRule: { configurable: true }, MultiValentEndPointBoundaryNodeRule: { configurable: true }, MonoValentEndPointBoundaryNodeRule: { configurable: true }, MOD2_BOUNDARY_RULE: { configurable: true }, ENDPOINT_BOUNDARY_RULE: { configurable: true }, MULTIVALENT_ENDPOINT_BOUNDARY_RULE: { configurable: true }, MONOVALENT_ENDPOINT_BOUNDARY_RULE: { configurable: true }, OGC_SFS_BOUNDARY_RULE: { configurable: true } };
        gt.prototype.isInBoundary = function(t2) {
        }, gt.prototype.interfaces_ = function() {
          return [];
        }, gt.prototype.getClass = function() {
          return gt;
        }, dt.Mod2BoundaryNodeRule.get = function() {
          return yt;
        }, dt.EndPointBoundaryNodeRule.get = function() {
          return _t;
        }, dt.MultiValentEndPointBoundaryNodeRule.get = function() {
          return mt;
        }, dt.MonoValentEndPointBoundaryNodeRule.get = function() {
          return vt;
        }, dt.MOD2_BOUNDARY_RULE.get = function() {
          return new yt();
        }, dt.ENDPOINT_BOUNDARY_RULE.get = function() {
          return new _t();
        }, dt.MULTIVALENT_ENDPOINT_BOUNDARY_RULE.get = function() {
          return new mt();
        }, dt.MONOVALENT_ENDPOINT_BOUNDARY_RULE.get = function() {
          return new vt();
        }, dt.OGC_SFS_BOUNDARY_RULE.get = function() {
          return gt.MOD2_BOUNDARY_RULE;
        }, Object.defineProperties(gt, dt);
        var yt = function() {
        };
        yt.prototype.isInBoundary = function(t2) {
          return t2 % 2 == 1;
        }, yt.prototype.interfaces_ = function() {
          return [gt];
        }, yt.prototype.getClass = function() {
          return yt;
        };
        var _t = function() {
        };
        _t.prototype.isInBoundary = function(t2) {
          return t2 > 0;
        }, _t.prototype.interfaces_ = function() {
          return [gt];
        }, _t.prototype.getClass = function() {
          return _t;
        };
        var mt = function() {
        };
        mt.prototype.isInBoundary = function(t2) {
          return t2 > 1;
        }, mt.prototype.interfaces_ = function() {
          return [gt];
        }, mt.prototype.getClass = function() {
          return mt;
        };
        var vt = function() {
        };
        vt.prototype.isInBoundary = function(t2) {
          return 1 === t2;
        }, vt.prototype.interfaces_ = function() {
          return [gt];
        }, vt.prototype.getClass = function() {
          return vt;
        };
        var It = function() {
        };
        It.prototype.add = function() {
        }, It.prototype.addAll = function() {
        }, It.prototype.isEmpty = function() {
        }, It.prototype.iterator = function() {
        }, It.prototype.size = function() {
        }, It.prototype.toArray = function() {
        }, It.prototype.remove = function() {
        }, (n.prototype = new Error()).name = "IndexOutOfBoundsException";
        var Et = function() {
        };
        Et.prototype.hasNext = function() {
        }, Et.prototype.next = function() {
        }, Et.prototype.remove = function() {
        };
        var xt = function(t2) {
          function e3() {
            t2.apply(this, arguments);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.get = function() {
          }, e3.prototype.set = function() {
          }, e3.prototype.isEmpty = function() {
          }, e3;
        }(It);
        (i.prototype = new Error()).name = "NoSuchElementException";
        var Nt = function(t2) {
          function e3() {
            t2.call(this), this.array_ = [], arguments[0] instanceof It && this.addAll(arguments[0]);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.ensureCapacity = function() {
          }, e3.prototype.interfaces_ = function() {
            return [t2, It];
          }, e3.prototype.add = function(t3) {
            return 1 === arguments.length ? this.array_.push(t3) : this.array_.splice(arguments[0], arguments[1]), true;
          }, e3.prototype.clear = function() {
            this.array_ = [];
          }, e3.prototype.addAll = function(t3) {
            for (var e4 = t3.iterator(); e4.hasNext(); )
              this.add(e4.next());
            return true;
          }, e3.prototype.set = function(t3, e4) {
            var n2 = this.array_[t3];
            return this.array_[t3] = e4, n2;
          }, e3.prototype.iterator = function() {
            return new Ct(this);
          }, e3.prototype.get = function(t3) {
            if (t3 < 0 || t3 >= this.size())
              throw new n();
            return this.array_[t3];
          }, e3.prototype.isEmpty = function() {
            return 0 === this.array_.length;
          }, e3.prototype.size = function() {
            return this.array_.length;
          }, e3.prototype.toArray = function() {
            for (var t3 = [], e4 = 0, n2 = this.array_.length; e4 < n2; e4++)
              t3.push(this.array_[e4]);
            return t3;
          }, e3.prototype.remove = function(t3) {
            for (var e4 = false, n2 = 0, i2 = this.array_.length; n2 < i2; n2++)
              if (this.array_[n2] === t3) {
                this.array_.splice(n2, 1), e4 = true;
                break;
              }
            return e4;
          }, e3;
        }(xt), Ct = function(t2) {
          function e3(e4) {
            t2.call(this), this.arrayList_ = e4, this.position_ = 0;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.next = function() {
            if (this.position_ === this.arrayList_.size())
              throw new i();
            return this.arrayList_.get(this.position_++);
          }, e3.prototype.hasNext = function() {
            return this.position_ < this.arrayList_.size();
          }, e3.prototype.set = function(t3) {
            return this.arrayList_.set(this.position_ - 1, t3);
          }, e3.prototype.remove = function() {
            this.arrayList_.remove(this.arrayList_.get(this.position_));
          }, e3;
        }(Et), St = function(t2) {
          function e3() {
            if (t2.call(this), 0 === arguments.length)
              ;
            else if (1 === arguments.length) {
              var e4 = arguments[0];
              this.ensureCapacity(e4.length), this.add(e4, true);
            } else if (2 === arguments.length) {
              var n3 = arguments[0], i2 = arguments[1];
              this.ensureCapacity(n3.length), this.add(n3, i2);
            }
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { coordArrayType: { configurable: true } };
          return n2.coordArrayType.get = function() {
            return new Array(0).fill(null);
          }, e3.prototype.getCoordinate = function(t3) {
            return this.get(t3);
          }, e3.prototype.addAll = function() {
            if (2 === arguments.length) {
              for (var e4 = arguments[0], n3 = arguments[1], i2 = false, r2 = e4.iterator(); r2.hasNext(); )
                this.add(r2.next(), n3), i2 = true;
              return i2;
            }
            return t2.prototype.addAll.apply(this, arguments);
          }, e3.prototype.clone = function() {
            for (var e4 = t2.prototype.clone.call(this), n3 = 0; n3 < this.size(); n3++)
              e4.add(n3, this.get(n3).copy());
            return e4;
          }, e3.prototype.toCoordinateArray = function() {
            return this.toArray(e3.coordArrayType);
          }, e3.prototype.add = function() {
            if (1 === arguments.length) {
              var e4 = arguments[0];
              t2.prototype.add.call(this, e4);
            } else if (2 === arguments.length) {
              if (arguments[0] instanceof Array && "boolean" == typeof arguments[1]) {
                var n3 = arguments[0], i2 = arguments[1];
                return this.add(n3, i2, true), true;
              }
              if (arguments[0] instanceof C && "boolean" == typeof arguments[1]) {
                var r2 = arguments[0];
                if (!arguments[1] && this.size() >= 1) {
                  if (this.get(this.size() - 1).equals2D(r2))
                    return null;
                }
                t2.prototype.add.call(this, r2);
              } else if (arguments[0] instanceof Object && "boolean" == typeof arguments[1]) {
                var o2 = arguments[0], s2 = arguments[1];
                return this.add(o2, s2), true;
              }
            } else if (3 === arguments.length) {
              if ("boolean" == typeof arguments[2] && arguments[0] instanceof Array && "boolean" == typeof arguments[1]) {
                var a2 = arguments[0], u2 = arguments[1];
                if (arguments[2])
                  for (var l2 = 0; l2 < a2.length; l2++)
                    this.add(a2[l2], u2);
                else
                  for (var c2 = a2.length - 1; c2 >= 0; c2--)
                    this.add(a2[c2], u2);
                return true;
              }
              if ("boolean" == typeof arguments[2] && Number.isInteger(arguments[0]) && arguments[1] instanceof C) {
                var p2 = arguments[0], h2 = arguments[1];
                if (!arguments[2]) {
                  var f2 = this.size();
                  if (f2 > 0) {
                    if (p2 > 0) {
                      if (this.get(p2 - 1).equals2D(h2))
                        return null;
                    }
                    if (p2 < f2) {
                      if (this.get(p2).equals2D(h2))
                        return null;
                    }
                  }
                }
                t2.prototype.add.call(this, p2, h2);
              }
            } else if (4 === arguments.length) {
              var g2 = arguments[0], d2 = arguments[1], y3 = arguments[2], _2 = arguments[3], m2 = 1;
              y3 > _2 && (m2 = -1);
              for (var v2 = y3; v2 !== _2; v2 += m2)
                this.add(g2[v2], d2);
              return true;
            }
          }, e3.prototype.closeRing = function() {
            this.size() > 0 && this.add(new C(this.get(0)), false);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, Object.defineProperties(e3, n2), e3;
        }(Nt), Lt = function() {
        }, bt = { ForwardComparator: { configurable: true }, BidirectionalComparator: { configurable: true }, coordArrayType: { configurable: true } };
        bt.ForwardComparator.get = function() {
          return wt;
        }, bt.BidirectionalComparator.get = function() {
          return Ot;
        }, bt.coordArrayType.get = function() {
          return new Array(0).fill(null);
        }, Lt.prototype.interfaces_ = function() {
          return [];
        }, Lt.prototype.getClass = function() {
          return Lt;
        }, Lt.isRing = function(t2) {
          return !(t2.length < 4) && !!t2[0].equals2D(t2[t2.length - 1]);
        }, Lt.ptNotInList = function(t2, e3) {
          for (var n2 = 0; n2 < t2.length; n2++) {
            var i2 = t2[n2];
            if (Lt.indexOf(i2, e3) < 0)
              return i2;
          }
          return null;
        }, Lt.scroll = function(t2, e3) {
          var n2 = Lt.indexOf(e3, t2);
          if (n2 < 0)
            return null;
          var i2 = new Array(t2.length).fill(null);
          Y.arraycopy(t2, n2, i2, 0, t2.length - n2), Y.arraycopy(t2, 0, i2, t2.length - n2, n2), Y.arraycopy(i2, 0, t2, 0, t2.length);
        }, Lt.equals = function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            if (t2 === e3)
              return true;
            if (null === t2 || null === e3)
              return false;
            if (t2.length !== e3.length)
              return false;
            for (var n2 = 0; n2 < t2.length; n2++)
              if (!t2[n2].equals(e3[n2]))
                return false;
            return true;
          }
          if (3 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2];
            if (i2 === r2)
              return true;
            if (null === i2 || null === r2)
              return false;
            if (i2.length !== r2.length)
              return false;
            for (var s2 = 0; s2 < i2.length; s2++)
              if (0 !== o2.compare(i2[s2], r2[s2]))
                return false;
            return true;
          }
        }, Lt.intersection = function(t2, e3) {
          for (var n2 = new St(), i2 = 0; i2 < t2.length; i2++)
            e3.intersects(t2[i2]) && n2.add(t2[i2], true);
          return n2.toCoordinateArray();
        }, Lt.hasRepeatedPoints = function(t2) {
          for (var e3 = 1; e3 < t2.length; e3++)
            if (t2[e3 - 1].equals(t2[e3]))
              return true;
          return false;
        }, Lt.removeRepeatedPoints = function(t2) {
          if (!Lt.hasRepeatedPoints(t2))
            return t2;
          return new St(t2, false).toCoordinateArray();
        }, Lt.reverse = function(t2) {
          for (var e3 = t2.length - 1, n2 = Math.trunc(e3 / 2), i2 = 0; i2 <= n2; i2++) {
            var r2 = t2[i2];
            t2[i2] = t2[e3 - i2], t2[e3 - i2] = r2;
          }
        }, Lt.removeNull = function(t2) {
          for (var e3 = 0, n2 = 0; n2 < t2.length; n2++)
            null !== t2[n2] && e3++;
          var i2 = new Array(e3).fill(null);
          if (0 === e3)
            return i2;
          for (var r2 = 0, o2 = 0; o2 < t2.length; o2++)
            null !== t2[o2] && (i2[r2++] = t2[o2]);
          return i2;
        }, Lt.copyDeep = function() {
          if (1 === arguments.length) {
            for (var t2 = arguments[0], e3 = new Array(t2.length).fill(null), n2 = 0; n2 < t2.length; n2++)
              e3[n2] = new C(t2[n2]);
            return e3;
          }
          if (5 === arguments.length)
            for (var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2], s2 = arguments[3], a2 = arguments[4], u2 = 0; u2 < a2; u2++)
              o2[s2 + u2] = new C(i2[r2 + u2]);
        }, Lt.isEqualReversed = function(t2, e3) {
          for (var n2 = 0; n2 < t2.length; n2++) {
            var i2 = t2[n2], r2 = e3[t2.length - n2 - 1];
            if (0 !== i2.compareTo(r2))
              return false;
          }
          return true;
        }, Lt.envelope = function(t2) {
          for (var e3 = new j(), n2 = 0; n2 < t2.length; n2++)
            e3.expandToInclude(t2[n2]);
          return e3;
        }, Lt.toCoordinateArray = function(t2) {
          return t2.toArray(Lt.coordArrayType);
        }, Lt.atLeastNCoordinatesOrNothing = function(t2, e3) {
          return e3.length >= t2 ? e3 : [];
        }, Lt.indexOf = function(t2, e3) {
          for (var n2 = 0; n2 < e3.length; n2++)
            if (t2.equals(e3[n2]))
              return n2;
          return -1;
        }, Lt.increasingDirection = function(t2) {
          for (var e3 = 0; e3 < Math.trunc(t2.length / 2); e3++) {
            var n2 = t2.length - 1 - e3, i2 = t2[e3].compareTo(t2[n2]);
            if (0 !== i2)
              return i2;
          }
          return 1;
        }, Lt.compare = function(t2, e3) {
          for (var n2 = 0; n2 < t2.length && n2 < e3.length; ) {
            var i2 = t2[n2].compareTo(e3[n2]);
            if (0 !== i2)
              return i2;
            n2++;
          }
          return n2 < e3.length ? -1 : n2 < t2.length ? 1 : 0;
        }, Lt.minCoordinate = function(t2) {
          for (var e3 = null, n2 = 0; n2 < t2.length; n2++)
            (null === e3 || e3.compareTo(t2[n2]) > 0) && (e3 = t2[n2]);
          return e3;
        }, Lt.extract = function(t2, e3, n2) {
          e3 = R.clamp(e3, 0, t2.length);
          var i2 = (n2 = R.clamp(n2, -1, t2.length)) - e3 + 1;
          n2 < 0 && (i2 = 0), e3 >= t2.length && (i2 = 0), n2 < e3 && (i2 = 0);
          var r2 = new Array(i2).fill(null);
          if (0 === i2)
            return r2;
          for (var o2 = 0, s2 = e3; s2 <= n2; s2++)
            r2[o2++] = t2[s2];
          return r2;
        }, Object.defineProperties(Lt, bt);
        var wt = function() {
        };
        wt.prototype.compare = function(t2, e3) {
          return Lt.compare(t2, e3);
        }, wt.prototype.interfaces_ = function() {
          return [N];
        }, wt.prototype.getClass = function() {
          return wt;
        };
        var Ot = function() {
        };
        Ot.prototype.compare = function(t2, e3) {
          var n2 = t2, i2 = e3;
          if (n2.length < i2.length)
            return -1;
          if (n2.length > i2.length)
            return 1;
          if (0 === n2.length)
            return 0;
          var r2 = Lt.compare(n2, i2);
          return Lt.isEqualReversed(n2, i2) ? 0 : r2;
        }, Ot.prototype.OLDcompare = function(t2, e3) {
          var n2 = t2, i2 = e3;
          if (n2.length < i2.length)
            return -1;
          if (n2.length > i2.length)
            return 1;
          if (0 === n2.length)
            return 0;
          for (var r2 = Lt.increasingDirection(n2), o2 = Lt.increasingDirection(i2), s2 = r2 > 0 ? 0 : n2.length - 1, a2 = o2 > 0 ? 0 : n2.length - 1, u2 = 0; u2 < n2.length; u2++) {
            var l2 = n2[s2].compareTo(i2[a2]);
            if (0 !== l2)
              return l2;
            s2 += r2, a2 += o2;
          }
          return 0;
        }, Ot.prototype.interfaces_ = function() {
          return [N];
        }, Ot.prototype.getClass = function() {
          return Ot;
        };
        var Tt = function() {
        };
        Tt.prototype.get = function() {
        }, Tt.prototype.put = function() {
        }, Tt.prototype.size = function() {
        }, Tt.prototype.values = function() {
        }, Tt.prototype.entrySet = function() {
        };
        var Rt = function(t2) {
          function e3() {
            t2.apply(this, arguments);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3;
        }(Tt);
        (r.prototype = new Error()).name = "OperationNotSupported", (o.prototype = new It()).contains = function() {
        };
        var Pt = function(t2) {
          function e3() {
            t2.call(this), this.array_ = [], arguments[0] instanceof It && this.addAll(arguments[0]);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.contains = function(t3) {
            for (var e4 = 0, n2 = this.array_.length; e4 < n2; e4++) {
              if (this.array_[e4] === t3)
                return true;
            }
            return false;
          }, e3.prototype.add = function(t3) {
            return !this.contains(t3) && (this.array_.push(t3), true);
          }, e3.prototype.addAll = function(t3) {
            for (var e4 = t3.iterator(); e4.hasNext(); )
              this.add(e4.next());
            return true;
          }, e3.prototype.remove = function(t3) {
            throw new Error();
          }, e3.prototype.size = function() {
            return this.array_.length;
          }, e3.prototype.isEmpty = function() {
            return 0 === this.array_.length;
          }, e3.prototype.toArray = function() {
            for (var t3 = [], e4 = 0, n2 = this.array_.length; e4 < n2; e4++)
              t3.push(this.array_[e4]);
            return t3;
          }, e3.prototype.iterator = function() {
            return new Dt(this);
          }, e3;
        }(o), Dt = function(t2) {
          function e3(e4) {
            t2.call(this), this.hashSet_ = e4, this.position_ = 0;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.next = function() {
            if (this.position_ === this.hashSet_.size())
              throw new i();
            return this.hashSet_.array_[this.position_++];
          }, e3.prototype.hasNext = function() {
            return this.position_ < this.hashSet_.size();
          }, e3.prototype.remove = function() {
            throw new r();
          }, e3;
        }(Et), Mt = 0;
        (p.prototype = new Rt()).get = function(t2) {
          for (var e3 = this.root_; null !== e3; ) {
            var n2 = t2.compareTo(e3.key);
            if (n2 < 0)
              e3 = e3.left;
            else {
              if (!(n2 > 0))
                return e3.value;
              e3 = e3.right;
            }
          }
          return null;
        }, p.prototype.put = function(t2, e3) {
          if (null === this.root_)
            return this.root_ = { key: t2, value: e3, left: null, right: null, parent: null, color: Mt, getValue: function() {
              return this.value;
            }, getKey: function() {
              return this.key;
            } }, this.size_ = 1, null;
          var n2, i2, r2 = this.root_;
          do {
            if (n2 = r2, (i2 = t2.compareTo(r2.key)) < 0)
              r2 = r2.left;
            else {
              if (!(i2 > 0)) {
                var o2 = r2.value;
                return r2.value = e3, o2;
              }
              r2 = r2.right;
            }
          } while (null !== r2);
          var s2 = { key: t2, left: null, right: null, value: e3, parent: n2, color: Mt, getValue: function() {
            return this.value;
          }, getKey: function() {
            return this.key;
          } };
          return i2 < 0 ? n2.left = s2 : n2.right = s2, this.fixAfterInsertion(s2), this.size_++, null;
        }, p.prototype.fixAfterInsertion = function(t2) {
          for (t2.color = 1; null != t2 && t2 !== this.root_ && 1 === t2.parent.color; )
            if (a(t2) === l(a(a(t2)))) {
              var e3 = c(a(a(t2)));
              1 === s(e3) ? (u(a(t2), Mt), u(e3, Mt), u(a(a(t2)), 1), t2 = a(a(t2))) : (t2 === c(a(t2)) && (t2 = a(t2), this.rotateLeft(t2)), u(a(t2), Mt), u(a(a(t2)), 1), this.rotateRight(a(a(t2))));
            } else {
              var n2 = l(a(a(t2)));
              1 === s(n2) ? (u(a(t2), Mt), u(n2, Mt), u(a(a(t2)), 1), t2 = a(a(t2))) : (t2 === l(a(t2)) && (t2 = a(t2), this.rotateRight(t2)), u(a(t2), Mt), u(a(a(t2)), 1), this.rotateLeft(a(a(t2))));
            }
          this.root_.color = Mt;
        }, p.prototype.values = function() {
          var t2 = new Nt(), e3 = this.getFirstEntry();
          if (null !== e3)
            for (t2.add(e3.value); null !== (e3 = p.successor(e3)); )
              t2.add(e3.value);
          return t2;
        }, p.prototype.entrySet = function() {
          var t2 = new Pt(), e3 = this.getFirstEntry();
          if (null !== e3)
            for (t2.add(e3); null !== (e3 = p.successor(e3)); )
              t2.add(e3);
          return t2;
        }, p.prototype.rotateLeft = function(t2) {
          if (null != t2) {
            var e3 = t2.right;
            t2.right = e3.left, null != e3.left && (e3.left.parent = t2), e3.parent = t2.parent, null === t2.parent ? this.root_ = e3 : t2.parent.left === t2 ? t2.parent.left = e3 : t2.parent.right = e3, e3.left = t2, t2.parent = e3;
          }
        }, p.prototype.rotateRight = function(t2) {
          if (null != t2) {
            var e3 = t2.left;
            t2.left = e3.right, null != e3.right && (e3.right.parent = t2), e3.parent = t2.parent, null === t2.parent ? this.root_ = e3 : t2.parent.right === t2 ? t2.parent.right = e3 : t2.parent.left = e3, e3.right = t2, t2.parent = e3;
          }
        }, p.prototype.getFirstEntry = function() {
          var t2 = this.root_;
          if (null != t2)
            for (; null != t2.left; )
              t2 = t2.left;
          return t2;
        }, p.successor = function(t2) {
          if (null === t2)
            return null;
          if (null !== t2.right) {
            for (var e3 = t2.right; null !== e3.left; )
              e3 = e3.left;
            return e3;
          }
          for (var n2 = t2.parent, i2 = t2; null !== n2 && i2 === n2.right; )
            i2 = n2, n2 = n2.parent;
          return n2;
        }, p.prototype.size = function() {
          return this.size_;
        };
        var At = function() {
        };
        At.prototype.interfaces_ = function() {
          return [];
        }, At.prototype.getClass = function() {
          return At;
        }, h.prototype = new o(), (f.prototype = new h()).contains = function(t2) {
          for (var e3 = 0, n2 = this.array_.length; e3 < n2; e3++) {
            if (0 === this.array_[e3].compareTo(t2))
              return true;
          }
          return false;
        }, f.prototype.add = function(t2) {
          if (this.contains(t2))
            return false;
          for (var e3 = 0, n2 = this.array_.length; e3 < n2; e3++) {
            if (1 === this.array_[e3].compareTo(t2))
              return this.array_.splice(e3, 0, t2), true;
          }
          return this.array_.push(t2), true;
        }, f.prototype.addAll = function(t2) {
          for (var e3 = t2.iterator(); e3.hasNext(); )
            this.add(e3.next());
          return true;
        }, f.prototype.remove = function(t2) {
          throw new r();
        }, f.prototype.size = function() {
          return this.array_.length;
        }, f.prototype.isEmpty = function() {
          return 0 === this.array_.length;
        }, f.prototype.toArray = function() {
          for (var t2 = [], e3 = 0, n2 = this.array_.length; e3 < n2; e3++)
            t2.push(this.array_[e3]);
          return t2;
        }, f.prototype.iterator = function() {
          return new Ft(this);
        };
        var Ft = function(t2) {
          this.treeSet_ = t2, this.position_ = 0;
        };
        Ft.prototype.next = function() {
          if (this.position_ === this.treeSet_.size())
            throw new i();
          return this.treeSet_.array_[this.position_++];
        }, Ft.prototype.hasNext = function() {
          return this.position_ < this.treeSet_.size();
        }, Ft.prototype.remove = function() {
          throw new r();
        };
        var Gt = function() {
        };
        Gt.sort = function() {
          var t2, e3, n2, i2, r2 = arguments[0];
          if (1 === arguments.length)
            i2 = function(t3, e4) {
              return t3.compareTo(e4);
            }, r2.sort(i2);
          else if (2 === arguments.length)
            n2 = arguments[1], i2 = function(t3, e4) {
              return n2.compare(t3, e4);
            }, r2.sort(i2);
          else if (3 === arguments.length) {
            (e3 = r2.slice(arguments[1], arguments[2])).sort();
            var o2 = r2.slice(0, arguments[1]).concat(e3, r2.slice(arguments[2], r2.length));
            for (r2.splice(0, r2.length), t2 = 0; t2 < o2.length; t2++)
              r2.push(o2[t2]);
          } else if (4 === arguments.length)
            for (e3 = r2.slice(arguments[1], arguments[2]), n2 = arguments[3], i2 = function(t3, e4) {
              return n2.compare(t3, e4);
            }, e3.sort(i2), o2 = r2.slice(0, arguments[1]).concat(e3, r2.slice(arguments[2], r2.length)), r2.splice(0, r2.length), t2 = 0; t2 < o2.length; t2++)
              r2.push(o2[t2]);
        }, Gt.asList = function(t2) {
          for (var e3 = new Nt(), n2 = 0, i2 = t2.length; n2 < i2; n2++)
            e3.add(t2[n2]);
          return e3;
        };
        var qt = function() {
        }, Bt = { P: { configurable: true }, L: { configurable: true }, A: { configurable: true }, FALSE: { configurable: true }, TRUE: { configurable: true }, DONTCARE: { configurable: true }, SYM_FALSE: { configurable: true }, SYM_TRUE: { configurable: true }, SYM_DONTCARE: { configurable: true }, SYM_P: { configurable: true }, SYM_L: { configurable: true }, SYM_A: { configurable: true } };
        Bt.P.get = function() {
          return 0;
        }, Bt.L.get = function() {
          return 1;
        }, Bt.A.get = function() {
          return 2;
        }, Bt.FALSE.get = function() {
          return -1;
        }, Bt.TRUE.get = function() {
          return -2;
        }, Bt.DONTCARE.get = function() {
          return -3;
        }, Bt.SYM_FALSE.get = function() {
          return "F";
        }, Bt.SYM_TRUE.get = function() {
          return "T";
        }, Bt.SYM_DONTCARE.get = function() {
          return "*";
        }, Bt.SYM_P.get = function() {
          return "0";
        }, Bt.SYM_L.get = function() {
          return "1";
        }, Bt.SYM_A.get = function() {
          return "2";
        }, qt.prototype.interfaces_ = function() {
          return [];
        }, qt.prototype.getClass = function() {
          return qt;
        }, qt.toDimensionSymbol = function(t2) {
          switch (t2) {
            case qt.FALSE:
              return qt.SYM_FALSE;
            case qt.TRUE:
              return qt.SYM_TRUE;
            case qt.DONTCARE:
              return qt.SYM_DONTCARE;
            case qt.P:
              return qt.SYM_P;
            case qt.L:
              return qt.SYM_L;
            case qt.A:
              return qt.SYM_A;
          }
          throw new m("Unknown dimension value: " + t2);
        }, qt.toDimensionValue = function(t2) {
          switch (A.toUpperCase(t2)) {
            case qt.SYM_FALSE:
              return qt.FALSE;
            case qt.SYM_TRUE:
              return qt.TRUE;
            case qt.SYM_DONTCARE:
              return qt.DONTCARE;
            case qt.SYM_P:
              return qt.P;
            case qt.SYM_L:
              return qt.L;
            case qt.SYM_A:
              return qt.A;
          }
          throw new m("Unknown dimension symbol: " + t2);
        }, Object.defineProperties(qt, Bt);
        var Vt = function() {
        };
        Vt.prototype.filter = function(t2) {
        }, Vt.prototype.interfaces_ = function() {
          return [];
        }, Vt.prototype.getClass = function() {
          return Vt;
        };
        var Ut = function() {
        };
        Ut.prototype.filter = function(t2, e3) {
        }, Ut.prototype.isDone = function() {
        }, Ut.prototype.isGeometryChanged = function() {
        }, Ut.prototype.interfaces_ = function() {
          return [];
        }, Ut.prototype.getClass = function() {
          return Ut;
        };
        var zt = function(t2) {
          function e3(e4, n3) {
            if (t2.call(this, n3), this._geometries = e4 || [], t2.hasNullElements(this._geometries))
              throw new m("geometries must not contain null elements");
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { serialVersionUID: { configurable: true } };
          return e3.prototype.computeEnvelopeInternal = function() {
            for (var t3 = new j(), e4 = 0; e4 < this._geometries.length; e4++)
              t3.expandToInclude(this._geometries[e4].getEnvelopeInternal());
            return t3;
          }, e3.prototype.getGeometryN = function(t3) {
            return this._geometries[t3];
          }, e3.prototype.getSortIndex = function() {
            return t2.SORTINDEX_GEOMETRYCOLLECTION;
          }, e3.prototype.getCoordinates = function() {
            for (var t3 = new Array(this.getNumPoints()).fill(null), e4 = -1, n3 = 0; n3 < this._geometries.length; n3++)
              for (var i2 = this._geometries[n3].getCoordinates(), r2 = 0; r2 < i2.length; r2++)
                t3[++e4] = i2[r2];
            return t3;
          }, e3.prototype.getArea = function() {
            for (var t3 = 0, e4 = 0; e4 < this._geometries.length; e4++)
              t3 += this._geometries[e4].getArea();
            return t3;
          }, e3.prototype.equalsExact = function() {
            if (2 === arguments.length) {
              var e4 = arguments[0], n3 = arguments[1];
              if (!this.isEquivalentClass(e4))
                return false;
              var i2 = e4;
              if (this._geometries.length !== i2._geometries.length)
                return false;
              for (var r2 = 0; r2 < this._geometries.length; r2++)
                if (!this._geometries[r2].equalsExact(i2._geometries[r2], n3))
                  return false;
              return true;
            }
            return t2.prototype.equalsExact.apply(this, arguments);
          }, e3.prototype.normalize = function() {
            for (var t3 = 0; t3 < this._geometries.length; t3++)
              this._geometries[t3].normalize();
            Gt.sort(this._geometries);
          }, e3.prototype.getCoordinate = function() {
            return this.isEmpty() ? null : this._geometries[0].getCoordinate();
          }, e3.prototype.getBoundaryDimension = function() {
            for (var t3 = qt.FALSE, e4 = 0; e4 < this._geometries.length; e4++)
              t3 = Math.max(t3, this._geometries[e4].getBoundaryDimension());
            return t3;
          }, e3.prototype.getDimension = function() {
            for (var t3 = qt.FALSE, e4 = 0; e4 < this._geometries.length; e4++)
              t3 = Math.max(t3, this._geometries[e4].getDimension());
            return t3;
          }, e3.prototype.getLength = function() {
            for (var t3 = 0, e4 = 0; e4 < this._geometries.length; e4++)
              t3 += this._geometries[e4].getLength();
            return t3;
          }, e3.prototype.getNumPoints = function() {
            for (var t3 = 0, e4 = 0; e4 < this._geometries.length; e4++)
              t3 += this._geometries[e4].getNumPoints();
            return t3;
          }, e3.prototype.getNumGeometries = function() {
            return this._geometries.length;
          }, e3.prototype.reverse = function() {
            for (var t3 = this._geometries.length, e4 = new Array(t3).fill(null), n3 = 0; n3 < this._geometries.length; n3++)
              e4[n3] = this._geometries[n3].reverse();
            return this.getFactory().createGeometryCollection(e4);
          }, e3.prototype.compareToSameClass = function() {
            if (1 === arguments.length) {
              var t3 = arguments[0], e4 = new f(Gt.asList(this._geometries)), n3 = new f(Gt.asList(t3._geometries));
              return this.compare(e4, n3);
            }
            if (2 === arguments.length) {
              for (var i2 = arguments[0], r2 = arguments[1], o2 = i2, s2 = this.getNumGeometries(), a2 = o2.getNumGeometries(), u2 = 0; u2 < s2 && u2 < a2; ) {
                var l2 = this.getGeometryN(u2), c2 = o2.getGeometryN(u2), p2 = l2.compareToSameClass(c2, r2);
                if (0 !== p2)
                  return p2;
                u2++;
              }
              return u2 < s2 ? 1 : u2 < a2 ? -1 : 0;
            }
          }, e3.prototype.apply = function() {
            if (T(arguments[0], ft))
              for (var t3 = arguments[0], e4 = 0; e4 < this._geometries.length; e4++)
                this._geometries[e4].apply(t3);
            else if (T(arguments[0], Ut)) {
              var n3 = arguments[0];
              if (0 === this._geometries.length)
                return null;
              for (var i2 = 0; i2 < this._geometries.length && (this._geometries[i2].apply(n3), !n3.isDone()); i2++)
                ;
              n3.isGeometryChanged() && this.geometryChanged();
            } else if (T(arguments[0], Vt)) {
              var r2 = arguments[0];
              r2.filter(this);
              for (var o2 = 0; o2 < this._geometries.length; o2++)
                this._geometries[o2].apply(r2);
            } else if (T(arguments[0], lt)) {
              var s2 = arguments[0];
              s2.filter(this);
              for (var a2 = 0; a2 < this._geometries.length; a2++)
                this._geometries[a2].apply(s2);
            }
          }, e3.prototype.getBoundary = function() {
            return this.checkNotGeometryCollection(this), et.shouldNeverReachHere(), null;
          }, e3.prototype.clone = function() {
            var e4 = t2.prototype.clone.call(this);
            e4._geometries = new Array(this._geometries.length).fill(null);
            for (var n3 = 0; n3 < this._geometries.length; n3++)
              e4._geometries[n3] = this._geometries[n3].clone();
            return e4;
          }, e3.prototype.getGeometryType = function() {
            return "GeometryCollection";
          }, e3.prototype.copy = function() {
            for (var t3 = new Array(this._geometries.length).fill(null), n3 = 0; n3 < t3.length; n3++)
              t3[n3] = this._geometries[n3].copy();
            return new e3(t3, this._factory);
          }, e3.prototype.isEmpty = function() {
            for (var t3 = 0; t3 < this._geometries.length; t3++)
              if (!this._geometries[t3].isEmpty())
                return false;
            return true;
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.serialVersionUID.get = function() {
            return -5694727726395021e3;
          }, Object.defineProperties(e3, n2), e3;
        }(ct), Xt = function(t2) {
          function e3() {
            t2.apply(this, arguments);
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { serialVersionUID: { configurable: true } };
          return e3.prototype.getSortIndex = function() {
            return ct.SORTINDEX_MULTILINESTRING;
          }, e3.prototype.equalsExact = function() {
            if (2 === arguments.length) {
              var e4 = arguments[0], n3 = arguments[1];
              return !!this.isEquivalentClass(e4) && t2.prototype.equalsExact.call(this, e4, n3);
            }
            return t2.prototype.equalsExact.apply(this, arguments);
          }, e3.prototype.getBoundaryDimension = function() {
            return this.isClosed() ? qt.FALSE : 0;
          }, e3.prototype.isClosed = function() {
            if (this.isEmpty())
              return false;
            for (var t3 = 0; t3 < this._geometries.length; t3++)
              if (!this._geometries[t3].isClosed())
                return false;
            return true;
          }, e3.prototype.getDimension = function() {
            return 1;
          }, e3.prototype.reverse = function() {
            for (var t3 = this._geometries.length, e4 = new Array(t3).fill(null), n3 = 0; n3 < this._geometries.length; n3++)
              e4[t3 - 1 - n3] = this._geometries[n3].reverse();
            return this.getFactory().createMultiLineString(e4);
          }, e3.prototype.getBoundary = function() {
            return new Yt(this).getBoundary();
          }, e3.prototype.getGeometryType = function() {
            return "MultiLineString";
          }, e3.prototype.copy = function() {
            for (var t3 = new Array(this._geometries.length).fill(null), n3 = 0; n3 < t3.length; n3++)
              t3[n3] = this._geometries[n3].copy();
            return new e3(t3, this._factory);
          }, e3.prototype.interfaces_ = function() {
            return [At];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.serialVersionUID.get = function() {
            return 8166665132445434e3;
          }, Object.defineProperties(e3, n2), e3;
        }(zt), Yt = function() {
          if (this._geom = null, this._geomFact = null, this._bnRule = null, this._endpointMap = null, 1 === arguments.length) {
            var t2 = arguments[0], e3 = gt.MOD2_BOUNDARY_RULE;
            this._geom = t2, this._geomFact = t2.getFactory(), this._bnRule = e3;
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            this._geom = n2, this._geomFact = n2.getFactory(), this._bnRule = i2;
          }
        };
        Yt.prototype.boundaryMultiLineString = function(t2) {
          if (this._geom.isEmpty())
            return this.getEmptyMultiPoint();
          var e3 = this.computeBoundaryCoordinates(t2);
          return 1 === e3.length ? this._geomFact.createPoint(e3[0]) : this._geomFact.createMultiPointFromCoords(e3);
        }, Yt.prototype.getBoundary = function() {
          return this._geom instanceof Kt ? this.boundaryLineString(this._geom) : this._geom instanceof Xt ? this.boundaryMultiLineString(this._geom) : this._geom.getBoundary();
        }, Yt.prototype.boundaryLineString = function(t2) {
          if (this._geom.isEmpty())
            return this.getEmptyMultiPoint();
          if (t2.isClosed()) {
            return this._bnRule.isInBoundary(2) ? t2.getStartPoint() : this._geomFact.createMultiPoint();
          }
          return this._geomFact.createMultiPoint([t2.getStartPoint(), t2.getEndPoint()]);
        }, Yt.prototype.getEmptyMultiPoint = function() {
          return this._geomFact.createMultiPoint();
        }, Yt.prototype.computeBoundaryCoordinates = function(t2) {
          var e3 = new Nt();
          this._endpointMap = new p();
          for (var n2 = 0; n2 < t2.getNumGeometries(); n2++) {
            var i2 = t2.getGeometryN(n2);
            0 !== i2.getNumPoints() && (this.addEndpoint(i2.getCoordinateN(0)), this.addEndpoint(i2.getCoordinateN(i2.getNumPoints() - 1)));
          }
          for (var r2 = this._endpointMap.entrySet().iterator(); r2.hasNext(); ) {
            var o2 = r2.next(), s2 = o2.getValue().count;
            this._bnRule.isInBoundary(s2) && e3.add(o2.getKey());
          }
          return Lt.toCoordinateArray(e3);
        }, Yt.prototype.addEndpoint = function(t2) {
          var e3 = this._endpointMap.get(t2);
          null === e3 && (e3 = new kt(), this._endpointMap.put(t2, e3)), e3.count++;
        }, Yt.prototype.interfaces_ = function() {
          return [];
        }, Yt.prototype.getClass = function() {
          return Yt;
        }, Yt.getBoundary = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return new Yt(t2).getBoundary();
          }
          if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            return new Yt(e3, n2).getBoundary();
          }
        };
        var kt = function() {
          this.count = null;
        };
        kt.prototype.interfaces_ = function() {
          return [];
        }, kt.prototype.getClass = function() {
          return kt;
        };
        var jt = function() {
        }, Ht = { NEWLINE: { configurable: true }, SIMPLE_ORDINATE_FORMAT: { configurable: true } };
        jt.prototype.interfaces_ = function() {
          return [];
        }, jt.prototype.getClass = function() {
          return jt;
        }, jt.chars = function(t2, e3) {
          for (var n2 = new Array(e3).fill(null), i2 = 0; i2 < e3; i2++)
            n2[i2] = t2;
          return String(n2);
        }, jt.getStackTrace = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0], e3 = new function() {
            }(), n2 = new function() {
            }(e3);
            return t2.printStackTrace(n2), e3.toString();
          }
          if (2 === arguments.length) {
            for (var i2 = arguments[0], r2 = arguments[1], o2 = "", s2 = new function() {
            }(new function() {
            }(jt.getStackTrace(i2))), a2 = 0; a2 < r2; a2++)
              try {
                o2 += s2.readLine() + jt.NEWLINE;
              } catch (t3) {
                if (!(t3 instanceof g))
                  throw t3;
                et.shouldNeverReachHere();
              }
            return o2;
          }
        }, jt.split = function(t2, e3) {
          for (var n2 = e3.length, i2 = new Nt(), r2 = "" + t2, o2 = r2.indexOf(e3); o2 >= 0; ) {
            var s2 = r2.substring(0, o2);
            i2.add(s2), o2 = (r2 = r2.substring(o2 + n2)).indexOf(e3);
          }
          r2.length > 0 && i2.add(r2);
          for (var a2 = new Array(i2.size()).fill(null), u2 = 0; u2 < a2.length; u2++)
            a2[u2] = i2.get(u2);
          return a2;
        }, jt.toString = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return jt.SIMPLE_ORDINATE_FORMAT.format(t2);
          }
        }, jt.spaces = function(t2) {
          return jt.chars(" ", t2);
        }, Ht.NEWLINE.get = function() {
          return Y.getProperty("line.separator");
        }, Ht.SIMPLE_ORDINATE_FORMAT.get = function() {
          return new function() {
          }("0.#");
        }, Object.defineProperties(jt, Ht);
        var Wt = function() {
        };
        Wt.prototype.interfaces_ = function() {
          return [];
        }, Wt.prototype.getClass = function() {
          return Wt;
        }, Wt.copyCoord = function(t2, e3, n2, i2) {
          for (var r2 = Math.min(t2.getDimension(), n2.getDimension()), o2 = 0; o2 < r2; o2++)
            n2.setOrdinate(i2, o2, t2.getOrdinate(e3, o2));
        }, Wt.isRing = function(t2) {
          var e3 = t2.size();
          return 0 === e3 || !(e3 <= 3) && (t2.getOrdinate(0, V.X) === t2.getOrdinate(e3 - 1, V.X) && t2.getOrdinate(0, V.Y) === t2.getOrdinate(e3 - 1, V.Y));
        }, Wt.isEqual = function(t2, e3) {
          var n2 = t2.size();
          if (n2 !== e3.size())
            return false;
          for (var i2 = Math.min(t2.getDimension(), e3.getDimension()), r2 = 0; r2 < n2; r2++)
            for (var o2 = 0; o2 < i2; o2++) {
              var s2 = t2.getOrdinate(r2, o2), a2 = e3.getOrdinate(r2, o2);
              if (t2.getOrdinate(r2, o2) !== e3.getOrdinate(r2, o2) && (!v.isNaN(s2) || !v.isNaN(a2)))
                return false;
            }
          return true;
        }, Wt.extend = function(t2, e3, n2) {
          var i2 = t2.create(n2, e3.getDimension()), r2 = e3.size();
          if (Wt.copy(e3, 0, i2, 0, r2), r2 > 0)
            for (var o2 = r2; o2 < n2; o2++)
              Wt.copy(e3, r2 - 1, i2, o2, 1);
          return i2;
        }, Wt.reverse = function(t2) {
          for (var e3 = t2.size() - 1, n2 = Math.trunc(e3 / 2), i2 = 0; i2 <= n2; i2++)
            Wt.swap(t2, i2, e3 - i2);
        }, Wt.swap = function(t2, e3, n2) {
          if (e3 === n2)
            return null;
          for (var i2 = 0; i2 < t2.getDimension(); i2++) {
            var r2 = t2.getOrdinate(e3, i2);
            t2.setOrdinate(e3, i2, t2.getOrdinate(n2, i2)), t2.setOrdinate(n2, i2, r2);
          }
        }, Wt.copy = function(t2, e3, n2, i2, r2) {
          for (var o2 = 0; o2 < r2; o2++)
            Wt.copyCoord(t2, e3 + o2, n2, i2 + o2);
        }, Wt.toString = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0], e3 = t2.size();
            if (0 === e3)
              return "()";
            var n2 = t2.getDimension(), i2 = new D();
            i2.append("(");
            for (var r2 = 0; r2 < e3; r2++) {
              r2 > 0 && i2.append(" ");
              for (var o2 = 0; o2 < n2; o2++)
                o2 > 0 && i2.append(","), i2.append(jt.toString(t2.getOrdinate(r2, o2)));
            }
            return i2.append(")"), i2.toString();
          }
        }, Wt.ensureValidRing = function(t2, e3) {
          var n2 = e3.size();
          if (0 === n2)
            return e3;
          if (n2 <= 3)
            return Wt.createClosedRing(t2, e3, 4);
          return e3.getOrdinate(0, V.X) === e3.getOrdinate(n2 - 1, V.X) && e3.getOrdinate(0, V.Y) === e3.getOrdinate(n2 - 1, V.Y) ? e3 : Wt.createClosedRing(t2, e3, n2 + 1);
        }, Wt.createClosedRing = function(t2, e3, n2) {
          var i2 = t2.create(n2, e3.getDimension()), r2 = e3.size();
          Wt.copy(e3, 0, i2, 0, r2);
          for (var o2 = r2; o2 < n2; o2++)
            Wt.copy(e3, 0, i2, o2, 1);
          return i2;
        };
        var Kt = function(t2) {
          function e3(e4, n3) {
            t2.call(this, n3), this._points = null, this.init(e4);
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { serialVersionUID: { configurable: true } };
          return e3.prototype.computeEnvelopeInternal = function() {
            return this.isEmpty() ? new j() : this._points.expandEnvelope(new j());
          }, e3.prototype.isRing = function() {
            return this.isClosed() && this.isSimple();
          }, e3.prototype.getSortIndex = function() {
            return t2.SORTINDEX_LINESTRING;
          }, e3.prototype.getCoordinates = function() {
            return this._points.toCoordinateArray();
          }, e3.prototype.equalsExact = function() {
            if (2 === arguments.length) {
              var e4 = arguments[0], n3 = arguments[1];
              if (!this.isEquivalentClass(e4))
                return false;
              var i2 = e4;
              if (this._points.size() !== i2._points.size())
                return false;
              for (var r2 = 0; r2 < this._points.size(); r2++)
                if (!this.equal(this._points.getCoordinate(r2), i2._points.getCoordinate(r2), n3))
                  return false;
              return true;
            }
            return t2.prototype.equalsExact.apply(this, arguments);
          }, e3.prototype.normalize = function() {
            for (var t3 = 0; t3 < Math.trunc(this._points.size() / 2); t3++) {
              var e4 = this._points.size() - 1 - t3;
              if (!this._points.getCoordinate(t3).equals(this._points.getCoordinate(e4)))
                return this._points.getCoordinate(t3).compareTo(this._points.getCoordinate(e4)) > 0 && Wt.reverse(this._points), null;
            }
          }, e3.prototype.getCoordinate = function() {
            return this.isEmpty() ? null : this._points.getCoordinate(0);
          }, e3.prototype.getBoundaryDimension = function() {
            return this.isClosed() ? qt.FALSE : 0;
          }, e3.prototype.isClosed = function() {
            return !this.isEmpty() && this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));
          }, e3.prototype.getEndPoint = function() {
            return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1);
          }, e3.prototype.getDimension = function() {
            return 1;
          }, e3.prototype.getLength = function() {
            return at.computeLength(this._points);
          }, e3.prototype.getNumPoints = function() {
            return this._points.size();
          }, e3.prototype.reverse = function() {
            var t3 = this._points.copy();
            Wt.reverse(t3);
            return this.getFactory().createLineString(t3);
          }, e3.prototype.compareToSameClass = function() {
            if (1 === arguments.length) {
              for (var t3 = arguments[0], e4 = 0, n3 = 0; e4 < this._points.size() && n3 < t3._points.size(); ) {
                var i2 = this._points.getCoordinate(e4).compareTo(t3._points.getCoordinate(n3));
                if (0 !== i2)
                  return i2;
                e4++, n3++;
              }
              return e4 < this._points.size() ? 1 : n3 < t3._points.size() ? -1 : 0;
            }
            if (2 === arguments.length) {
              var r2 = arguments[0];
              return arguments[1].compare(this._points, r2._points);
            }
          }, e3.prototype.apply = function() {
            if (T(arguments[0], ft))
              for (var t3 = arguments[0], e4 = 0; e4 < this._points.size(); e4++)
                t3.filter(this._points.getCoordinate(e4));
            else if (T(arguments[0], Ut)) {
              var n3 = arguments[0];
              if (0 === this._points.size())
                return null;
              for (var i2 = 0; i2 < this._points.size() && (n3.filter(this._points, i2), !n3.isDone()); i2++)
                ;
              n3.isGeometryChanged() && this.geometryChanged();
            } else if (T(arguments[0], Vt)) {
              arguments[0].filter(this);
            } else if (T(arguments[0], lt)) {
              arguments[0].filter(this);
            }
          }, e3.prototype.getBoundary = function() {
            return new Yt(this).getBoundary();
          }, e3.prototype.isEquivalentClass = function(t3) {
            return t3 instanceof e3;
          }, e3.prototype.clone = function() {
            var e4 = t2.prototype.clone.call(this);
            return e4._points = this._points.clone(), e4;
          }, e3.prototype.getCoordinateN = function(t3) {
            return this._points.getCoordinate(t3);
          }, e3.prototype.getGeometryType = function() {
            return "LineString";
          }, e3.prototype.copy = function() {
            return new e3(this._points.copy(), this._factory);
          }, e3.prototype.getCoordinateSequence = function() {
            return this._points;
          }, e3.prototype.isEmpty = function() {
            return 0 === this._points.size();
          }, e3.prototype.init = function(t3) {
            if (null === t3 && (t3 = this.getFactory().getCoordinateSequenceFactory().create([])), 1 === t3.size())
              throw new m("Invalid number of points in LineString (found " + t3.size() + " - must be 0 or >= 2)");
            this._points = t3;
          }, e3.prototype.isCoordinate = function(t3) {
            for (var e4 = 0; e4 < this._points.size(); e4++)
              if (this._points.getCoordinate(e4).equals(t3))
                return true;
            return false;
          }, e3.prototype.getStartPoint = function() {
            return this.isEmpty() ? null : this.getPointN(0);
          }, e3.prototype.getPointN = function(t3) {
            return this.getFactory().createPoint(this._points.getCoordinate(t3));
          }, e3.prototype.interfaces_ = function() {
            return [At];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.serialVersionUID.get = function() {
            return 3110669828065365500;
          }, Object.defineProperties(e3, n2), e3;
        }(ct), Jt = function() {
        };
        Jt.prototype.interfaces_ = function() {
          return [];
        }, Jt.prototype.getClass = function() {
          return Jt;
        };
        var Qt = function(t2) {
          function e3(e4, n3) {
            t2.call(this, n3), this._coordinates = e4 || null, this.init(this._coordinates);
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { serialVersionUID: { configurable: true } };
          return e3.prototype.computeEnvelopeInternal = function() {
            if (this.isEmpty())
              return new j();
            var t3 = new j();
            return t3.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0)), t3;
          }, e3.prototype.getSortIndex = function() {
            return t2.SORTINDEX_POINT;
          }, e3.prototype.getCoordinates = function() {
            return this.isEmpty() ? [] : [this.getCoordinate()];
          }, e3.prototype.equalsExact = function() {
            if (2 === arguments.length) {
              var e4 = arguments[0], n3 = arguments[1];
              return !!this.isEquivalentClass(e4) && (!(!this.isEmpty() || !e4.isEmpty()) || this.isEmpty() === e4.isEmpty() && this.equal(e4.getCoordinate(), this.getCoordinate(), n3));
            }
            return t2.prototype.equalsExact.apply(this, arguments);
          }, e3.prototype.normalize = function() {
          }, e3.prototype.getCoordinate = function() {
            return 0 !== this._coordinates.size() ? this._coordinates.getCoordinate(0) : null;
          }, e3.prototype.getBoundaryDimension = function() {
            return qt.FALSE;
          }, e3.prototype.getDimension = function() {
            return 0;
          }, e3.prototype.getNumPoints = function() {
            return this.isEmpty() ? 0 : 1;
          }, e3.prototype.reverse = function() {
            return this.copy();
          }, e3.prototype.getX = function() {
            if (null === this.getCoordinate())
              throw new Error("getX called on empty Point");
            return this.getCoordinate().x;
          }, e3.prototype.compareToSameClass = function() {
            if (1 === arguments.length) {
              var t3 = arguments[0];
              return this.getCoordinate().compareTo(t3.getCoordinate());
            }
            if (2 === arguments.length) {
              var e4 = arguments[0];
              return arguments[1].compare(this._coordinates, e4._coordinates);
            }
          }, e3.prototype.apply = function() {
            if (T(arguments[0], ft)) {
              var t3 = arguments[0];
              if (this.isEmpty())
                return null;
              t3.filter(this.getCoordinate());
            } else if (T(arguments[0], Ut)) {
              var e4 = arguments[0];
              if (this.isEmpty())
                return null;
              e4.filter(this._coordinates, 0), e4.isGeometryChanged() && this.geometryChanged();
            } else if (T(arguments[0], Vt)) {
              arguments[0].filter(this);
            } else if (T(arguments[0], lt)) {
              arguments[0].filter(this);
            }
          }, e3.prototype.getBoundary = function() {
            return this.getFactory().createGeometryCollection(null);
          }, e3.prototype.clone = function() {
            var e4 = t2.prototype.clone.call(this);
            return e4._coordinates = this._coordinates.clone(), e4;
          }, e3.prototype.getGeometryType = function() {
            return "Point";
          }, e3.prototype.copy = function() {
            return new e3(this._coordinates.copy(), this._factory);
          }, e3.prototype.getCoordinateSequence = function() {
            return this._coordinates;
          }, e3.prototype.getY = function() {
            if (null === this.getCoordinate())
              throw new Error("getY called on empty Point");
            return this.getCoordinate().y;
          }, e3.prototype.isEmpty = function() {
            return 0 === this._coordinates.size();
          }, e3.prototype.init = function(t3) {
            null === t3 && (t3 = this.getFactory().getCoordinateSequenceFactory().create([])), et.isTrue(t3.size() <= 1), this._coordinates = t3;
          }, e3.prototype.isSimple = function() {
            return true;
          }, e3.prototype.interfaces_ = function() {
            return [Jt];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.serialVersionUID.get = function() {
            return 4902022702746615e3;
          }, Object.defineProperties(e3, n2), e3;
        }(ct), Zt = function() {
        };
        Zt.prototype.interfaces_ = function() {
          return [];
        }, Zt.prototype.getClass = function() {
          return Zt;
        };
        var $t = function(t2) {
          function e3(e4, n3, i2) {
            if (t2.call(this, i2), this._shell = null, this._holes = null, null === e4 && (e4 = this.getFactory().createLinearRing()), null === n3 && (n3 = []), t2.hasNullElements(n3))
              throw new m("holes must not contain null elements");
            if (e4.isEmpty() && t2.hasNonEmptyElements(n3))
              throw new m("shell is empty but holes are not");
            this._shell = e4, this._holes = n3;
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { serialVersionUID: { configurable: true } };
          return e3.prototype.computeEnvelopeInternal = function() {
            return this._shell.getEnvelopeInternal();
          }, e3.prototype.getSortIndex = function() {
            return t2.SORTINDEX_POLYGON;
          }, e3.prototype.getCoordinates = function() {
            if (this.isEmpty())
              return [];
            for (var t3 = new Array(this.getNumPoints()).fill(null), e4 = -1, n3 = this._shell.getCoordinates(), i2 = 0; i2 < n3.length; i2++)
              t3[++e4] = n3[i2];
            for (var r2 = 0; r2 < this._holes.length; r2++)
              for (var o2 = this._holes[r2].getCoordinates(), s2 = 0; s2 < o2.length; s2++)
                t3[++e4] = o2[s2];
            return t3;
          }, e3.prototype.getArea = function() {
            var t3 = 0;
            t3 += Math.abs(at.signedArea(this._shell.getCoordinateSequence()));
            for (var e4 = 0; e4 < this._holes.length; e4++)
              t3 -= Math.abs(at.signedArea(this._holes[e4].getCoordinateSequence()));
            return t3;
          }, e3.prototype.isRectangle = function() {
            if (0 !== this.getNumInteriorRing())
              return false;
            if (null === this._shell)
              return false;
            if (5 !== this._shell.getNumPoints())
              return false;
            for (var t3 = this._shell.getCoordinateSequence(), e4 = this.getEnvelopeInternal(), n3 = 0; n3 < 5; n3++) {
              var i2 = t3.getX(n3);
              if (i2 !== e4.getMinX() && i2 !== e4.getMaxX())
                return false;
              var r2 = t3.getY(n3);
              if (r2 !== e4.getMinY() && r2 !== e4.getMaxY())
                return false;
            }
            for (var o2 = t3.getX(0), s2 = t3.getY(0), a2 = 1; a2 <= 4; a2++) {
              var u2 = t3.getX(a2), l2 = t3.getY(a2);
              if (u2 !== o2 === (l2 !== s2))
                return false;
              o2 = u2, s2 = l2;
            }
            return true;
          }, e3.prototype.equalsExact = function() {
            if (2 === arguments.length) {
              var e4 = arguments[0], n3 = arguments[1];
              if (!this.isEquivalentClass(e4))
                return false;
              var i2 = e4, r2 = this._shell, o2 = i2._shell;
              if (!r2.equalsExact(o2, n3))
                return false;
              if (this._holes.length !== i2._holes.length)
                return false;
              for (var s2 = 0; s2 < this._holes.length; s2++)
                if (!this._holes[s2].equalsExact(i2._holes[s2], n3))
                  return false;
              return true;
            }
            return t2.prototype.equalsExact.apply(this, arguments);
          }, e3.prototype.normalize = function() {
            if (0 === arguments.length) {
              this.normalize(this._shell, true);
              for (var t3 = 0; t3 < this._holes.length; t3++)
                this.normalize(this._holes[t3], false);
              Gt.sort(this._holes);
            } else if (2 === arguments.length) {
              var e4 = arguments[0], n3 = arguments[1];
              if (e4.isEmpty())
                return null;
              var i2 = new Array(e4.getCoordinates().length - 1).fill(null);
              Y.arraycopy(e4.getCoordinates(), 0, i2, 0, i2.length);
              var r2 = Lt.minCoordinate(e4.getCoordinates());
              Lt.scroll(i2, r2), Y.arraycopy(i2, 0, e4.getCoordinates(), 0, i2.length), e4.getCoordinates()[i2.length] = i2[0], at.isCCW(e4.getCoordinates()) === n3 && Lt.reverse(e4.getCoordinates());
            }
          }, e3.prototype.getCoordinate = function() {
            return this._shell.getCoordinate();
          }, e3.prototype.getNumInteriorRing = function() {
            return this._holes.length;
          }, e3.prototype.getBoundaryDimension = function() {
            return 1;
          }, e3.prototype.getDimension = function() {
            return 2;
          }, e3.prototype.getLength = function() {
            var t3 = 0;
            t3 += this._shell.getLength();
            for (var e4 = 0; e4 < this._holes.length; e4++)
              t3 += this._holes[e4].getLength();
            return t3;
          }, e3.prototype.getNumPoints = function() {
            for (var t3 = this._shell.getNumPoints(), e4 = 0; e4 < this._holes.length; e4++)
              t3 += this._holes[e4].getNumPoints();
            return t3;
          }, e3.prototype.reverse = function() {
            var t3 = this.copy();
            t3._shell = this._shell.copy().reverse(), t3._holes = new Array(this._holes.length).fill(null);
            for (var e4 = 0; e4 < this._holes.length; e4++)
              t3._holes[e4] = this._holes[e4].copy().reverse();
            return t3;
          }, e3.prototype.convexHull = function() {
            return this.getExteriorRing().convexHull();
          }, e3.prototype.compareToSameClass = function() {
            if (1 === arguments.length) {
              var t3 = arguments[0], e4 = this._shell, n3 = t3._shell;
              return e4.compareToSameClass(n3);
            }
            if (2 === arguments.length) {
              var i2 = arguments[0], r2 = arguments[1], o2 = i2, s2 = this._shell, a2 = o2._shell, u2 = s2.compareToSameClass(a2, r2);
              if (0 !== u2)
                return u2;
              for (var l2 = this.getNumInteriorRing(), c2 = o2.getNumInteriorRing(), p2 = 0; p2 < l2 && p2 < c2; ) {
                var h2 = this.getInteriorRingN(p2), f2 = o2.getInteriorRingN(p2), g2 = h2.compareToSameClass(f2, r2);
                if (0 !== g2)
                  return g2;
                p2++;
              }
              return p2 < l2 ? 1 : p2 < c2 ? -1 : 0;
            }
          }, e3.prototype.apply = function(t3) {
            if (T(t3, ft)) {
              this._shell.apply(t3);
              for (var e4 = 0; e4 < this._holes.length; e4++)
                this._holes[e4].apply(t3);
            } else if (T(t3, Ut)) {
              if (this._shell.apply(t3), !t3.isDone())
                for (var n3 = 0; n3 < this._holes.length && (this._holes[n3].apply(t3), !t3.isDone()); n3++)
                  ;
              t3.isGeometryChanged() && this.geometryChanged();
            } else if (T(t3, Vt))
              t3.filter(this);
            else if (T(t3, lt)) {
              t3.filter(this), this._shell.apply(t3);
              for (var i2 = 0; i2 < this._holes.length; i2++)
                this._holes[i2].apply(t3);
            }
          }, e3.prototype.getBoundary = function() {
            if (this.isEmpty())
              return this.getFactory().createMultiLineString();
            var t3 = new Array(this._holes.length + 1).fill(null);
            t3[0] = this._shell;
            for (var e4 = 0; e4 < this._holes.length; e4++)
              t3[e4 + 1] = this._holes[e4];
            return t3.length <= 1 ? this.getFactory().createLinearRing(t3[0].getCoordinateSequence()) : this.getFactory().createMultiLineString(t3);
          }, e3.prototype.clone = function() {
            var e4 = t2.prototype.clone.call(this);
            e4._shell = this._shell.clone(), e4._holes = new Array(this._holes.length).fill(null);
            for (var n3 = 0; n3 < this._holes.length; n3++)
              e4._holes[n3] = this._holes[n3].clone();
            return e4;
          }, e3.prototype.getGeometryType = function() {
            return "Polygon";
          }, e3.prototype.copy = function() {
            for (var t3 = this._shell.copy(), n3 = new Array(this._holes.length).fill(null), i2 = 0; i2 < n3.length; i2++)
              n3[i2] = this._holes[i2].copy();
            return new e3(t3, n3, this._factory);
          }, e3.prototype.getExteriorRing = function() {
            return this._shell;
          }, e3.prototype.isEmpty = function() {
            return this._shell.isEmpty();
          }, e3.prototype.getInteriorRingN = function(t3) {
            return this._holes[t3];
          }, e3.prototype.interfaces_ = function() {
            return [Zt];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.serialVersionUID.get = function() {
            return -3494792200821764600;
          }, Object.defineProperties(e3, n2), e3;
        }(ct), te = function(t2) {
          function e3() {
            t2.apply(this, arguments);
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { serialVersionUID: { configurable: true } };
          return e3.prototype.getSortIndex = function() {
            return ct.SORTINDEX_MULTIPOINT;
          }, e3.prototype.isValid = function() {
            return true;
          }, e3.prototype.equalsExact = function() {
            if (2 === arguments.length) {
              var e4 = arguments[0], n3 = arguments[1];
              return !!this.isEquivalentClass(e4) && t2.prototype.equalsExact.call(this, e4, n3);
            }
            return t2.prototype.equalsExact.apply(this, arguments);
          }, e3.prototype.getCoordinate = function() {
            if (1 === arguments.length) {
              var e4 = arguments[0];
              return this._geometries[e4].getCoordinate();
            }
            return t2.prototype.getCoordinate.apply(this, arguments);
          }, e3.prototype.getBoundaryDimension = function() {
            return qt.FALSE;
          }, e3.prototype.getDimension = function() {
            return 0;
          }, e3.prototype.getBoundary = function() {
            return this.getFactory().createGeometryCollection(null);
          }, e3.prototype.getGeometryType = function() {
            return "MultiPoint";
          }, e3.prototype.copy = function() {
            for (var t3 = new Array(this._geometries.length).fill(null), n3 = 0; n3 < t3.length; n3++)
              t3[n3] = this._geometries[n3].copy();
            return new e3(t3, this._factory);
          }, e3.prototype.interfaces_ = function() {
            return [Jt];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.serialVersionUID.get = function() {
            return -8048474874175356e3;
          }, Object.defineProperties(e3, n2), e3;
        }(zt), ee = function(t2) {
          function e3(e4, n3) {
            e4 instanceof C && n3 instanceof _e && (e4 = n3.getCoordinateSequenceFactory().create(e4)), t2.call(this, e4, n3), this.validateConstruction();
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { MINIMUM_VALID_SIZE: { configurable: true }, serialVersionUID: { configurable: true } };
          return e3.prototype.getSortIndex = function() {
            return ct.SORTINDEX_LINEARRING;
          }, e3.prototype.getBoundaryDimension = function() {
            return qt.FALSE;
          }, e3.prototype.isClosed = function() {
            return !!this.isEmpty() || t2.prototype.isClosed.call(this);
          }, e3.prototype.reverse = function() {
            var t3 = this._points.copy();
            Wt.reverse(t3);
            return this.getFactory().createLinearRing(t3);
          }, e3.prototype.validateConstruction = function() {
            if (!this.isEmpty() && !t2.prototype.isClosed.call(this))
              throw new m("Points of LinearRing do not form a closed linestring");
            if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < e3.MINIMUM_VALID_SIZE)
              throw new m("Invalid number of points in LinearRing (found " + this.getCoordinateSequence().size() + " - must be 0 or >= 4)");
          }, e3.prototype.getGeometryType = function() {
            return "LinearRing";
          }, e3.prototype.copy = function() {
            return new e3(this._points.copy(), this._factory);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.MINIMUM_VALID_SIZE.get = function() {
            return 4;
          }, n2.serialVersionUID.get = function() {
            return -4261142084085851600;
          }, Object.defineProperties(e3, n2), e3;
        }(Kt), ne = function(t2) {
          function e3() {
            t2.apply(this, arguments);
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { serialVersionUID: { configurable: true } };
          return e3.prototype.getSortIndex = function() {
            return ct.SORTINDEX_MULTIPOLYGON;
          }, e3.prototype.equalsExact = function() {
            if (2 === arguments.length) {
              var e4 = arguments[0], n3 = arguments[1];
              return !!this.isEquivalentClass(e4) && t2.prototype.equalsExact.call(this, e4, n3);
            }
            return t2.prototype.equalsExact.apply(this, arguments);
          }, e3.prototype.getBoundaryDimension = function() {
            return 1;
          }, e3.prototype.getDimension = function() {
            return 2;
          }, e3.prototype.reverse = function() {
            for (var t3 = this._geometries.length, e4 = new Array(t3).fill(null), n3 = 0; n3 < this._geometries.length; n3++)
              e4[n3] = this._geometries[n3].reverse();
            return this.getFactory().createMultiPolygon(e4);
          }, e3.prototype.getBoundary = function() {
            if (this.isEmpty())
              return this.getFactory().createMultiLineString();
            for (var t3 = new Nt(), e4 = 0; e4 < this._geometries.length; e4++)
              for (var n3 = this._geometries[e4].getBoundary(), i2 = 0; i2 < n3.getNumGeometries(); i2++)
                t3.add(n3.getGeometryN(i2));
            var r2 = new Array(t3.size()).fill(null);
            return this.getFactory().createMultiLineString(t3.toArray(r2));
          }, e3.prototype.getGeometryType = function() {
            return "MultiPolygon";
          }, e3.prototype.copy = function() {
            for (var t3 = new Array(this._geometries.length).fill(null), n3 = 0; n3 < t3.length; n3++)
              t3[n3] = this._geometries[n3].copy();
            return new e3(t3, this._factory);
          }, e3.prototype.interfaces_ = function() {
            return [Zt];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.serialVersionUID.get = function() {
            return -551033529766975900;
          }, Object.defineProperties(e3, n2), e3;
        }(zt), ie = function(t2) {
          this._factory = t2 || null, this._isUserDataCopied = false;
        }, re = { NoOpGeometryOperation: { configurable: true }, CoordinateOperation: { configurable: true }, CoordinateSequenceOperation: { configurable: true } };
        ie.prototype.setCopyUserData = function(t2) {
          this._isUserDataCopied = t2;
        }, ie.prototype.edit = function(t2, e3) {
          if (null === t2)
            return null;
          var n2 = this.editInternal(t2, e3);
          return this._isUserDataCopied && n2.setUserData(t2.getUserData()), n2;
        }, ie.prototype.editInternal = function(t2, e3) {
          return null === this._factory && (this._factory = t2.getFactory()), t2 instanceof zt ? this.editGeometryCollection(t2, e3) : t2 instanceof $t ? this.editPolygon(t2, e3) : t2 instanceof Qt ? e3.edit(t2, this._factory) : t2 instanceof Kt ? e3.edit(t2, this._factory) : (et.shouldNeverReachHere("Unsupported Geometry class: " + t2.getClass().getName()), null);
        }, ie.prototype.editGeometryCollection = function(t2, e3) {
          for (var n2 = e3.edit(t2, this._factory), i2 = new Nt(), r2 = 0; r2 < n2.getNumGeometries(); r2++) {
            var o2 = this.edit(n2.getGeometryN(r2), e3);
            null === o2 || o2.isEmpty() || i2.add(o2);
          }
          return n2.getClass() === te ? this._factory.createMultiPoint(i2.toArray([])) : n2.getClass() === Xt ? this._factory.createMultiLineString(i2.toArray([])) : n2.getClass() === ne ? this._factory.createMultiPolygon(i2.toArray([])) : this._factory.createGeometryCollection(i2.toArray([]));
        }, ie.prototype.editPolygon = function(t2, e3) {
          var n2 = e3.edit(t2, this._factory);
          if (null === n2 && (n2 = this._factory.createPolygon(null)), n2.isEmpty())
            return n2;
          var i2 = this.edit(n2.getExteriorRing(), e3);
          if (null === i2 || i2.isEmpty())
            return this._factory.createPolygon();
          for (var r2 = new Nt(), o2 = 0; o2 < n2.getNumInteriorRing(); o2++) {
            var s2 = this.edit(n2.getInteriorRingN(o2), e3);
            null === s2 || s2.isEmpty() || r2.add(s2);
          }
          return this._factory.createPolygon(i2, r2.toArray([]));
        }, ie.prototype.interfaces_ = function() {
          return [];
        }, ie.prototype.getClass = function() {
          return ie;
        }, ie.GeometryEditorOperation = function() {
        }, re.NoOpGeometryOperation.get = function() {
          return oe;
        }, re.CoordinateOperation.get = function() {
          return se;
        }, re.CoordinateSequenceOperation.get = function() {
          return ae;
        }, Object.defineProperties(ie, re);
        var oe = function() {
        };
        oe.prototype.edit = function(t2, e3) {
          return t2;
        }, oe.prototype.interfaces_ = function() {
          return [ie.GeometryEditorOperation];
        }, oe.prototype.getClass = function() {
          return oe;
        };
        var se = function() {
        };
        se.prototype.edit = function(t2, e3) {
          var n2 = this.editCoordinates(t2.getCoordinates(), t2);
          return null === n2 ? t2 : t2 instanceof ee ? e3.createLinearRing(n2) : t2 instanceof Kt ? e3.createLineString(n2) : t2 instanceof Qt ? n2.length > 0 ? e3.createPoint(n2[0]) : e3.createPoint() : t2;
        }, se.prototype.interfaces_ = function() {
          return [ie.GeometryEditorOperation];
        }, se.prototype.getClass = function() {
          return se;
        };
        var ae = function() {
        };
        ae.prototype.edit = function(t2, e3) {
          return t2 instanceof ee ? e3.createLinearRing(this.edit(t2.getCoordinateSequence(), t2)) : t2 instanceof Kt ? e3.createLineString(this.edit(t2.getCoordinateSequence(), t2)) : t2 instanceof Qt ? e3.createPoint(this.edit(t2.getCoordinateSequence(), t2)) : t2;
        }, ae.prototype.interfaces_ = function() {
          return [ie.GeometryEditorOperation];
        }, ae.prototype.getClass = function() {
          return ae;
        };
        var ue = function() {
          if (this._dimension = 3, this._coordinates = null, 1 === arguments.length) {
            if (arguments[0] instanceof Array)
              this._coordinates = arguments[0], this._dimension = 3;
            else if (Number.isInteger(arguments[0])) {
              var t2 = arguments[0];
              this._coordinates = new Array(t2).fill(null);
              for (var e3 = 0; e3 < t2; e3++)
                this._coordinates[e3] = new C();
            } else if (T(arguments[0], V)) {
              var n2 = arguments[0];
              if (null === n2)
                return this._coordinates = new Array(0).fill(null), null;
              this._dimension = n2.getDimension(), this._coordinates = new Array(n2.size()).fill(null);
              for (var i2 = 0; i2 < this._coordinates.length; i2++)
                this._coordinates[i2] = n2.getCoordinateCopy(i2);
            }
          } else if (2 === arguments.length) {
            if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
              var r2 = arguments[0], o2 = arguments[1];
              this._coordinates = r2, this._dimension = o2, null === r2 && (this._coordinates = new Array(0).fill(null));
            } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
              var s2 = arguments[0], a2 = arguments[1];
              this._coordinates = new Array(s2).fill(null), this._dimension = a2;
              for (var u2 = 0; u2 < s2; u2++)
                this._coordinates[u2] = new C();
            }
          }
        }, le = { serialVersionUID: { configurable: true } };
        ue.prototype.setOrdinate = function(t2, e3, n2) {
          switch (e3) {
            case V.X:
              this._coordinates[t2].x = n2;
              break;
            case V.Y:
              this._coordinates[t2].y = n2;
              break;
            case V.Z:
              this._coordinates[t2].z = n2;
              break;
            default:
              throw new m("invalid ordinateIndex");
          }
        }, ue.prototype.size = function() {
          return this._coordinates.length;
        }, ue.prototype.getOrdinate = function(t2, e3) {
          switch (e3) {
            case V.X:
              return this._coordinates[t2].x;
            case V.Y:
              return this._coordinates[t2].y;
            case V.Z:
              return this._coordinates[t2].z;
          }
          return v.NaN;
        }, ue.prototype.getCoordinate = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return this._coordinates[t2];
          }
          if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            n2.x = this._coordinates[e3].x, n2.y = this._coordinates[e3].y, n2.z = this._coordinates[e3].z;
          }
        }, ue.prototype.getCoordinateCopy = function(t2) {
          return new C(this._coordinates[t2]);
        }, ue.prototype.getDimension = function() {
          return this._dimension;
        }, ue.prototype.getX = function(t2) {
          return this._coordinates[t2].x;
        }, ue.prototype.clone = function() {
          for (var t2 = new Array(this.size()).fill(null), e3 = 0; e3 < this._coordinates.length; e3++)
            t2[e3] = this._coordinates[e3].clone();
          return new ue(t2, this._dimension);
        }, ue.prototype.expandEnvelope = function(t2) {
          for (var e3 = 0; e3 < this._coordinates.length; e3++)
            t2.expandToInclude(this._coordinates[e3]);
          return t2;
        }, ue.prototype.copy = function() {
          for (var t2 = new Array(this.size()).fill(null), e3 = 0; e3 < this._coordinates.length; e3++)
            t2[e3] = this._coordinates[e3].copy();
          return new ue(t2, this._dimension);
        }, ue.prototype.toString = function() {
          if (this._coordinates.length > 0) {
            var t2 = new D(17 * this._coordinates.length);
            t2.append("("), t2.append(this._coordinates[0]);
            for (var e3 = 1; e3 < this._coordinates.length; e3++)
              t2.append(", "), t2.append(this._coordinates[e3]);
            return t2.append(")"), t2.toString();
          }
          return "()";
        }, ue.prototype.getY = function(t2) {
          return this._coordinates[t2].y;
        }, ue.prototype.toCoordinateArray = function() {
          return this._coordinates;
        }, ue.prototype.interfaces_ = function() {
          return [V, e];
        }, ue.prototype.getClass = function() {
          return ue;
        }, le.serialVersionUID.get = function() {
          return -915438501601840600;
        }, Object.defineProperties(ue, le);
        var ce = function() {
        }, pe = { serialVersionUID: { configurable: true }, instanceObject: { configurable: true } };
        ce.prototype.readResolve = function() {
          return ce.instance();
        }, ce.prototype.create = function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof Array) {
              var t2 = arguments[0];
              return new ue(t2);
            }
            if (T(arguments[0], V)) {
              var e3 = arguments[0];
              return new ue(e3);
            }
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            return i2 > 3 && (i2 = 3), i2 < 2 ? new ue(n2) : new ue(n2, i2);
          }
        }, ce.prototype.interfaces_ = function() {
          return [b, e];
        }, ce.prototype.getClass = function() {
          return ce;
        }, ce.instance = function() {
          return ce.instanceObject;
        }, pe.serialVersionUID.get = function() {
          return -4099577099607551500;
        }, pe.instanceObject.get = function() {
          return new ce();
        }, Object.defineProperties(ce, pe);
        var he = function(t2) {
          function e3() {
            t2.call(this), this.map_ = /* @__PURE__ */ new Map();
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.get = function(t3) {
            return this.map_.get(t3) || null;
          }, e3.prototype.put = function(t3, e4) {
            return this.map_.set(t3, e4), e4;
          }, e3.prototype.values = function() {
            for (var t3 = new Nt(), e4 = this.map_.values(), n2 = e4.next(); !n2.done; )
              t3.add(n2.value), n2 = e4.next();
            return t3;
          }, e3.prototype.entrySet = function() {
            var t3 = new Pt();
            return this.map_.entries().forEach(function(e4) {
              return t3.add(e4);
            }), t3;
          }, e3.prototype.size = function() {
            return this.map_.size();
          }, e3;
        }(Tt), fe = function t2() {
          if (this._modelType = null, this._scale = null, 0 === arguments.length)
            this._modelType = t2.FLOATING;
          else if (1 === arguments.length) {
            if (arguments[0] instanceof de) {
              var e3 = arguments[0];
              this._modelType = e3, e3 === t2.FIXED && this.setScale(1);
            } else if ("number" == typeof arguments[0]) {
              var n2 = arguments[0];
              this._modelType = t2.FIXED, this.setScale(n2);
            } else if (arguments[0] instanceof t2) {
              var i2 = arguments[0];
              this._modelType = i2._modelType, this._scale = i2._scale;
            }
          }
        }, ge = { serialVersionUID: { configurable: true }, maximumPreciseValue: { configurable: true } };
        fe.prototype.equals = function(t2) {
          if (!(t2 instanceof fe))
            return false;
          var e3 = t2;
          return this._modelType === e3._modelType && this._scale === e3._scale;
        }, fe.prototype.compareTo = function(t2) {
          var e3 = t2, n2 = this.getMaximumSignificantDigits(), i2 = e3.getMaximumSignificantDigits();
          return new M(n2).compareTo(new M(i2));
        }, fe.prototype.getScale = function() {
          return this._scale;
        }, fe.prototype.isFloating = function() {
          return this._modelType === fe.FLOATING || this._modelType === fe.FLOATING_SINGLE;
        }, fe.prototype.getType = function() {
          return this._modelType;
        }, fe.prototype.toString = function() {
          var t2 = "UNKNOWN";
          return this._modelType === fe.FLOATING ? t2 = "Floating" : this._modelType === fe.FLOATING_SINGLE ? t2 = "Floating-Single" : this._modelType === fe.FIXED && (t2 = "Fixed (Scale=" + this.getScale() + ")"), t2;
        }, fe.prototype.makePrecise = function() {
          if ("number" == typeof arguments[0]) {
            var t2 = arguments[0];
            if (v.isNaN(t2))
              return t2;
            if (this._modelType === fe.FLOATING_SINGLE) {
              return t2;
            }
            return this._modelType === fe.FIXED ? Math.round(t2 * this._scale) / this._scale : t2;
          }
          if (arguments[0] instanceof C) {
            var e3 = arguments[0];
            if (this._modelType === fe.FLOATING)
              return null;
            e3.x = this.makePrecise(e3.x), e3.y = this.makePrecise(e3.y);
          }
        }, fe.prototype.getMaximumSignificantDigits = function() {
          var t2 = 16;
          return this._modelType === fe.FLOATING ? t2 = 16 : this._modelType === fe.FLOATING_SINGLE ? t2 = 6 : this._modelType === fe.FIXED && (t2 = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))), t2;
        }, fe.prototype.setScale = function(t2) {
          this._scale = Math.abs(t2);
        }, fe.prototype.interfaces_ = function() {
          return [e, E];
        }, fe.prototype.getClass = function() {
          return fe;
        }, fe.mostPrecise = function(t2, e3) {
          return t2.compareTo(e3) >= 0 ? t2 : e3;
        }, ge.serialVersionUID.get = function() {
          return 7777263578777804e3;
        }, ge.maximumPreciseValue.get = function() {
          return 9007199254740992;
        }, Object.defineProperties(fe, ge);
        var de = function t2(e3) {
          this._name = e3 || null, t2.nameToTypeMap.put(e3, this);
        }, ye = { serialVersionUID: { configurable: true }, nameToTypeMap: { configurable: true } };
        de.prototype.readResolve = function() {
          return de.nameToTypeMap.get(this._name);
        }, de.prototype.toString = function() {
          return this._name;
        }, de.prototype.interfaces_ = function() {
          return [e];
        }, de.prototype.getClass = function() {
          return de;
        }, ye.serialVersionUID.get = function() {
          return -552860263173159e4;
        }, ye.nameToTypeMap.get = function() {
          return new he();
        }, Object.defineProperties(de, ye), fe.Type = de, fe.FIXED = new de("FIXED"), fe.FLOATING = new de("FLOATING"), fe.FLOATING_SINGLE = new de("FLOATING SINGLE");
        var _e = function t2() {
          this._precisionModel = new fe(), this._SRID = 0, this._coordinateSequenceFactory = t2.getDefaultCoordinateSequenceFactory(), 0 === arguments.length || (1 === arguments.length ? T(arguments[0], b) ? this._coordinateSequenceFactory = arguments[0] : arguments[0] instanceof fe && (this._precisionModel = arguments[0]) : 2 === arguments.length ? (this._precisionModel = arguments[0], this._SRID = arguments[1]) : 3 === arguments.length && (this._precisionModel = arguments[0], this._SRID = arguments[1], this._coordinateSequenceFactory = arguments[2]));
        }, me = { serialVersionUID: { configurable: true } };
        _e.prototype.toGeometry = function(t2) {
          return t2.isNull() ? this.createPoint(null) : t2.getMinX() === t2.getMaxX() && t2.getMinY() === t2.getMaxY() ? this.createPoint(new C(t2.getMinX(), t2.getMinY())) : t2.getMinX() === t2.getMaxX() || t2.getMinY() === t2.getMaxY() ? this.createLineString([new C(t2.getMinX(), t2.getMinY()), new C(t2.getMaxX(), t2.getMaxY())]) : this.createPolygon(this.createLinearRing([new C(t2.getMinX(), t2.getMinY()), new C(t2.getMinX(), t2.getMaxY()), new C(t2.getMaxX(), t2.getMaxY()), new C(t2.getMaxX(), t2.getMinY()), new C(t2.getMinX(), t2.getMinY())]), null);
        }, _e.prototype.createLineString = function(t2) {
          return t2 ? t2 instanceof Array ? new Kt(this.getCoordinateSequenceFactory().create(t2), this) : T(t2, V) ? new Kt(t2, this) : void 0 : new Kt(this.getCoordinateSequenceFactory().create([]), this);
        }, _e.prototype.createMultiLineString = function() {
          if (0 === arguments.length)
            return new Xt(null, this);
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return new Xt(t2, this);
          }
        }, _e.prototype.buildGeometry = function(t2) {
          for (var e3 = null, n2 = false, i2 = false, r2 = t2.iterator(); r2.hasNext(); ) {
            var o2 = r2.next(), s2 = o2.getClass();
            null === e3 && (e3 = s2), s2 !== e3 && (n2 = true), o2.isGeometryCollectionOrDerived() && (i2 = true);
          }
          if (null === e3)
            return this.createGeometryCollection();
          if (n2 || i2)
            return this.createGeometryCollection(_e.toGeometryArray(t2));
          var a2 = t2.iterator().next();
          if (t2.size() > 1) {
            if (a2 instanceof $t)
              return this.createMultiPolygon(_e.toPolygonArray(t2));
            if (a2 instanceof Kt)
              return this.createMultiLineString(_e.toLineStringArray(t2));
            if (a2 instanceof Qt)
              return this.createMultiPoint(_e.toPointArray(t2));
            et.shouldNeverReachHere("Unhandled class: " + a2.getClass().getName());
          }
          return a2;
        }, _e.prototype.createMultiPointFromCoords = function(t2) {
          return this.createMultiPoint(null !== t2 ? this.getCoordinateSequenceFactory().create(t2) : null);
        }, _e.prototype.createPoint = function() {
          if (0 === arguments.length)
            return this.createPoint(this.getCoordinateSequenceFactory().create([]));
          if (1 === arguments.length) {
            if (arguments[0] instanceof C) {
              var t2 = arguments[0];
              return this.createPoint(null !== t2 ? this.getCoordinateSequenceFactory().create([t2]) : null);
            }
            if (T(arguments[0], V)) {
              var e3 = arguments[0];
              return new Qt(e3, this);
            }
          }
        }, _e.prototype.getCoordinateSequenceFactory = function() {
          return this._coordinateSequenceFactory;
        }, _e.prototype.createPolygon = function() {
          if (0 === arguments.length)
            return new $t(null, null, this);
          if (1 === arguments.length) {
            if (T(arguments[0], V)) {
              var t2 = arguments[0];
              return this.createPolygon(this.createLinearRing(t2));
            }
            if (arguments[0] instanceof Array) {
              var e3 = arguments[0];
              return this.createPolygon(this.createLinearRing(e3));
            }
            if (arguments[0] instanceof ee) {
              var n2 = arguments[0];
              return this.createPolygon(n2, null);
            }
          } else if (2 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1];
            return new $t(i2, r2, this);
          }
        }, _e.prototype.getSRID = function() {
          return this._SRID;
        }, _e.prototype.createGeometryCollection = function() {
          if (0 === arguments.length)
            return new zt(null, this);
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return new zt(t2, this);
          }
        }, _e.prototype.createGeometry = function(t2) {
          return new ie(this).edit(t2, { edit: function() {
            if (2 === arguments.length) {
              var t3 = arguments[0];
              return this._coordinateSequenceFactory.create(t3);
            }
          } });
        }, _e.prototype.getPrecisionModel = function() {
          return this._precisionModel;
        }, _e.prototype.createLinearRing = function() {
          if (0 === arguments.length)
            return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));
          if (1 === arguments.length) {
            if (arguments[0] instanceof Array) {
              var t2 = arguments[0];
              return this.createLinearRing(null !== t2 ? this.getCoordinateSequenceFactory().create(t2) : null);
            }
            if (T(arguments[0], V)) {
              var e3 = arguments[0];
              return new ee(e3, this);
            }
          }
        }, _e.prototype.createMultiPolygon = function() {
          if (0 === arguments.length)
            return new ne(null, this);
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return new ne(t2, this);
          }
        }, _e.prototype.createMultiPoint = function() {
          if (0 === arguments.length)
            return new te(null, this);
          if (1 === arguments.length) {
            if (arguments[0] instanceof Array) {
              var t2 = arguments[0];
              return new te(t2, this);
            }
            if (arguments[0] instanceof Array) {
              var e3 = arguments[0];
              return this.createMultiPoint(null !== e3 ? this.getCoordinateSequenceFactory().create(e3) : null);
            }
            if (T(arguments[0], V)) {
              var n2 = arguments[0];
              if (null === n2)
                return this.createMultiPoint(new Array(0).fill(null));
              for (var i2 = new Array(n2.size()).fill(null), r2 = 0; r2 < n2.size(); r2++) {
                var o2 = this.getCoordinateSequenceFactory().create(1, n2.getDimension());
                Wt.copy(n2, r2, o2, 0, 1), i2[r2] = this.createPoint(o2);
              }
              return this.createMultiPoint(i2);
            }
          }
        }, _e.prototype.interfaces_ = function() {
          return [e];
        }, _e.prototype.getClass = function() {
          return _e;
        }, _e.toMultiPolygonArray = function(t2) {
          var e3 = new Array(t2.size()).fill(null);
          return t2.toArray(e3);
        }, _e.toGeometryArray = function(t2) {
          if (null === t2)
            return null;
          var e3 = new Array(t2.size()).fill(null);
          return t2.toArray(e3);
        }, _e.getDefaultCoordinateSequenceFactory = function() {
          return ce.instance();
        }, _e.toMultiLineStringArray = function(t2) {
          var e3 = new Array(t2.size()).fill(null);
          return t2.toArray(e3);
        }, _e.toLineStringArray = function(t2) {
          var e3 = new Array(t2.size()).fill(null);
          return t2.toArray(e3);
        }, _e.toMultiPointArray = function(t2) {
          var e3 = new Array(t2.size()).fill(null);
          return t2.toArray(e3);
        }, _e.toLinearRingArray = function(t2) {
          var e3 = new Array(t2.size()).fill(null);
          return t2.toArray(e3);
        }, _e.toPointArray = function(t2) {
          var e3 = new Array(t2.size()).fill(null);
          return t2.toArray(e3);
        }, _e.toPolygonArray = function(t2) {
          var e3 = new Array(t2.size()).fill(null);
          return t2.toArray(e3);
        }, _e.createPointFromInternalCoord = function(t2, e3) {
          return e3.getPrecisionModel().makePrecise(t2), e3.getFactory().createPoint(t2);
        }, me.serialVersionUID.get = function() {
          return -6820524753094096e3;
        }, Object.defineProperties(_e, me);
        var ve = ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"], Ie = function(t2) {
          this.geometryFactory = t2 || new _e();
        };
        Ie.prototype.read = function(t2) {
          var e3, n2 = (e3 = "string" == typeof t2 ? JSON.parse(t2) : t2).type;
          if (!Ee[n2])
            throw new Error("Unknown GeoJSON type: " + e3.type);
          return -1 !== ve.indexOf(n2) ? Ee[n2].apply(this, [e3.coordinates]) : "GeometryCollection" === n2 ? Ee[n2].apply(this, [e3.geometries]) : Ee[n2].apply(this, [e3]);
        }, Ie.prototype.write = function(t2) {
          var e3 = t2.getGeometryType();
          if (!xe[e3])
            throw new Error("Geometry is not supported");
          return xe[e3].apply(this, [t2]);
        };
        var Ee = { Feature: function(t2) {
          var e3 = {};
          for (var n2 in t2)
            e3[n2] = t2[n2];
          if (t2.geometry) {
            var i2 = t2.geometry.type;
            if (!Ee[i2])
              throw new Error("Unknown GeoJSON type: " + t2.type);
            e3.geometry = this.read(t2.geometry);
          }
          return t2.bbox && (e3.bbox = Ee.bbox.apply(this, [t2.bbox])), e3;
        }, FeatureCollection: function(t2) {
          var e3 = {};
          if (t2.features) {
            e3.features = [];
            for (var n2 = 0; n2 < t2.features.length; ++n2)
              e3.features.push(this.read(t2.features[n2]));
          }
          return t2.bbox && (e3.bbox = this.parse.bbox.apply(this, [t2.bbox])), e3;
        }, coordinates: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2.length; ++n2) {
            var i2 = t2[n2];
            e3.push(new C(i2[0], i2[1]));
          }
          return e3;
        }, bbox: function(t2) {
          return this.geometryFactory.createLinearRing([new C(t2[0], t2[1]), new C(t2[2], t2[1]), new C(t2[2], t2[3]), new C(t2[0], t2[3]), new C(t2[0], t2[1])]);
        }, Point: function(t2) {
          var e3 = new C(t2[0], t2[1]);
          return this.geometryFactory.createPoint(e3);
        }, MultiPoint: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2.length; ++n2)
            e3.push(Ee.Point.apply(this, [t2[n2]]));
          return this.geometryFactory.createMultiPoint(e3);
        }, LineString: function(t2) {
          var e3 = Ee.coordinates.apply(this, [t2]);
          return this.geometryFactory.createLineString(e3);
        }, MultiLineString: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2.length; ++n2)
            e3.push(Ee.LineString.apply(this, [t2[n2]]));
          return this.geometryFactory.createMultiLineString(e3);
        }, Polygon: function(t2) {
          for (var e3 = Ee.coordinates.apply(this, [t2[0]]), n2 = this.geometryFactory.createLinearRing(e3), i2 = [], r2 = 1; r2 < t2.length; ++r2) {
            var o2 = t2[r2], s2 = Ee.coordinates.apply(this, [o2]), a2 = this.geometryFactory.createLinearRing(s2);
            i2.push(a2);
          }
          return this.geometryFactory.createPolygon(n2, i2);
        }, MultiPolygon: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2.length; ++n2) {
            var i2 = t2[n2];
            e3.push(Ee.Polygon.apply(this, [i2]));
          }
          return this.geometryFactory.createMultiPolygon(e3);
        }, GeometryCollection: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2.length; ++n2) {
            var i2 = t2[n2];
            e3.push(this.read(i2));
          }
          return this.geometryFactory.createGeometryCollection(e3);
        } }, xe = { coordinate: function(t2) {
          return [t2.x, t2.y];
        }, Point: function(t2) {
          return { type: "Point", coordinates: xe.coordinate.apply(this, [t2.getCoordinate()]) };
        }, MultiPoint: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2._geometries.length; ++n2) {
            var i2 = t2._geometries[n2], r2 = xe.Point.apply(this, [i2]);
            e3.push(r2.coordinates);
          }
          return { type: "MultiPoint", coordinates: e3 };
        }, LineString: function(t2) {
          for (var e3 = [], n2 = t2.getCoordinates(), i2 = 0; i2 < n2.length; ++i2) {
            var r2 = n2[i2];
            e3.push(xe.coordinate.apply(this, [r2]));
          }
          return { type: "LineString", coordinates: e3 };
        }, MultiLineString: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2._geometries.length; ++n2) {
            var i2 = t2._geometries[n2], r2 = xe.LineString.apply(this, [i2]);
            e3.push(r2.coordinates);
          }
          return { type: "MultiLineString", coordinates: e3 };
        }, Polygon: function(t2) {
          var e3 = [], n2 = xe.LineString.apply(this, [t2._shell]);
          e3.push(n2.coordinates);
          for (var i2 = 0; i2 < t2._holes.length; ++i2) {
            var r2 = t2._holes[i2], o2 = xe.LineString.apply(this, [r2]);
            e3.push(o2.coordinates);
          }
          return { type: "Polygon", coordinates: e3 };
        }, MultiPolygon: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2._geometries.length; ++n2) {
            var i2 = t2._geometries[n2], r2 = xe.Polygon.apply(this, [i2]);
            e3.push(r2.coordinates);
          }
          return { type: "MultiPolygon", coordinates: e3 };
        }, GeometryCollection: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2._geometries.length; ++n2) {
            var i2 = t2._geometries[n2], r2 = i2.getGeometryType();
            e3.push(xe[r2].apply(this, [i2]));
          }
          return { type: "GeometryCollection", geometries: e3 };
        } }, Ne = function(t2) {
          this.geometryFactory = t2 || new _e(), this.precisionModel = this.geometryFactory.getPrecisionModel(), this.parser = new Ie(this.geometryFactory);
        };
        Ne.prototype.read = function(t2) {
          var e3 = this.parser.read(t2);
          return this.precisionModel.getType() === fe.FIXED && this.reducePrecision(e3), e3;
        }, Ne.prototype.reducePrecision = function(t2) {
          var e3, n2;
          if (t2.coordinate)
            this.precisionModel.makePrecise(t2.coordinate);
          else if (t2.points)
            for (e3 = 0, n2 = t2.points.length; e3 < n2; e3++)
              this.precisionModel.makePrecise(t2.points[e3]);
          else if (t2.geometries)
            for (e3 = 0, n2 = t2.geometries.length; e3 < n2; e3++)
              this.reducePrecision(t2.geometries[e3]);
        };
        var Ce = function() {
          this.parser = new Ie(this.geometryFactory);
        };
        Ce.prototype.write = function(t2) {
          return this.parser.write(t2);
        };
        var Se = function() {
        }, Le = { ON: { configurable: true }, LEFT: { configurable: true }, RIGHT: { configurable: true } };
        Se.prototype.interfaces_ = function() {
          return [];
        }, Se.prototype.getClass = function() {
          return Se;
        }, Se.opposite = function(t2) {
          return t2 === Se.LEFT ? Se.RIGHT : t2 === Se.RIGHT ? Se.LEFT : t2;
        }, Le.ON.get = function() {
          return 0;
        }, Le.LEFT.get = function() {
          return 1;
        }, Le.RIGHT.get = function() {
          return 2;
        }, Object.defineProperties(Se, Le), (d.prototype = new Error()).name = "EmptyStackException", (y2.prototype = new xt()).add = function(t2) {
          return this.array_.push(t2), true;
        }, y2.prototype.get = function(t2) {
          if (t2 < 0 || t2 >= this.size())
            throw new Error();
          return this.array_[t2];
        }, y2.prototype.push = function(t2) {
          return this.array_.push(t2), t2;
        }, y2.prototype.pop = function(t2) {
          if (0 === this.array_.length)
            throw new d();
          return this.array_.pop();
        }, y2.prototype.peek = function() {
          if (0 === this.array_.length)
            throw new d();
          return this.array_[this.array_.length - 1];
        }, y2.prototype.empty = function() {
          return 0 === this.array_.length;
        }, y2.prototype.isEmpty = function() {
          return this.empty();
        }, y2.prototype.search = function(t2) {
          return this.array_.indexOf(t2);
        }, y2.prototype.size = function() {
          return this.array_.length;
        }, y2.prototype.toArray = function() {
          for (var t2 = [], e3 = 0, n2 = this.array_.length; e3 < n2; e3++)
            t2.push(this.array_[e3]);
          return t2;
        };
        var be = function() {
          this._minIndex = -1, this._minCoord = null, this._minDe = null, this._orientedDe = null;
        };
        be.prototype.getCoordinate = function() {
          return this._minCoord;
        }, be.prototype.getRightmostSide = function(t2, e3) {
          var n2 = this.getRightmostSideOfSegment(t2, e3);
          return n2 < 0 && (n2 = this.getRightmostSideOfSegment(t2, e3 - 1)), n2 < 0 && (this._minCoord = null, this.checkForRightmostCoordinate(t2)), n2;
        }, be.prototype.findRightmostEdgeAtVertex = function() {
          var t2 = this._minDe.getEdge().getCoordinates();
          et.isTrue(this._minIndex > 0 && this._minIndex < t2.length, "rightmost point expected to be interior vertex of edge");
          var e3 = t2[this._minIndex - 1], n2 = t2[this._minIndex + 1], i2 = at.computeOrientation(this._minCoord, n2, e3), r2 = false;
          e3.y < this._minCoord.y && n2.y < this._minCoord.y && i2 === at.COUNTERCLOCKWISE ? r2 = true : e3.y > this._minCoord.y && n2.y > this._minCoord.y && i2 === at.CLOCKWISE && (r2 = true), r2 && (this._minIndex = this._minIndex - 1);
        }, be.prototype.getRightmostSideOfSegment = function(t2, e3) {
          var n2 = t2.getEdge().getCoordinates();
          if (e3 < 0 || e3 + 1 >= n2.length)
            return -1;
          if (n2[e3].y === n2[e3 + 1].y)
            return -1;
          var i2 = Se.LEFT;
          return n2[e3].y < n2[e3 + 1].y && (i2 = Se.RIGHT), i2;
        }, be.prototype.getEdge = function() {
          return this._orientedDe;
        }, be.prototype.checkForRightmostCoordinate = function(t2) {
          for (var e3 = t2.getEdge().getCoordinates(), n2 = 0; n2 < e3.length - 1; n2++)
            (null === this._minCoord || e3[n2].x > this._minCoord.x) && (this._minDe = t2, this._minIndex = n2, this._minCoord = e3[n2]);
        }, be.prototype.findRightmostEdgeAtNode = function() {
          var t2 = this._minDe.getNode().getEdges();
          this._minDe = t2.getRightmostEdge(), this._minDe.isForward() || (this._minDe = this._minDe.getSym(), this._minIndex = this._minDe.getEdge().getCoordinates().length - 1);
        }, be.prototype.findEdge = function(t2) {
          for (var e3 = t2.iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            n2.isForward() && this.checkForRightmostCoordinate(n2);
          }
          et.isTrue(0 !== this._minIndex || this._minCoord.equals(this._minDe.getCoordinate()), "inconsistency in rightmost processing"), 0 === this._minIndex ? this.findRightmostEdgeAtNode() : this.findRightmostEdgeAtVertex(), this._orientedDe = this._minDe;
          this.getRightmostSide(this._minDe, this._minIndex) === Se.LEFT && (this._orientedDe = this._minDe.getSym());
        }, be.prototype.interfaces_ = function() {
          return [];
        }, be.prototype.getClass = function() {
          return be;
        };
        var we = function(t2) {
          function e3(n2, i2) {
            t2.call(this, e3.msgWithCoord(n2, i2)), this.pt = i2 ? new C(i2) : null, this.name = "TopologyException";
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.getCoordinate = function() {
            return this.pt;
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3.msgWithCoord = function(t3, e4) {
            return e4 ? t3 : t3 + " [ " + e4 + " ]";
          }, e3;
        }($), Oe = function() {
          this.array_ = [];
        };
        Oe.prototype.addLast = function(t2) {
          this.array_.push(t2);
        }, Oe.prototype.removeFirst = function() {
          return this.array_.shift();
        }, Oe.prototype.isEmpty = function() {
          return 0 === this.array_.length;
        };
        var Te = function() {
          this._finder = null, this._dirEdgeList = new Nt(), this._nodes = new Nt(), this._rightMostCoord = null, this._env = null, this._finder = new be();
        };
        Te.prototype.clearVisitedEdges = function() {
          for (var t2 = this._dirEdgeList.iterator(); t2.hasNext(); ) {
            t2.next().setVisited(false);
          }
        }, Te.prototype.getRightmostCoordinate = function() {
          return this._rightMostCoord;
        }, Te.prototype.computeNodeDepth = function(t2) {
          for (var e3 = null, n2 = t2.getEdges().iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            if (i2.isVisited() || i2.getSym().isVisited()) {
              e3 = i2;
              break;
            }
          }
          if (null === e3)
            throw new we("unable to find edge to compute depths at " + t2.getCoordinate());
          t2.getEdges().computeDepths(e3);
          for (var r2 = t2.getEdges().iterator(); r2.hasNext(); ) {
            var o2 = r2.next();
            o2.setVisited(true), this.copySymDepths(o2);
          }
        }, Te.prototype.computeDepth = function(t2) {
          this.clearVisitedEdges();
          var e3 = this._finder.getEdge();
          e3.setEdgeDepths(Se.RIGHT, t2), this.copySymDepths(e3), this.computeDepths(e3);
        }, Te.prototype.create = function(t2) {
          this.addReachable(t2), this._finder.findEdge(this._dirEdgeList), this._rightMostCoord = this._finder.getCoordinate();
        }, Te.prototype.findResultEdges = function() {
          for (var t2 = this._dirEdgeList.iterator(); t2.hasNext(); ) {
            var e3 = t2.next();
            e3.getDepth(Se.RIGHT) >= 1 && e3.getDepth(Se.LEFT) <= 0 && !e3.isInteriorAreaEdge() && e3.setInResult(true);
          }
        }, Te.prototype.computeDepths = function(t2) {
          var e3 = new Pt(), n2 = new Oe(), i2 = t2.getNode();
          for (n2.addLast(i2), e3.add(i2), t2.setVisited(true); !n2.isEmpty(); ) {
            var r2 = n2.removeFirst();
            e3.add(r2), this.computeNodeDepth(r2);
            for (var o2 = r2.getEdges().iterator(); o2.hasNext(); ) {
              var s2 = o2.next().getSym();
              if (!s2.isVisited()) {
                var a2 = s2.getNode();
                e3.contains(a2) || (n2.addLast(a2), e3.add(a2));
              }
            }
          }
        }, Te.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this._rightMostCoord.x < e3._rightMostCoord.x ? -1 : this._rightMostCoord.x > e3._rightMostCoord.x ? 1 : 0;
        }, Te.prototype.getEnvelope = function() {
          if (null === this._env) {
            for (var t2 = new j(), e3 = this._dirEdgeList.iterator(); e3.hasNext(); )
              for (var n2 = e3.next().getEdge().getCoordinates(), i2 = 0; i2 < n2.length - 1; i2++)
                t2.expandToInclude(n2[i2]);
            this._env = t2;
          }
          return this._env;
        }, Te.prototype.addReachable = function(t2) {
          var e3 = new y2();
          for (e3.add(t2); !e3.empty(); ) {
            var n2 = e3.pop();
            this.add(n2, e3);
          }
        }, Te.prototype.copySymDepths = function(t2) {
          var e3 = t2.getSym();
          e3.setDepth(Se.LEFT, t2.getDepth(Se.RIGHT)), e3.setDepth(Se.RIGHT, t2.getDepth(Se.LEFT));
        }, Te.prototype.add = function(t2, e3) {
          t2.setVisited(true), this._nodes.add(t2);
          for (var n2 = t2.getEdges().iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            this._dirEdgeList.add(i2);
            var r2 = i2.getSym().getNode();
            r2.isVisited() || e3.push(r2);
          }
        }, Te.prototype.getNodes = function() {
          return this._nodes;
        }, Te.prototype.getDirectedEdges = function() {
          return this._dirEdgeList;
        }, Te.prototype.interfaces_ = function() {
          return [E];
        }, Te.prototype.getClass = function() {
          return Te;
        };
        var Re = function t2() {
          if (this.location = null, 1 === arguments.length) {
            if (arguments[0] instanceof Array) {
              var e3 = arguments[0];
              this.init(e3.length);
            } else if (Number.isInteger(arguments[0])) {
              var n2 = arguments[0];
              this.init(1), this.location[Se.ON] = n2;
            } else if (arguments[0] instanceof t2) {
              var i2 = arguments[0];
              if (this.init(i2.location.length), null !== i2)
                for (var r2 = 0; r2 < this.location.length; r2++)
                  this.location[r2] = i2.location[r2];
            }
          } else if (3 === arguments.length) {
            var o2 = arguments[0], s2 = arguments[1], a2 = arguments[2];
            this.init(3), this.location[Se.ON] = o2, this.location[Se.LEFT] = s2, this.location[Se.RIGHT] = a2;
          }
        };
        Re.prototype.setAllLocations = function(t2) {
          for (var e3 = 0; e3 < this.location.length; e3++)
            this.location[e3] = t2;
        }, Re.prototype.isNull = function() {
          for (var t2 = 0; t2 < this.location.length; t2++)
            if (this.location[t2] !== w.NONE)
              return false;
          return true;
        }, Re.prototype.setAllLocationsIfNull = function(t2) {
          for (var e3 = 0; e3 < this.location.length; e3++)
            this.location[e3] === w.NONE && (this.location[e3] = t2);
        }, Re.prototype.isLine = function() {
          return 1 === this.location.length;
        }, Re.prototype.merge = function(t2) {
          if (t2.location.length > this.location.length) {
            var e3 = new Array(3).fill(null);
            e3[Se.ON] = this.location[Se.ON], e3[Se.LEFT] = w.NONE, e3[Se.RIGHT] = w.NONE, this.location = e3;
          }
          for (var n2 = 0; n2 < this.location.length; n2++)
            this.location[n2] === w.NONE && n2 < t2.location.length && (this.location[n2] = t2.location[n2]);
        }, Re.prototype.getLocations = function() {
          return this.location;
        }, Re.prototype.flip = function() {
          if (this.location.length <= 1)
            return null;
          var t2 = this.location[Se.LEFT];
          this.location[Se.LEFT] = this.location[Se.RIGHT], this.location[Se.RIGHT] = t2;
        }, Re.prototype.toString = function() {
          var t2 = new D();
          return this.location.length > 1 && t2.append(w.toLocationSymbol(this.location[Se.LEFT])), t2.append(w.toLocationSymbol(this.location[Se.ON])), this.location.length > 1 && t2.append(w.toLocationSymbol(this.location[Se.RIGHT])), t2.toString();
        }, Re.prototype.setLocations = function(t2, e3, n2) {
          this.location[Se.ON] = t2, this.location[Se.LEFT] = e3, this.location[Se.RIGHT] = n2;
        }, Re.prototype.get = function(t2) {
          return t2 < this.location.length ? this.location[t2] : w.NONE;
        }, Re.prototype.isArea = function() {
          return this.location.length > 1;
        }, Re.prototype.isAnyNull = function() {
          for (var t2 = 0; t2 < this.location.length; t2++)
            if (this.location[t2] === w.NONE)
              return true;
          return false;
        }, Re.prototype.setLocation = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.setLocation(Se.ON, t2);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            this.location[e3] = n2;
          }
        }, Re.prototype.init = function(t2) {
          this.location = new Array(t2).fill(null), this.setAllLocations(w.NONE);
        }, Re.prototype.isEqualOnSide = function(t2, e3) {
          return this.location[e3] === t2.location[e3];
        }, Re.prototype.allPositionsEqual = function(t2) {
          for (var e3 = 0; e3 < this.location.length; e3++)
            if (this.location[e3] !== t2)
              return false;
          return true;
        }, Re.prototype.interfaces_ = function() {
          return [];
        }, Re.prototype.getClass = function() {
          return Re;
        };
        var Pe = function t2() {
          if (this.elt = new Array(2).fill(null), 1 === arguments.length) {
            if (Number.isInteger(arguments[0])) {
              var e3 = arguments[0];
              this.elt[0] = new Re(e3), this.elt[1] = new Re(e3);
            } else if (arguments[0] instanceof t2) {
              var n2 = arguments[0];
              this.elt[0] = new Re(n2.elt[0]), this.elt[1] = new Re(n2.elt[1]);
            }
          } else if (2 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1];
            this.elt[0] = new Re(w.NONE), this.elt[1] = new Re(w.NONE), this.elt[i2].setLocation(r2);
          } else if (3 === arguments.length) {
            var o2 = arguments[0], s2 = arguments[1], a2 = arguments[2];
            this.elt[0] = new Re(o2, s2, a2), this.elt[1] = new Re(o2, s2, a2);
          } else if (4 === arguments.length) {
            var u2 = arguments[0], l2 = arguments[1], c2 = arguments[2], p2 = arguments[3];
            this.elt[0] = new Re(w.NONE, w.NONE, w.NONE), this.elt[1] = new Re(w.NONE, w.NONE, w.NONE), this.elt[u2].setLocations(l2, c2, p2);
          }
        };
        Pe.prototype.getGeometryCount = function() {
          var t2 = 0;
          return this.elt[0].isNull() || t2++, this.elt[1].isNull() || t2++, t2;
        }, Pe.prototype.setAllLocations = function(t2, e3) {
          this.elt[t2].setAllLocations(e3);
        }, Pe.prototype.isNull = function(t2) {
          return this.elt[t2].isNull();
        }, Pe.prototype.setAllLocationsIfNull = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.setAllLocationsIfNull(0, t2), this.setAllLocationsIfNull(1, t2);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            this.elt[e3].setAllLocationsIfNull(n2);
          }
        }, Pe.prototype.isLine = function(t2) {
          return this.elt[t2].isLine();
        }, Pe.prototype.merge = function(t2) {
          for (var e3 = 0; e3 < 2; e3++)
            null === this.elt[e3] && null !== t2.elt[e3] ? this.elt[e3] = new Re(t2.elt[e3]) : this.elt[e3].merge(t2.elt[e3]);
        }, Pe.prototype.flip = function() {
          this.elt[0].flip(), this.elt[1].flip();
        }, Pe.prototype.getLocation = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return this.elt[t2].get(Se.ON);
          }
          if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            return this.elt[e3].get(n2);
          }
        }, Pe.prototype.toString = function() {
          var t2 = new D();
          return null !== this.elt[0] && (t2.append("A:"), t2.append(this.elt[0].toString())), null !== this.elt[1] && (t2.append(" B:"), t2.append(this.elt[1].toString())), t2.toString();
        }, Pe.prototype.isArea = function() {
          if (0 === arguments.length)
            return this.elt[0].isArea() || this.elt[1].isArea();
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return this.elt[t2].isArea();
          }
        }, Pe.prototype.isAnyNull = function(t2) {
          return this.elt[t2].isAnyNull();
        }, Pe.prototype.setLocation = function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            this.elt[t2].setLocation(Se.ON, e3);
          } else if (3 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2];
            this.elt[n2].setLocation(i2, r2);
          }
        }, Pe.prototype.isEqualOnSide = function(t2, e3) {
          return this.elt[0].isEqualOnSide(t2.elt[0], e3) && this.elt[1].isEqualOnSide(t2.elt[1], e3);
        }, Pe.prototype.allPositionsEqual = function(t2, e3) {
          return this.elt[t2].allPositionsEqual(e3);
        }, Pe.prototype.toLine = function(t2) {
          this.elt[t2].isArea() && (this.elt[t2] = new Re(this.elt[t2].location[0]));
        }, Pe.prototype.interfaces_ = function() {
          return [];
        }, Pe.prototype.getClass = function() {
          return Pe;
        }, Pe.toLineLabel = function(t2) {
          for (var e3 = new Pe(w.NONE), n2 = 0; n2 < 2; n2++)
            e3.setLocation(n2, t2.getLocation(n2));
          return e3;
        };
        var De = function() {
          this._startDe = null, this._maxNodeDegree = -1, this._edges = new Nt(), this._pts = new Nt(), this._label = new Pe(w.NONE), this._ring = null, this._isHole = null, this._shell = null, this._holes = new Nt(), this._geometryFactory = null;
          var t2 = arguments[0], e3 = arguments[1];
          this._geometryFactory = e3, this.computePoints(t2), this.computeRing();
        };
        De.prototype.computeRing = function() {
          if (null !== this._ring)
            return null;
          for (var t2 = new Array(this._pts.size()).fill(null), e3 = 0; e3 < this._pts.size(); e3++)
            t2[e3] = this._pts.get(e3);
          this._ring = this._geometryFactory.createLinearRing(t2), this._isHole = at.isCCW(this._ring.getCoordinates());
        }, De.prototype.isIsolated = function() {
          return 1 === this._label.getGeometryCount();
        }, De.prototype.computePoints = function(t2) {
          this._startDe = t2;
          var e3 = t2, n2 = true;
          do {
            if (null === e3)
              throw new we("Found null DirectedEdge");
            if (e3.getEdgeRing() === this)
              throw new we("Directed Edge visited twice during ring-building at " + e3.getCoordinate());
            this._edges.add(e3);
            var i2 = e3.getLabel();
            et.isTrue(i2.isArea()), this.mergeLabel(i2), this.addPoints(e3.getEdge(), e3.isForward(), n2), n2 = false, this.setEdgeRing(e3, this), e3 = this.getNext(e3);
          } while (e3 !== this._startDe);
        }, De.prototype.getLinearRing = function() {
          return this._ring;
        }, De.prototype.getCoordinate = function(t2) {
          return this._pts.get(t2);
        }, De.prototype.computeMaxNodeDegree = function() {
          this._maxNodeDegree = 0;
          var t2 = this._startDe;
          do {
            var e3 = t2.getNode().getEdges().getOutgoingDegree(this);
            e3 > this._maxNodeDegree && (this._maxNodeDegree = e3), t2 = this.getNext(t2);
          } while (t2 !== this._startDe);
          this._maxNodeDegree *= 2;
        }, De.prototype.addPoints = function(t2, e3, n2) {
          var i2 = t2.getCoordinates();
          if (e3) {
            var r2 = 1;
            n2 && (r2 = 0);
            for (var o2 = r2; o2 < i2.length; o2++)
              this._pts.add(i2[o2]);
          } else {
            var s2 = i2.length - 2;
            n2 && (s2 = i2.length - 1);
            for (var a2 = s2; a2 >= 0; a2--)
              this._pts.add(i2[a2]);
          }
        }, De.prototype.isHole = function() {
          return this._isHole;
        }, De.prototype.setInResult = function() {
          var t2 = this._startDe;
          do {
            t2.getEdge().setInResult(true), t2 = t2.getNext();
          } while (t2 !== this._startDe);
        }, De.prototype.containsPoint = function(t2) {
          var e3 = this.getLinearRing();
          if (!e3.getEnvelopeInternal().contains(t2))
            return false;
          if (!at.isPointInRing(t2, e3.getCoordinates()))
            return false;
          for (var n2 = this._holes.iterator(); n2.hasNext(); ) {
            if (n2.next().containsPoint(t2))
              return false;
          }
          return true;
        }, De.prototype.addHole = function(t2) {
          this._holes.add(t2);
        }, De.prototype.isShell = function() {
          return null === this._shell;
        }, De.prototype.getLabel = function() {
          return this._label;
        }, De.prototype.getEdges = function() {
          return this._edges;
        }, De.prototype.getMaxNodeDegree = function() {
          return this._maxNodeDegree < 0 && this.computeMaxNodeDegree(), this._maxNodeDegree;
        }, De.prototype.getShell = function() {
          return this._shell;
        }, De.prototype.mergeLabel = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.mergeLabel(t2, 0), this.mergeLabel(t2, 1);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1], i2 = e3.getLocation(n2, Se.RIGHT);
            if (i2 === w.NONE)
              return null;
            if (this._label.getLocation(n2) === w.NONE)
              return this._label.setLocation(n2, i2), null;
          }
        }, De.prototype.setShell = function(t2) {
          this._shell = t2, null !== t2 && t2.addHole(this);
        }, De.prototype.toPolygon = function(t2) {
          for (var e3 = new Array(this._holes.size()).fill(null), n2 = 0; n2 < this._holes.size(); n2++)
            e3[n2] = this._holes.get(n2).getLinearRing();
          return t2.createPolygon(this.getLinearRing(), e3);
        }, De.prototype.interfaces_ = function() {
          return [];
        }, De.prototype.getClass = function() {
          return De;
        };
        var Me = function(t2) {
          function e3() {
            var e4 = arguments[0], n2 = arguments[1];
            t2.call(this, e4, n2);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.setEdgeRing = function(t3, e4) {
            t3.setMinEdgeRing(e4);
          }, e3.prototype.getNext = function(t3) {
            return t3.getNextMin();
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(De), Ae = function(t2) {
          function e3() {
            var e4 = arguments[0], n2 = arguments[1];
            t2.call(this, e4, n2);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.buildMinimalRings = function() {
            var t3 = new Nt(), e4 = this._startDe;
            do {
              if (null === e4.getMinEdgeRing()) {
                var n2 = new Me(e4, this._geometryFactory);
                t3.add(n2);
              }
              e4 = e4.getNext();
            } while (e4 !== this._startDe);
            return t3;
          }, e3.prototype.setEdgeRing = function(t3, e4) {
            t3.setEdgeRing(e4);
          }, e3.prototype.linkDirectedEdgesForMinimalEdgeRings = function() {
            var t3 = this._startDe;
            do {
              t3.getNode().getEdges().linkMinimalDirectedEdges(this), t3 = t3.getNext();
            } while (t3 !== this._startDe);
          }, e3.prototype.getNext = function(t3) {
            return t3.getNext();
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(De), Fe = function() {
          if (this._label = null, this._isInResult = false, this._isCovered = false, this._isCoveredSet = false, this._isVisited = false, 0 === arguments.length)
            ;
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            this._label = t2;
          }
        };
        Fe.prototype.setVisited = function(t2) {
          this._isVisited = t2;
        }, Fe.prototype.setInResult = function(t2) {
          this._isInResult = t2;
        }, Fe.prototype.isCovered = function() {
          return this._isCovered;
        }, Fe.prototype.isCoveredSet = function() {
          return this._isCoveredSet;
        }, Fe.prototype.setLabel = function(t2) {
          this._label = t2;
        }, Fe.prototype.getLabel = function() {
          return this._label;
        }, Fe.prototype.setCovered = function(t2) {
          this._isCovered = t2, this._isCoveredSet = true;
        }, Fe.prototype.updateIM = function(t2) {
          et.isTrue(this._label.getGeometryCount() >= 2, "found partial label"), this.computeIM(t2);
        }, Fe.prototype.isInResult = function() {
          return this._isInResult;
        }, Fe.prototype.isVisited = function() {
          return this._isVisited;
        }, Fe.prototype.interfaces_ = function() {
          return [];
        }, Fe.prototype.getClass = function() {
          return Fe;
        };
        var Ge = function(t2) {
          function e3() {
            t2.call(this), this._coord = null, this._edges = null;
            var e4 = arguments[0], n2 = arguments[1];
            this._coord = e4, this._edges = n2, this._label = new Pe(0, w.NONE);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.isIncidentEdgeInResult = function() {
            for (var t3 = this.getEdges().getEdges().iterator(); t3.hasNext(); ) {
              if (t3.next().getEdge().isInResult())
                return true;
            }
            return false;
          }, e3.prototype.isIsolated = function() {
            return 1 === this._label.getGeometryCount();
          }, e3.prototype.getCoordinate = function() {
            return this._coord;
          }, e3.prototype.print = function(t3) {
            t3.println("node " + this._coord + " lbl: " + this._label);
          }, e3.prototype.computeIM = function(t3) {
          }, e3.prototype.computeMergedLocation = function(t3, e4) {
            var n2 = w.NONE;
            if (n2 = this._label.getLocation(e4), !t3.isNull(e4)) {
              var i2 = t3.getLocation(e4);
              n2 !== w.BOUNDARY && (n2 = i2);
            }
            return n2;
          }, e3.prototype.setLabel = function() {
            if (2 !== arguments.length)
              return t2.prototype.setLabel.apply(this, arguments);
            var e4 = arguments[0], n2 = arguments[1];
            null === this._label ? this._label = new Pe(e4, n2) : this._label.setLocation(e4, n2);
          }, e3.prototype.getEdges = function() {
            return this._edges;
          }, e3.prototype.mergeLabel = function() {
            if (arguments[0] instanceof e3) {
              var t3 = arguments[0];
              this.mergeLabel(t3._label);
            } else if (arguments[0] instanceof Pe)
              for (var n2 = arguments[0], i2 = 0; i2 < 2; i2++) {
                var r2 = this.computeMergedLocation(n2, i2);
                this._label.getLocation(i2) === w.NONE && this._label.setLocation(i2, r2);
              }
          }, e3.prototype.add = function(t3) {
            this._edges.insert(t3), t3.setNode(this);
          }, e3.prototype.setLabelBoundary = function(t3) {
            if (null === this._label)
              return null;
            var e4 = w.NONE;
            null !== this._label && (e4 = this._label.getLocation(t3));
            var n2 = null;
            switch (e4) {
              case w.BOUNDARY:
                n2 = w.INTERIOR;
                break;
              case w.INTERIOR:
              default:
                n2 = w.BOUNDARY;
            }
            this._label.setLocation(t3, n2);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(Fe), qe = function() {
          this.nodeMap = new p(), this.nodeFact = null;
          var t2 = arguments[0];
          this.nodeFact = t2;
        };
        qe.prototype.find = function(t2) {
          return this.nodeMap.get(t2);
        }, qe.prototype.addNode = function() {
          if (arguments[0] instanceof C) {
            var t2 = arguments[0], e3 = this.nodeMap.get(t2);
            return null === e3 && (e3 = this.nodeFact.createNode(t2), this.nodeMap.put(t2, e3)), e3;
          }
          if (arguments[0] instanceof Ge) {
            var n2 = arguments[0], i2 = this.nodeMap.get(n2.getCoordinate());
            return null === i2 ? (this.nodeMap.put(n2.getCoordinate(), n2), n2) : (i2.mergeLabel(n2), i2);
          }
        }, qe.prototype.print = function(t2) {
          for (var e3 = this.iterator(); e3.hasNext(); ) {
            e3.next().print(t2);
          }
        }, qe.prototype.iterator = function() {
          return this.nodeMap.values().iterator();
        }, qe.prototype.values = function() {
          return this.nodeMap.values();
        }, qe.prototype.getBoundaryNodes = function(t2) {
          for (var e3 = new Nt(), n2 = this.iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            i2.getLabel().getLocation(t2) === w.BOUNDARY && e3.add(i2);
          }
          return e3;
        }, qe.prototype.add = function(t2) {
          var e3 = t2.getCoordinate();
          this.addNode(e3).add(t2);
        }, qe.prototype.interfaces_ = function() {
          return [];
        }, qe.prototype.getClass = function() {
          return qe;
        };
        var Be = function() {
        }, Ve = { NE: { configurable: true }, NW: { configurable: true }, SW: { configurable: true }, SE: { configurable: true } };
        Be.prototype.interfaces_ = function() {
          return [];
        }, Be.prototype.getClass = function() {
          return Be;
        }, Be.isNorthern = function(t2) {
          return t2 === Be.NE || t2 === Be.NW;
        }, Be.isOpposite = function(t2, e3) {
          if (t2 === e3)
            return false;
          return 2 === (t2 - e3 + 4) % 4;
        }, Be.commonHalfPlane = function(t2, e3) {
          if (t2 === e3)
            return t2;
          if (2 === (t2 - e3 + 4) % 4)
            return -1;
          var n2 = t2 < e3 ? t2 : e3;
          return 0 === n2 && 3 === (t2 > e3 ? t2 : e3) ? 3 : n2;
        }, Be.isInHalfPlane = function(t2, e3) {
          return e3 === Be.SE ? t2 === Be.SE || t2 === Be.SW : t2 === e3 || t2 === e3 + 1;
        }, Be.quadrant = function() {
          if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
            var t2 = arguments[0], e3 = arguments[1];
            if (0 === t2 && 0 === e3)
              throw new m("Cannot compute the quadrant for point ( " + t2 + ", " + e3 + " )");
            return t2 >= 0 ? e3 >= 0 ? Be.NE : Be.SE : e3 >= 0 ? Be.NW : Be.SW;
          }
          if (arguments[0] instanceof C && arguments[1] instanceof C) {
            var n2 = arguments[0], i2 = arguments[1];
            if (i2.x === n2.x && i2.y === n2.y)
              throw new m("Cannot compute the quadrant for two identical points " + n2);
            return i2.x >= n2.x ? i2.y >= n2.y ? Be.NE : Be.SE : i2.y >= n2.y ? Be.NW : Be.SW;
          }
        }, Ve.NE.get = function() {
          return 0;
        }, Ve.NW.get = function() {
          return 1;
        }, Ve.SW.get = function() {
          return 2;
        }, Ve.SE.get = function() {
          return 3;
        }, Object.defineProperties(Be, Ve);
        var Ue = function() {
          if (this._edge = null, this._label = null, this._node = null, this._p0 = null, this._p1 = null, this._dx = null, this._dy = null, this._quadrant = null, 1 === arguments.length) {
            var t2 = arguments[0];
            this._edge = t2;
          } else if (3 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1], i2 = arguments[2];
            this._edge = e3, this.init(n2, i2), this._label = null;
          } else if (4 === arguments.length) {
            var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2], a2 = arguments[3];
            this._edge = r2, this.init(o2, s2), this._label = a2;
          }
        };
        Ue.prototype.compareDirection = function(t2) {
          return this._dx === t2._dx && this._dy === t2._dy ? 0 : this._quadrant > t2._quadrant ? 1 : this._quadrant < t2._quadrant ? -1 : at.computeOrientation(t2._p0, t2._p1, this._p1);
        }, Ue.prototype.getDy = function() {
          return this._dy;
        }, Ue.prototype.getCoordinate = function() {
          return this._p0;
        }, Ue.prototype.setNode = function(t2) {
          this._node = t2;
        }, Ue.prototype.print = function(t2) {
          var e3 = Math.atan2(this._dy, this._dx), n2 = this.getClass().getName(), i2 = n2.lastIndexOf("."), r2 = n2.substring(i2 + 1);
          t2.print("  " + r2 + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + e3 + "   " + this._label);
        }, Ue.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this.compareDirection(e3);
        }, Ue.prototype.getDirectedCoordinate = function() {
          return this._p1;
        }, Ue.prototype.getDx = function() {
          return this._dx;
        }, Ue.prototype.getLabel = function() {
          return this._label;
        }, Ue.prototype.getEdge = function() {
          return this._edge;
        }, Ue.prototype.getQuadrant = function() {
          return this._quadrant;
        }, Ue.prototype.getNode = function() {
          return this._node;
        }, Ue.prototype.toString = function() {
          var t2 = Math.atan2(this._dy, this._dx), e3 = this.getClass().getName(), n2 = e3.lastIndexOf(".");
          return "  " + e3.substring(n2 + 1) + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + t2 + "   " + this._label;
        }, Ue.prototype.computeLabel = function(t2) {
        }, Ue.prototype.init = function(t2, e3) {
          this._p0 = t2, this._p1 = e3, this._dx = e3.x - t2.x, this._dy = e3.y - t2.y, this._quadrant = Be.quadrant(this._dx, this._dy), et.isTrue(!(0 === this._dx && 0 === this._dy), "EdgeEnd with identical endpoints found");
        }, Ue.prototype.interfaces_ = function() {
          return [E];
        }, Ue.prototype.getClass = function() {
          return Ue;
        };
        var ze = function(t2) {
          function e3() {
            var e4 = arguments[0], n2 = arguments[1];
            if (t2.call(this, e4), this._isForward = null, this._isInResult = false, this._isVisited = false, this._sym = null, this._next = null, this._nextMin = null, this._edgeRing = null, this._minEdgeRing = null, this._depth = [0, -999, -999], this._isForward = n2, n2)
              this.init(e4.getCoordinate(0), e4.getCoordinate(1));
            else {
              var i2 = e4.getNumPoints() - 1;
              this.init(e4.getCoordinate(i2), e4.getCoordinate(i2 - 1));
            }
            this.computeDirectedLabel();
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.getNextMin = function() {
            return this._nextMin;
          }, e3.prototype.getDepth = function(t3) {
            return this._depth[t3];
          }, e3.prototype.setVisited = function(t3) {
            this._isVisited = t3;
          }, e3.prototype.computeDirectedLabel = function() {
            this._label = new Pe(this._edge.getLabel()), this._isForward || this._label.flip();
          }, e3.prototype.getNext = function() {
            return this._next;
          }, e3.prototype.setDepth = function(t3, e4) {
            if (-999 !== this._depth[t3] && this._depth[t3] !== e4)
              throw new we("assigned depths do not match", this.getCoordinate());
            this._depth[t3] = e4;
          }, e3.prototype.isInteriorAreaEdge = function() {
            for (var t3 = true, e4 = 0; e4 < 2; e4++)
              this._label.isArea(e4) && this._label.getLocation(e4, Se.LEFT) === w.INTERIOR && this._label.getLocation(e4, Se.RIGHT) === w.INTERIOR || (t3 = false);
            return t3;
          }, e3.prototype.setNextMin = function(t3) {
            this._nextMin = t3;
          }, e3.prototype.print = function(e4) {
            t2.prototype.print.call(this, e4), e4.print(" " + this._depth[Se.LEFT] + "/" + this._depth[Se.RIGHT]), e4.print(" (" + this.getDepthDelta() + ")"), this._isInResult && e4.print(" inResult");
          }, e3.prototype.setMinEdgeRing = function(t3) {
            this._minEdgeRing = t3;
          }, e3.prototype.isLineEdge = function() {
            var t3 = this._label.isLine(0) || this._label.isLine(1), e4 = !this._label.isArea(0) || this._label.allPositionsEqual(0, w.EXTERIOR), n2 = !this._label.isArea(1) || this._label.allPositionsEqual(1, w.EXTERIOR);
            return t3 && e4 && n2;
          }, e3.prototype.setEdgeRing = function(t3) {
            this._edgeRing = t3;
          }, e3.prototype.getMinEdgeRing = function() {
            return this._minEdgeRing;
          }, e3.prototype.getDepthDelta = function() {
            var t3 = this._edge.getDepthDelta();
            return this._isForward || (t3 = -t3), t3;
          }, e3.prototype.setInResult = function(t3) {
            this._isInResult = t3;
          }, e3.prototype.getSym = function() {
            return this._sym;
          }, e3.prototype.isForward = function() {
            return this._isForward;
          }, e3.prototype.getEdge = function() {
            return this._edge;
          }, e3.prototype.printEdge = function(t3) {
            this.print(t3), t3.print(" "), this._isForward ? this._edge.print(t3) : this._edge.printReverse(t3);
          }, e3.prototype.setSym = function(t3) {
            this._sym = t3;
          }, e3.prototype.setVisitedEdge = function(t3) {
            this.setVisited(t3), this._sym.setVisited(t3);
          }, e3.prototype.setEdgeDepths = function(t3, e4) {
            var n2 = this.getEdge().getDepthDelta();
            this._isForward || (n2 = -n2);
            var i2 = 1;
            t3 === Se.LEFT && (i2 = -1);
            var r2 = Se.opposite(t3), o2 = e4 + n2 * i2;
            this.setDepth(t3, e4), this.setDepth(r2, o2);
          }, e3.prototype.getEdgeRing = function() {
            return this._edgeRing;
          }, e3.prototype.isInResult = function() {
            return this._isInResult;
          }, e3.prototype.setNext = function(t3) {
            this._next = t3;
          }, e3.prototype.isVisited = function() {
            return this._isVisited;
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3.depthFactor = function(t3, e4) {
            return t3 === w.EXTERIOR && e4 === w.INTERIOR ? 1 : t3 === w.INTERIOR && e4 === w.EXTERIOR ? -1 : 0;
          }, e3;
        }(Ue), Xe = function() {
        };
        Xe.prototype.createNode = function(t2) {
          return new Ge(t2, null);
        }, Xe.prototype.interfaces_ = function() {
          return [];
        }, Xe.prototype.getClass = function() {
          return Xe;
        };
        var Ye = function() {
          if (this._edges = new Nt(), this._nodes = null, this._edgeEndList = new Nt(), 0 === arguments.length)
            this._nodes = new qe(new Xe());
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            this._nodes = new qe(t2);
          }
        };
        Ye.prototype.printEdges = function(t2) {
          t2.println("Edges:");
          for (var e3 = 0; e3 < this._edges.size(); e3++) {
            t2.println("edge " + e3 + ":");
            var n2 = this._edges.get(e3);
            n2.print(t2), n2.eiList.print(t2);
          }
        }, Ye.prototype.find = function(t2) {
          return this._nodes.find(t2);
        }, Ye.prototype.addNode = function() {
          if (arguments[0] instanceof Ge) {
            var t2 = arguments[0];
            return this._nodes.addNode(t2);
          }
          if (arguments[0] instanceof C) {
            var e3 = arguments[0];
            return this._nodes.addNode(e3);
          }
        }, Ye.prototype.getNodeIterator = function() {
          return this._nodes.iterator();
        }, Ye.prototype.linkResultDirectedEdges = function() {
          for (var t2 = this._nodes.iterator(); t2.hasNext(); ) {
            t2.next().getEdges().linkResultDirectedEdges();
          }
        }, Ye.prototype.debugPrintln = function(t2) {
          Y.out.println(t2);
        }, Ye.prototype.isBoundaryNode = function(t2, e3) {
          var n2 = this._nodes.find(e3);
          if (null === n2)
            return false;
          var i2 = n2.getLabel();
          return null !== i2 && i2.getLocation(t2) === w.BOUNDARY;
        }, Ye.prototype.linkAllDirectedEdges = function() {
          for (var t2 = this._nodes.iterator(); t2.hasNext(); ) {
            t2.next().getEdges().linkAllDirectedEdges();
          }
        }, Ye.prototype.matchInSameDirection = function(t2, e3, n2, i2) {
          return !!t2.equals(n2) && (at.computeOrientation(t2, e3, i2) === at.COLLINEAR && Be.quadrant(t2, e3) === Be.quadrant(n2, i2));
        }, Ye.prototype.getEdgeEnds = function() {
          return this._edgeEndList;
        }, Ye.prototype.debugPrint = function(t2) {
          Y.out.print(t2);
        }, Ye.prototype.getEdgeIterator = function() {
          return this._edges.iterator();
        }, Ye.prototype.findEdgeInSameDirection = function(t2, e3) {
          for (var n2 = 0; n2 < this._edges.size(); n2++) {
            var i2 = this._edges.get(n2), r2 = i2.getCoordinates();
            if (this.matchInSameDirection(t2, e3, r2[0], r2[1]))
              return i2;
            if (this.matchInSameDirection(t2, e3, r2[r2.length - 1], r2[r2.length - 2]))
              return i2;
          }
          return null;
        }, Ye.prototype.insertEdge = function(t2) {
          this._edges.add(t2);
        }, Ye.prototype.findEdgeEnd = function(t2) {
          for (var e3 = this.getEdgeEnds().iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            if (n2.getEdge() === t2)
              return n2;
          }
          return null;
        }, Ye.prototype.addEdges = function(t2) {
          for (var e3 = t2.iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            this._edges.add(n2);
            var i2 = new ze(n2, true), r2 = new ze(n2, false);
            i2.setSym(r2), r2.setSym(i2), this.add(i2), this.add(r2);
          }
        }, Ye.prototype.add = function(t2) {
          this._nodes.add(t2), this._edgeEndList.add(t2);
        }, Ye.prototype.getNodes = function() {
          return this._nodes.values();
        }, Ye.prototype.findEdge = function(t2, e3) {
          for (var n2 = 0; n2 < this._edges.size(); n2++) {
            var i2 = this._edges.get(n2), r2 = i2.getCoordinates();
            if (t2.equals(r2[0]) && e3.equals(r2[1]))
              return i2;
          }
          return null;
        }, Ye.prototype.interfaces_ = function() {
          return [];
        }, Ye.prototype.getClass = function() {
          return Ye;
        }, Ye.linkResultDirectedEdges = function(t2) {
          for (var e3 = t2.iterator(); e3.hasNext(); ) {
            e3.next().getEdges().linkResultDirectedEdges();
          }
        };
        var ke = function() {
          this._geometryFactory = null, this._shellList = new Nt();
          var t2 = arguments[0];
          this._geometryFactory = t2;
        };
        ke.prototype.sortShellsAndHoles = function(t2, e3, n2) {
          for (var i2 = t2.iterator(); i2.hasNext(); ) {
            var r2 = i2.next();
            r2.isHole() ? n2.add(r2) : e3.add(r2);
          }
        }, ke.prototype.computePolygons = function(t2) {
          for (var e3 = new Nt(), n2 = t2.iterator(); n2.hasNext(); ) {
            var i2 = n2.next().toPolygon(this._geometryFactory);
            e3.add(i2);
          }
          return e3;
        }, ke.prototype.placeFreeHoles = function(t2, e3) {
          for (var n2 = e3.iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            if (null === i2.getShell()) {
              var r2 = this.findEdgeRingContaining(i2, t2);
              if (null === r2)
                throw new we("unable to assign hole to a shell", i2.getCoordinate(0));
              i2.setShell(r2);
            }
          }
        }, ke.prototype.buildMinimalEdgeRings = function(t2, e3, n2) {
          for (var i2 = new Nt(), r2 = t2.iterator(); r2.hasNext(); ) {
            var o2 = r2.next();
            if (o2.getMaxNodeDegree() > 2) {
              o2.linkDirectedEdgesForMinimalEdgeRings();
              var s2 = o2.buildMinimalRings(), a2 = this.findShell(s2);
              null !== a2 ? (this.placePolygonHoles(a2, s2), e3.add(a2)) : n2.addAll(s2);
            } else
              i2.add(o2);
          }
          return i2;
        }, ke.prototype.containsPoint = function(t2) {
          for (var e3 = this._shellList.iterator(); e3.hasNext(); ) {
            if (e3.next().containsPoint(t2))
              return true;
          }
          return false;
        }, ke.prototype.buildMaximalEdgeRings = function(t2) {
          for (var e3 = new Nt(), n2 = t2.iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            if (i2.isInResult() && i2.getLabel().isArea() && null === i2.getEdgeRing()) {
              var r2 = new Ae(i2, this._geometryFactory);
              e3.add(r2), r2.setInResult();
            }
          }
          return e3;
        }, ke.prototype.placePolygonHoles = function(t2, e3) {
          for (var n2 = e3.iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            i2.isHole() && i2.setShell(t2);
          }
        }, ke.prototype.getPolygons = function() {
          return this.computePolygons(this._shellList);
        }, ke.prototype.findEdgeRingContaining = function(t2, e3) {
          for (var n2 = t2.getLinearRing(), i2 = n2.getEnvelopeInternal(), r2 = n2.getCoordinateN(0), o2 = null, s2 = null, a2 = e3.iterator(); a2.hasNext(); ) {
            var u2 = a2.next(), l2 = u2.getLinearRing(), c2 = l2.getEnvelopeInternal();
            null !== o2 && (s2 = o2.getLinearRing().getEnvelopeInternal());
            var p2 = false;
            c2.contains(i2) && at.isPointInRing(r2, l2.getCoordinates()) && (p2 = true), p2 && (null === o2 || s2.contains(c2)) && (o2 = u2);
          }
          return o2;
        }, ke.prototype.findShell = function(t2) {
          for (var e3 = 0, n2 = null, i2 = t2.iterator(); i2.hasNext(); ) {
            var r2 = i2.next();
            r2.isHole() || (n2 = r2, e3++);
          }
          return et.isTrue(e3 <= 1, "found two shells in MinimalEdgeRing list"), n2;
        }, ke.prototype.add = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.add(t2.getEdgeEnds(), t2.getNodes());
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            Ye.linkResultDirectedEdges(n2);
            var i2 = this.buildMaximalEdgeRings(e3), r2 = new Nt(), o2 = this.buildMinimalEdgeRings(i2, this._shellList, r2);
            this.sortShellsAndHoles(o2, this._shellList, r2), this.placeFreeHoles(this._shellList, r2);
          }
        }, ke.prototype.interfaces_ = function() {
          return [];
        }, ke.prototype.getClass = function() {
          return ke;
        };
        var je = function() {
        };
        je.prototype.getBounds = function() {
        }, je.prototype.interfaces_ = function() {
          return [];
        }, je.prototype.getClass = function() {
          return je;
        };
        var He = function() {
          this._bounds = null, this._item = null;
          var t2 = arguments[0], e3 = arguments[1];
          this._bounds = t2, this._item = e3;
        };
        He.prototype.getItem = function() {
          return this._item;
        }, He.prototype.getBounds = function() {
          return this._bounds;
        }, He.prototype.interfaces_ = function() {
          return [je, e];
        }, He.prototype.getClass = function() {
          return He;
        };
        var We = function() {
          this._size = null, this._items = null, this._size = 0, this._items = new Nt(), this._items.add(null);
        };
        We.prototype.poll = function() {
          if (this.isEmpty())
            return null;
          var t2 = this._items.get(1);
          return this._items.set(1, this._items.get(this._size)), this._size -= 1, this.reorder(1), t2;
        }, We.prototype.size = function() {
          return this._size;
        }, We.prototype.reorder = function(t2) {
          for (var e3 = null, n2 = this._items.get(t2); 2 * t2 <= this._size && ((e3 = 2 * t2) !== this._size && this._items.get(e3 + 1).compareTo(this._items.get(e3)) < 0 && e3++, this._items.get(e3).compareTo(n2) < 0); t2 = e3)
            this._items.set(t2, this._items.get(e3));
          this._items.set(t2, n2);
        }, We.prototype.clear = function() {
          this._size = 0, this._items.clear();
        }, We.prototype.isEmpty = function() {
          return 0 === this._size;
        }, We.prototype.add = function(t2) {
          this._items.add(null), this._size += 1;
          var e3 = this._size;
          for (this._items.set(0, t2); t2.compareTo(this._items.get(Math.trunc(e3 / 2))) < 0; e3 /= 2)
            this._items.set(e3, this._items.get(Math.trunc(e3 / 2)));
          this._items.set(e3, t2);
        }, We.prototype.interfaces_ = function() {
          return [];
        }, We.prototype.getClass = function() {
          return We;
        };
        var Ke = function() {
        };
        Ke.prototype.visitItem = function(t2) {
        }, Ke.prototype.interfaces_ = function() {
          return [];
        }, Ke.prototype.getClass = function() {
          return Ke;
        };
        var Je = function() {
        };
        Je.prototype.insert = function(t2, e3) {
        }, Je.prototype.remove = function(t2, e3) {
        }, Je.prototype.query = function() {
        }, Je.prototype.interfaces_ = function() {
          return [];
        }, Je.prototype.getClass = function() {
          return Je;
        };
        var Qe = function() {
          if (this._childBoundables = new Nt(), this._bounds = null, this._level = null, 0 === arguments.length)
            ;
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            this._level = t2;
          }
        }, Ze = { serialVersionUID: { configurable: true } };
        Qe.prototype.getLevel = function() {
          return this._level;
        }, Qe.prototype.size = function() {
          return this._childBoundables.size();
        }, Qe.prototype.getChildBoundables = function() {
          return this._childBoundables;
        }, Qe.prototype.addChildBoundable = function(t2) {
          et.isTrue(null === this._bounds), this._childBoundables.add(t2);
        }, Qe.prototype.isEmpty = function() {
          return this._childBoundables.isEmpty();
        }, Qe.prototype.getBounds = function() {
          return null === this._bounds && (this._bounds = this.computeBounds()), this._bounds;
        }, Qe.prototype.interfaces_ = function() {
          return [je, e];
        }, Qe.prototype.getClass = function() {
          return Qe;
        }, Ze.serialVersionUID.get = function() {
          return 6493722185909574e3;
        }, Object.defineProperties(Qe, Ze);
        var $e = function() {
        };
        $e.reverseOrder = function() {
          return { compare: function(t2, e3) {
            return e3.compareTo(t2);
          } };
        }, $e.min = function(t2) {
          return $e.sort(t2), t2.get(0);
        }, $e.sort = function(t2, e3) {
          var n2 = t2.toArray();
          e3 ? Gt.sort(n2, e3) : Gt.sort(n2);
          for (var i2 = t2.iterator(), r2 = 0, o2 = n2.length; r2 < o2; r2++)
            i2.next(), i2.set(n2[r2]);
        }, $e.singletonList = function(t2) {
          var e3 = new Nt();
          return e3.add(t2), e3;
        };
        var tn = function() {
          this._boundable1 = null, this._boundable2 = null, this._distance = null, this._itemDistance = null;
          var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
          this._boundable1 = t2, this._boundable2 = e3, this._itemDistance = n2, this._distance = this.distance();
        };
        tn.prototype.expandToQueue = function(t2, e3) {
          var n2 = tn.isComposite(this._boundable1), i2 = tn.isComposite(this._boundable2);
          if (n2 && i2)
            return tn.area(this._boundable1) > tn.area(this._boundable2) ? (this.expand(this._boundable1, this._boundable2, t2, e3), null) : (this.expand(this._boundable2, this._boundable1, t2, e3), null);
          if (n2)
            return this.expand(this._boundable1, this._boundable2, t2, e3), null;
          if (i2)
            return this.expand(this._boundable2, this._boundable1, t2, e3), null;
          throw new m("neither boundable is composite");
        }, tn.prototype.isLeaves = function() {
          return !(tn.isComposite(this._boundable1) || tn.isComposite(this._boundable2));
        }, tn.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this._distance < e3._distance ? -1 : this._distance > e3._distance ? 1 : 0;
        }, tn.prototype.expand = function(t2, e3, n2, i2) {
          for (var r2 = t2.getChildBoundables().iterator(); r2.hasNext(); ) {
            var o2 = r2.next(), s2 = new tn(o2, e3, this._itemDistance);
            s2.getDistance() < i2 && n2.add(s2);
          }
        }, tn.prototype.getBoundable = function(t2) {
          return 0 === t2 ? this._boundable1 : this._boundable2;
        }, tn.prototype.getDistance = function() {
          return this._distance;
        }, tn.prototype.distance = function() {
          return this.isLeaves() ? this._itemDistance.distance(this._boundable1, this._boundable2) : this._boundable1.getBounds().distance(this._boundable2.getBounds());
        }, tn.prototype.interfaces_ = function() {
          return [E];
        }, tn.prototype.getClass = function() {
          return tn;
        }, tn.area = function(t2) {
          return t2.getBounds().getArea();
        }, tn.isComposite = function(t2) {
          return t2 instanceof Qe;
        };
        var en = function t2() {
          if (this._root = null, this._built = false, this._itemBoundables = new Nt(), this._nodeCapacity = null, 0 === arguments.length) {
            var e3 = t2.DEFAULT_NODE_CAPACITY;
            this._nodeCapacity = e3;
          } else if (1 === arguments.length) {
            var n2 = arguments[0];
            et.isTrue(n2 > 1, "Node capacity must be greater than 1"), this._nodeCapacity = n2;
          }
        }, nn = { IntersectsOp: { configurable: true }, serialVersionUID: { configurable: true }, DEFAULT_NODE_CAPACITY: { configurable: true } };
        en.prototype.getNodeCapacity = function() {
          return this._nodeCapacity;
        }, en.prototype.lastNode = function(t2) {
          return t2.get(t2.size() - 1);
        }, en.prototype.size = function() {
          if (0 === arguments.length)
            return this.isEmpty() ? 0 : (this.build(), this.size(this._root));
          if (1 === arguments.length) {
            for (var t2 = 0, e3 = arguments[0].getChildBoundables().iterator(); e3.hasNext(); ) {
              var n2 = e3.next();
              n2 instanceof Qe ? t2 += this.size(n2) : n2 instanceof He && (t2 += 1);
            }
            return t2;
          }
        }, en.prototype.removeItem = function(t2, e3) {
          for (var n2 = null, i2 = t2.getChildBoundables().iterator(); i2.hasNext(); ) {
            var r2 = i2.next();
            r2 instanceof He && r2.getItem() === e3 && (n2 = r2);
          }
          return null !== n2 && (t2.getChildBoundables().remove(n2), true);
        }, en.prototype.itemsTree = function() {
          if (0 === arguments.length) {
            this.build();
            var t2 = this.itemsTree(this._root);
            return null === t2 ? new Nt() : t2;
          }
          if (1 === arguments.length) {
            for (var e3 = arguments[0], n2 = new Nt(), i2 = e3.getChildBoundables().iterator(); i2.hasNext(); ) {
              var r2 = i2.next();
              if (r2 instanceof Qe) {
                var o2 = this.itemsTree(r2);
                null !== o2 && n2.add(o2);
              } else
                r2 instanceof He ? n2.add(r2.getItem()) : et.shouldNeverReachHere();
            }
            return n2.size() <= 0 ? null : n2;
          }
        }, en.prototype.insert = function(t2, e3) {
          et.isTrue(!this._built, "Cannot insert items into an STR packed R-tree after it has been built."), this._itemBoundables.add(new He(t2, e3));
        }, en.prototype.boundablesAtLevel = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0], e3 = new Nt();
            return this.boundablesAtLevel(t2, this._root, e3), e3;
          }
          if (3 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2];
            if (et.isTrue(n2 > -2), i2.getLevel() === n2)
              return r2.add(i2), null;
            for (var o2 = i2.getChildBoundables().iterator(); o2.hasNext(); ) {
              var s2 = o2.next();
              s2 instanceof Qe ? this.boundablesAtLevel(n2, s2, r2) : (et.isTrue(s2 instanceof He), -1 === n2 && r2.add(s2));
            }
            return null;
          }
        }, en.prototype.query = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.build();
            var e3 = new Nt();
            return this.isEmpty() ? e3 : (this.getIntersectsOp().intersects(this._root.getBounds(), t2) && this.query(t2, this._root, e3), e3);
          }
          if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            if (this.build(), this.isEmpty())
              return null;
            this.getIntersectsOp().intersects(this._root.getBounds(), n2) && this.query(n2, this._root, i2);
          } else if (3 === arguments.length) {
            if (T(arguments[2], Ke) && arguments[0] instanceof Object && arguments[1] instanceof Qe)
              for (var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2], a2 = o2.getChildBoundables(), u2 = 0; u2 < a2.size(); u2++) {
                var l2 = a2.get(u2);
                this.getIntersectsOp().intersects(l2.getBounds(), r2) && (l2 instanceof Qe ? this.query(r2, l2, s2) : l2 instanceof He ? s2.visitItem(l2.getItem()) : et.shouldNeverReachHere());
              }
            else if (T(arguments[2], xt) && arguments[0] instanceof Object && arguments[1] instanceof Qe)
              for (var c2 = arguments[0], p2 = arguments[1], h2 = arguments[2], f2 = p2.getChildBoundables(), g2 = 0; g2 < f2.size(); g2++) {
                var d2 = f2.get(g2);
                this.getIntersectsOp().intersects(d2.getBounds(), c2) && (d2 instanceof Qe ? this.query(c2, d2, h2) : d2 instanceof He ? h2.add(d2.getItem()) : et.shouldNeverReachHere());
              }
          }
        }, en.prototype.build = function() {
          if (this._built)
            return null;
          this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1), this._itemBoundables = null, this._built = true;
        }, en.prototype.getRoot = function() {
          return this.build(), this._root;
        }, en.prototype.remove = function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            return this.build(), !!this.getIntersectsOp().intersects(this._root.getBounds(), t2) && this.remove(t2, this._root, e3);
          }
          if (3 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2], o2 = this.removeItem(i2, r2);
            if (o2)
              return true;
            for (var s2 = null, a2 = i2.getChildBoundables().iterator(); a2.hasNext(); ) {
              var u2 = a2.next();
              if (this.getIntersectsOp().intersects(u2.getBounds(), n2) && (u2 instanceof Qe && (o2 = this.remove(n2, u2, r2)))) {
                s2 = u2;
                break;
              }
            }
            return null !== s2 && s2.getChildBoundables().isEmpty() && i2.getChildBoundables().remove(s2), o2;
          }
        }, en.prototype.createHigherLevels = function(t2, e3) {
          et.isTrue(!t2.isEmpty());
          var n2 = this.createParentBoundables(t2, e3 + 1);
          return 1 === n2.size() ? n2.get(0) : this.createHigherLevels(n2, e3 + 1);
        }, en.prototype.depth = function() {
          if (0 === arguments.length)
            return this.isEmpty() ? 0 : (this.build(), this.depth(this._root));
          if (1 === arguments.length) {
            for (var t2 = 0, e3 = arguments[0].getChildBoundables().iterator(); e3.hasNext(); ) {
              var n2 = e3.next();
              if (n2 instanceof Qe) {
                var i2 = this.depth(n2);
                i2 > t2 && (t2 = i2);
              }
            }
            return t2 + 1;
          }
        }, en.prototype.createParentBoundables = function(t2, e3) {
          et.isTrue(!t2.isEmpty());
          var n2 = new Nt();
          n2.add(this.createNode(e3));
          var i2 = new Nt(t2);
          $e.sort(i2, this.getComparator());
          for (var r2 = i2.iterator(); r2.hasNext(); ) {
            var o2 = r2.next();
            this.lastNode(n2).getChildBoundables().size() === this.getNodeCapacity() && n2.add(this.createNode(e3)), this.lastNode(n2).addChildBoundable(o2);
          }
          return n2;
        }, en.prototype.isEmpty = function() {
          return this._built ? this._root.isEmpty() : this._itemBoundables.isEmpty();
        }, en.prototype.interfaces_ = function() {
          return [e];
        }, en.prototype.getClass = function() {
          return en;
        }, en.compareDoubles = function(t2, e3) {
          return t2 > e3 ? 1 : t2 < e3 ? -1 : 0;
        }, nn.IntersectsOp.get = function() {
          return rn;
        }, nn.serialVersionUID.get = function() {
          return -3886435814360241e3;
        }, nn.DEFAULT_NODE_CAPACITY.get = function() {
          return 10;
        }, Object.defineProperties(en, nn);
        var rn = function() {
        }, on = function() {
        };
        on.prototype.distance = function(t2, e3) {
        }, on.prototype.interfaces_ = function() {
          return [];
        }, on.prototype.getClass = function() {
          return on;
        };
        var sn = function(t2) {
          function n2(e3) {
            e3 = e3 || n2.DEFAULT_NODE_CAPACITY, t2.call(this, e3);
          }
          t2 && (n2.__proto__ = t2), (n2.prototype = Object.create(t2 && t2.prototype)).constructor = n2;
          var i2 = { STRtreeNode: { configurable: true }, serialVersionUID: { configurable: true }, xComparator: { configurable: true }, yComparator: { configurable: true }, intersectsOp: { configurable: true }, DEFAULT_NODE_CAPACITY: { configurable: true } };
          return n2.prototype.createParentBoundablesFromVerticalSlices = function(t3, e3) {
            et.isTrue(t3.length > 0);
            for (var n3 = new Nt(), i3 = 0; i3 < t3.length; i3++)
              n3.addAll(this.createParentBoundablesFromVerticalSlice(t3[i3], e3));
            return n3;
          }, n2.prototype.createNode = function(t3) {
            return new an(t3);
          }, n2.prototype.size = function() {
            return 0 === arguments.length ? t2.prototype.size.call(this) : t2.prototype.size.apply(this, arguments);
          }, n2.prototype.insert = function() {
            if (2 !== arguments.length)
              return t2.prototype.insert.apply(this, arguments);
            var e3 = arguments[0], n3 = arguments[1];
            if (e3.isNull())
              return null;
            t2.prototype.insert.call(this, e3, n3);
          }, n2.prototype.getIntersectsOp = function() {
            return n2.intersectsOp;
          }, n2.prototype.verticalSlices = function(t3, e3) {
            for (var n3 = Math.trunc(Math.ceil(t3.size() / e3)), i3 = new Array(e3).fill(null), r2 = t3.iterator(), o2 = 0; o2 < e3; o2++) {
              i3[o2] = new Nt();
              for (var s2 = 0; r2.hasNext() && s2 < n3; ) {
                var a2 = r2.next();
                i3[o2].add(a2), s2++;
              }
            }
            return i3;
          }, n2.prototype.query = function() {
            if (1 === arguments.length) {
              var e3 = arguments[0];
              return t2.prototype.query.call(this, e3);
            }
            if (2 === arguments.length) {
              var n3 = arguments[0], i3 = arguments[1];
              t2.prototype.query.call(this, n3, i3);
            } else if (3 === arguments.length) {
              if (T(arguments[2], Ke) && arguments[0] instanceof Object && arguments[1] instanceof Qe) {
                var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2];
                t2.prototype.query.call(this, r2, o2, s2);
              } else if (T(arguments[2], xt) && arguments[0] instanceof Object && arguments[1] instanceof Qe) {
                var a2 = arguments[0], u2 = arguments[1], l2 = arguments[2];
                t2.prototype.query.call(this, a2, u2, l2);
              }
            }
          }, n2.prototype.getComparator = function() {
            return n2.yComparator;
          }, n2.prototype.createParentBoundablesFromVerticalSlice = function(e3, n3) {
            return t2.prototype.createParentBoundables.call(this, e3, n3);
          }, n2.prototype.remove = function() {
            if (2 === arguments.length) {
              var e3 = arguments[0], n3 = arguments[1];
              return t2.prototype.remove.call(this, e3, n3);
            }
            return t2.prototype.remove.apply(this, arguments);
          }, n2.prototype.depth = function() {
            return 0 === arguments.length ? t2.prototype.depth.call(this) : t2.prototype.depth.apply(this, arguments);
          }, n2.prototype.createParentBoundables = function(t3, e3) {
            et.isTrue(!t3.isEmpty());
            var i3 = Math.trunc(Math.ceil(t3.size() / this.getNodeCapacity())), r2 = new Nt(t3);
            $e.sort(r2, n2.xComparator);
            var o2 = this.verticalSlices(r2, Math.trunc(Math.ceil(Math.sqrt(i3))));
            return this.createParentBoundablesFromVerticalSlices(o2, e3);
          }, n2.prototype.nearestNeighbour = function() {
            if (1 === arguments.length) {
              if (T(arguments[0], on)) {
                var t3 = arguments[0], e3 = new tn(this.getRoot(), this.getRoot(), t3);
                return this.nearestNeighbour(e3);
              }
              if (arguments[0] instanceof tn) {
                var i3 = arguments[0];
                return this.nearestNeighbour(i3, v.POSITIVE_INFINITY);
              }
            } else if (2 === arguments.length) {
              if (arguments[0] instanceof n2 && T(arguments[1], on)) {
                var r2 = arguments[0], o2 = arguments[1], s2 = new tn(this.getRoot(), r2.getRoot(), o2);
                return this.nearestNeighbour(s2);
              }
              if (arguments[0] instanceof tn && "number" == typeof arguments[1]) {
                var a2 = arguments[0], u2 = arguments[1], l2 = null, c2 = new We();
                for (c2.add(a2); !c2.isEmpty() && u2 > 0; ) {
                  var p2 = c2.poll(), h2 = p2.getDistance();
                  if (h2 >= u2)
                    break;
                  p2.isLeaves() ? (u2 = h2, l2 = p2) : p2.expandToQueue(c2, u2);
                }
                return [l2.getBoundable(0).getItem(), l2.getBoundable(1).getItem()];
              }
            } else if (3 === arguments.length) {
              var f2 = arguments[0], g2 = arguments[1], d2 = arguments[2], y3 = new He(f2, g2), _2 = new tn(this.getRoot(), y3, d2);
              return this.nearestNeighbour(_2)[0];
            }
          }, n2.prototype.interfaces_ = function() {
            return [Je, e];
          }, n2.prototype.getClass = function() {
            return n2;
          }, n2.centreX = function(t3) {
            return n2.avg(t3.getMinX(), t3.getMaxX());
          }, n2.avg = function(t3, e3) {
            return (t3 + e3) / 2;
          }, n2.centreY = function(t3) {
            return n2.avg(t3.getMinY(), t3.getMaxY());
          }, i2.STRtreeNode.get = function() {
            return an;
          }, i2.serialVersionUID.get = function() {
            return 259274702368956900;
          }, i2.xComparator.get = function() {
            return { interfaces_: function() {
              return [N];
            }, compare: function(e3, i3) {
              return t2.compareDoubles(n2.centreX(e3.getBounds()), n2.centreX(i3.getBounds()));
            } };
          }, i2.yComparator.get = function() {
            return { interfaces_: function() {
              return [N];
            }, compare: function(e3, i3) {
              return t2.compareDoubles(n2.centreY(e3.getBounds()), n2.centreY(i3.getBounds()));
            } };
          }, i2.intersectsOp.get = function() {
            return { interfaces_: function() {
              return [t2.IntersectsOp];
            }, intersects: function(t3, e3) {
              return t3.intersects(e3);
            } };
          }, i2.DEFAULT_NODE_CAPACITY.get = function() {
            return 10;
          }, Object.defineProperties(n2, i2), n2;
        }(en), an = function(t2) {
          function e3() {
            var e4 = arguments[0];
            t2.call(this, e4);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.computeBounds = function() {
            for (var t3 = null, e4 = this.getChildBoundables().iterator(); e4.hasNext(); ) {
              var n2 = e4.next();
              null === t3 ? t3 = new j(n2.getBounds()) : t3.expandToInclude(n2.getBounds());
            }
            return t3;
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(Qe), un = function() {
        };
        un.prototype.interfaces_ = function() {
          return [];
        }, un.prototype.getClass = function() {
          return un;
        }, un.relativeSign = function(t2, e3) {
          return t2 < e3 ? -1 : t2 > e3 ? 1 : 0;
        }, un.compare = function(t2, e3, n2) {
          if (e3.equals2D(n2))
            return 0;
          var i2 = un.relativeSign(e3.x, n2.x), r2 = un.relativeSign(e3.y, n2.y);
          switch (t2) {
            case 0:
              return un.compareValue(i2, r2);
            case 1:
              return un.compareValue(r2, i2);
            case 2:
              return un.compareValue(r2, -i2);
            case 3:
              return un.compareValue(-i2, r2);
            case 4:
              return un.compareValue(-i2, -r2);
            case 5:
              return un.compareValue(-r2, -i2);
            case 6:
              return un.compareValue(-r2, i2);
            case 7:
              return un.compareValue(i2, -r2);
          }
          return et.shouldNeverReachHere("invalid octant value"), 0;
        }, un.compareValue = function(t2, e3) {
          return t2 < 0 ? -1 : t2 > 0 ? 1 : e3 < 0 ? -1 : e3 > 0 ? 1 : 0;
        };
        var ln = function() {
          this._segString = null, this.coord = null, this.segmentIndex = null, this._segmentOctant = null, this._isInterior = null;
          var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2], i2 = arguments[3];
          this._segString = t2, this.coord = new C(e3), this.segmentIndex = n2, this._segmentOctant = i2, this._isInterior = !e3.equals2D(t2.getCoordinate(n2));
        };
        ln.prototype.getCoordinate = function() {
          return this.coord;
        }, ln.prototype.print = function(t2) {
          t2.print(this.coord), t2.print(" seg # = " + this.segmentIndex);
        }, ln.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this.segmentIndex < e3.segmentIndex ? -1 : this.segmentIndex > e3.segmentIndex ? 1 : this.coord.equals2D(e3.coord) ? 0 : un.compare(this._segmentOctant, this.coord, e3.coord);
        }, ln.prototype.isEndPoint = function(t2) {
          return 0 === this.segmentIndex && !this._isInterior || this.segmentIndex === t2;
        }, ln.prototype.isInterior = function() {
          return this._isInterior;
        }, ln.prototype.interfaces_ = function() {
          return [E];
        }, ln.prototype.getClass = function() {
          return ln;
        };
        var cn = function() {
          this._nodeMap = new p(), this._edge = null;
          var t2 = arguments[0];
          this._edge = t2;
        };
        cn.prototype.getSplitCoordinates = function() {
          var t2 = new St();
          this.addEndpoints();
          for (var e3 = this.iterator(), n2 = e3.next(); e3.hasNext(); ) {
            var i2 = e3.next();
            this.addEdgeCoordinates(n2, i2, t2), n2 = i2;
          }
          return t2.toCoordinateArray();
        }, cn.prototype.addCollapsedNodes = function() {
          var t2 = new Nt();
          this.findCollapsesFromInsertedNodes(t2), this.findCollapsesFromExistingVertices(t2);
          for (var e3 = t2.iterator(); e3.hasNext(); ) {
            var n2 = e3.next().intValue();
            this.add(this._edge.getCoordinate(n2), n2);
          }
        }, cn.prototype.print = function(t2) {
          t2.println("Intersections:");
          for (var e3 = this.iterator(); e3.hasNext(); ) {
            e3.next().print(t2);
          }
        }, cn.prototype.findCollapsesFromExistingVertices = function(t2) {
          for (var e3 = 0; e3 < this._edge.size() - 2; e3++) {
            var n2 = this._edge.getCoordinate(e3), i2 = this._edge.getCoordinate(e3 + 2);
            n2.equals2D(i2) && t2.add(new M(e3 + 1));
          }
        }, cn.prototype.addEdgeCoordinates = function(t2, e3, n2) {
          var i2 = this._edge.getCoordinate(e3.segmentIndex), r2 = e3.isInterior() || !e3.coord.equals2D(i2);
          n2.add(new C(t2.coord), false);
          for (var o2 = t2.segmentIndex + 1; o2 <= e3.segmentIndex; o2++)
            n2.add(this._edge.getCoordinate(o2));
          r2 && n2.add(new C(e3.coord));
        }, cn.prototype.iterator = function() {
          return this._nodeMap.values().iterator();
        }, cn.prototype.addSplitEdges = function(t2) {
          this.addEndpoints(), this.addCollapsedNodes();
          for (var e3 = this.iterator(), n2 = e3.next(); e3.hasNext(); ) {
            var i2 = e3.next(), r2 = this.createSplitEdge(n2, i2);
            t2.add(r2), n2 = i2;
          }
        }, cn.prototype.findCollapseIndex = function(t2, e3, n2) {
          if (!t2.coord.equals2D(e3.coord))
            return false;
          var i2 = e3.segmentIndex - t2.segmentIndex;
          return e3.isInterior() || i2--, 1 === i2 && (n2[0] = t2.segmentIndex + 1, true);
        }, cn.prototype.findCollapsesFromInsertedNodes = function(t2) {
          for (var e3 = new Array(1).fill(null), n2 = this.iterator(), i2 = n2.next(); n2.hasNext(); ) {
            var r2 = n2.next();
            this.findCollapseIndex(i2, r2, e3) && t2.add(new M(e3[0])), i2 = r2;
          }
        }, cn.prototype.getEdge = function() {
          return this._edge;
        }, cn.prototype.addEndpoints = function() {
          var t2 = this._edge.size() - 1;
          this.add(this._edge.getCoordinate(0), 0), this.add(this._edge.getCoordinate(t2), t2);
        }, cn.prototype.createSplitEdge = function(t2, e3) {
          var n2 = e3.segmentIndex - t2.segmentIndex + 2, i2 = this._edge.getCoordinate(e3.segmentIndex), r2 = e3.isInterior() || !e3.coord.equals2D(i2);
          r2 || n2--;
          var o2 = new Array(n2).fill(null), s2 = 0;
          o2[s2++] = new C(t2.coord);
          for (var a2 = t2.segmentIndex + 1; a2 <= e3.segmentIndex; a2++)
            o2[s2++] = this._edge.getCoordinate(a2);
          return r2 && (o2[s2] = new C(e3.coord)), new gn(o2, this._edge.getData());
        }, cn.prototype.add = function(t2, e3) {
          var n2 = new ln(this._edge, t2, e3, this._edge.getSegmentOctant(e3)), i2 = this._nodeMap.get(n2);
          return null !== i2 ? (et.isTrue(i2.coord.equals2D(t2), "Found equal nodes with different coordinates"), i2) : (this._nodeMap.put(n2, n2), n2);
        }, cn.prototype.checkSplitEdgesCorrectness = function(t2) {
          var e3 = this._edge.getCoordinates(), n2 = t2.get(0).getCoordinate(0);
          if (!n2.equals2D(e3[0]))
            throw new $("bad split edge start point at " + n2);
          var i2 = t2.get(t2.size() - 1).getCoordinates(), r2 = i2[i2.length - 1];
          if (!r2.equals2D(e3[e3.length - 1]))
            throw new $("bad split edge end point at " + r2);
        }, cn.prototype.interfaces_ = function() {
          return [];
        }, cn.prototype.getClass = function() {
          return cn;
        };
        var pn = function() {
        };
        pn.prototype.interfaces_ = function() {
          return [];
        }, pn.prototype.getClass = function() {
          return pn;
        }, pn.octant = function() {
          if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
            var t2 = arguments[0], e3 = arguments[1];
            if (0 === t2 && 0 === e3)
              throw new m("Cannot compute the octant for point ( " + t2 + ", " + e3 + " )");
            var n2 = Math.abs(t2), i2 = Math.abs(e3);
            return t2 >= 0 ? e3 >= 0 ? n2 >= i2 ? 0 : 1 : n2 >= i2 ? 7 : 6 : e3 >= 0 ? n2 >= i2 ? 3 : 2 : n2 >= i2 ? 4 : 5;
          }
          if (arguments[0] instanceof C && arguments[1] instanceof C) {
            var r2 = arguments[0], o2 = arguments[1], s2 = o2.x - r2.x, a2 = o2.y - r2.y;
            if (0 === s2 && 0 === a2)
              throw new m("Cannot compute the octant for two identical points " + r2);
            return pn.octant(s2, a2);
          }
        };
        var hn = function() {
        };
        hn.prototype.getCoordinates = function() {
        }, hn.prototype.size = function() {
        }, hn.prototype.getCoordinate = function(t2) {
        }, hn.prototype.isClosed = function() {
        }, hn.prototype.setData = function(t2) {
        }, hn.prototype.getData = function() {
        }, hn.prototype.interfaces_ = function() {
          return [];
        }, hn.prototype.getClass = function() {
          return hn;
        };
        var fn = function() {
        };
        fn.prototype.addIntersection = function(t2, e3) {
        }, fn.prototype.interfaces_ = function() {
          return [hn];
        }, fn.prototype.getClass = function() {
          return fn;
        };
        var gn = function() {
          this._nodeList = new cn(this), this._pts = null, this._data = null;
          var t2 = arguments[0], e3 = arguments[1];
          this._pts = t2, this._data = e3;
        };
        gn.prototype.getCoordinates = function() {
          return this._pts;
        }, gn.prototype.size = function() {
          return this._pts.length;
        }, gn.prototype.getCoordinate = function(t2) {
          return this._pts[t2];
        }, gn.prototype.isClosed = function() {
          return this._pts[0].equals(this._pts[this._pts.length - 1]);
        }, gn.prototype.getSegmentOctant = function(t2) {
          return t2 === this._pts.length - 1 ? -1 : this.safeOctant(this.getCoordinate(t2), this.getCoordinate(t2 + 1));
        }, gn.prototype.setData = function(t2) {
          this._data = t2;
        }, gn.prototype.safeOctant = function(t2, e3) {
          return t2.equals2D(e3) ? 0 : pn.octant(t2, e3);
        }, gn.prototype.getData = function() {
          return this._data;
        }, gn.prototype.addIntersection = function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            this.addIntersectionNode(t2, e3);
          } else if (4 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[3], o2 = new C(n2.getIntersection(r2));
            this.addIntersection(o2, i2);
          }
        }, gn.prototype.toString = function() {
          return Z.toLineString(new ue(this._pts));
        }, gn.prototype.getNodeList = function() {
          return this._nodeList;
        }, gn.prototype.addIntersectionNode = function(t2, e3) {
          var n2 = e3, i2 = n2 + 1;
          if (i2 < this._pts.length) {
            var r2 = this._pts[i2];
            t2.equals2D(r2) && (n2 = i2);
          }
          return this._nodeList.add(t2, n2);
        }, gn.prototype.addIntersections = function(t2, e3, n2) {
          for (var i2 = 0; i2 < t2.getIntersectionNum(); i2++)
            this.addIntersection(t2, e3, n2, i2);
        }, gn.prototype.interfaces_ = function() {
          return [fn];
        }, gn.prototype.getClass = function() {
          return gn;
        }, gn.getNodedSubstrings = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0], e3 = new Nt();
            return gn.getNodedSubstrings(t2, e3), e3;
          }
          if (2 === arguments.length)
            for (var n2 = arguments[0], i2 = arguments[1], r2 = n2.iterator(); r2.hasNext(); ) {
              r2.next().getNodeList().addSplitEdges(i2);
            }
        };
        var dn = function() {
          if (this.p0 = null, this.p1 = null, 0 === arguments.length)
            this.p0 = new C(), this.p1 = new C();
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            this.p0 = new C(t2.p0), this.p1 = new C(t2.p1);
          } else if (2 === arguments.length)
            this.p0 = arguments[0], this.p1 = arguments[1];
          else if (4 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1], i2 = arguments[2], r2 = arguments[3];
            this.p0 = new C(e3, n2), this.p1 = new C(i2, r2);
          }
        }, yn = { serialVersionUID: { configurable: true } };
        dn.prototype.minX = function() {
          return Math.min(this.p0.x, this.p1.x);
        }, dn.prototype.orientationIndex = function() {
          if (arguments[0] instanceof dn) {
            var t2 = arguments[0], e3 = at.orientationIndex(this.p0, this.p1, t2.p0), n2 = at.orientationIndex(this.p0, this.p1, t2.p1);
            return e3 >= 0 && n2 >= 0 ? Math.max(e3, n2) : e3 <= 0 && n2 <= 0 ? Math.max(e3, n2) : 0;
          }
          if (arguments[0] instanceof C) {
            var i2 = arguments[0];
            return at.orientationIndex(this.p0, this.p1, i2);
          }
        }, dn.prototype.toGeometry = function(t2) {
          return t2.createLineString([this.p0, this.p1]);
        }, dn.prototype.isVertical = function() {
          return this.p0.x === this.p1.x;
        }, dn.prototype.equals = function(t2) {
          if (!(t2 instanceof dn))
            return false;
          var e3 = t2;
          return this.p0.equals(e3.p0) && this.p1.equals(e3.p1);
        }, dn.prototype.intersection = function(t2) {
          var e3 = new rt();
          return e3.computeIntersection(this.p0, this.p1, t2.p0, t2.p1), e3.hasIntersection() ? e3.getIntersection(0) : null;
        }, dn.prototype.project = function() {
          if (arguments[0] instanceof C) {
            var t2 = arguments[0];
            if (t2.equals(this.p0) || t2.equals(this.p1))
              return new C(t2);
            var e3 = this.projectionFactor(t2), n2 = new C();
            return n2.x = this.p0.x + e3 * (this.p1.x - this.p0.x), n2.y = this.p0.y + e3 * (this.p1.y - this.p0.y), n2;
          }
          if (arguments[0] instanceof dn) {
            var i2 = arguments[0], r2 = this.projectionFactor(i2.p0), o2 = this.projectionFactor(i2.p1);
            if (r2 >= 1 && o2 >= 1)
              return null;
            if (r2 <= 0 && o2 <= 0)
              return null;
            var s2 = this.project(i2.p0);
            r2 < 0 && (s2 = this.p0), r2 > 1 && (s2 = this.p1);
            var a2 = this.project(i2.p1);
            return o2 < 0 && (a2 = this.p0), o2 > 1 && (a2 = this.p1), new dn(s2, a2);
          }
        }, dn.prototype.normalize = function() {
          this.p1.compareTo(this.p0) < 0 && this.reverse();
        }, dn.prototype.angle = function() {
          return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);
        }, dn.prototype.getCoordinate = function(t2) {
          return 0 === t2 ? this.p0 : this.p1;
        }, dn.prototype.distancePerpendicular = function(t2) {
          return at.distancePointLinePerpendicular(t2, this.p0, this.p1);
        }, dn.prototype.minY = function() {
          return Math.min(this.p0.y, this.p1.y);
        }, dn.prototype.midPoint = function() {
          return dn.midPoint(this.p0, this.p1);
        }, dn.prototype.projectionFactor = function(t2) {
          if (t2.equals(this.p0))
            return 0;
          if (t2.equals(this.p1))
            return 1;
          var e3 = this.p1.x - this.p0.x, n2 = this.p1.y - this.p0.y, i2 = e3 * e3 + n2 * n2;
          if (i2 <= 0)
            return v.NaN;
          return ((t2.x - this.p0.x) * e3 + (t2.y - this.p0.y) * n2) / i2;
        }, dn.prototype.closestPoints = function(t2) {
          var e3 = this.intersection(t2);
          if (null !== e3)
            return [e3, e3];
          var n2 = new Array(2).fill(null), i2 = v.MAX_VALUE, r2 = null, o2 = this.closestPoint(t2.p0);
          i2 = o2.distance(t2.p0), n2[0] = o2, n2[1] = t2.p0;
          var s2 = this.closestPoint(t2.p1);
          (r2 = s2.distance(t2.p1)) < i2 && (i2 = r2, n2[0] = s2, n2[1] = t2.p1);
          var a2 = t2.closestPoint(this.p0);
          (r2 = a2.distance(this.p0)) < i2 && (i2 = r2, n2[0] = this.p0, n2[1] = a2);
          var u2 = t2.closestPoint(this.p1);
          return (r2 = u2.distance(this.p1)) < i2 && (i2 = r2, n2[0] = this.p1, n2[1] = u2), n2;
        }, dn.prototype.closestPoint = function(t2) {
          var e3 = this.projectionFactor(t2);
          if (e3 > 0 && e3 < 1)
            return this.project(t2);
          return this.p0.distance(t2) < this.p1.distance(t2) ? this.p0 : this.p1;
        }, dn.prototype.maxX = function() {
          return Math.max(this.p0.x, this.p1.x);
        }, dn.prototype.getLength = function() {
          return this.p0.distance(this.p1);
        }, dn.prototype.compareTo = function(t2) {
          var e3 = t2, n2 = this.p0.compareTo(e3.p0);
          return 0 !== n2 ? n2 : this.p1.compareTo(e3.p1);
        }, dn.prototype.reverse = function() {
          var t2 = this.p0;
          this.p0 = this.p1, this.p1 = t2;
        }, dn.prototype.equalsTopo = function(t2) {
          return this.p0.equals(t2.p0) && (this.p1.equals(t2.p1) || this.p0.equals(t2.p1)) && this.p1.equals(t2.p0);
        }, dn.prototype.lineIntersection = function(t2) {
          try {
            return k.intersection(this.p0, this.p1, t2.p0, t2.p1);
          } catch (t3) {
            if (!(t3 instanceof X))
              throw t3;
          }
          return null;
        }, dn.prototype.maxY = function() {
          return Math.max(this.p0.y, this.p1.y);
        }, dn.prototype.pointAlongOffset = function(t2, e3) {
          var n2 = this.p0.x + t2 * (this.p1.x - this.p0.x), i2 = this.p0.y + t2 * (this.p1.y - this.p0.y), r2 = this.p1.x - this.p0.x, o2 = this.p1.y - this.p0.y, s2 = Math.sqrt(r2 * r2 + o2 * o2), a2 = 0, u2 = 0;
          if (0 !== e3) {
            if (s2 <= 0)
              throw new Error("Cannot compute offset from zero-length line segment");
            a2 = e3 * r2 / s2, u2 = e3 * o2 / s2;
          }
          return new C(n2 - u2, i2 + a2);
        }, dn.prototype.setCoordinates = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.setCoordinates(t2.p0, t2.p1);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            this.p0.x = e3.x, this.p0.y = e3.y, this.p1.x = n2.x, this.p1.y = n2.y;
          }
        }, dn.prototype.segmentFraction = function(t2) {
          var e3 = this.projectionFactor(t2);
          return e3 < 0 ? e3 = 0 : (e3 > 1 || v.isNaN(e3)) && (e3 = 1), e3;
        }, dn.prototype.toString = function() {
          return "LINESTRING( " + this.p0.x + " " + this.p0.y + ", " + this.p1.x + " " + this.p1.y + ")";
        }, dn.prototype.isHorizontal = function() {
          return this.p0.y === this.p1.y;
        }, dn.prototype.distance = function() {
          if (arguments[0] instanceof dn) {
            var t2 = arguments[0];
            return at.distanceLineLine(this.p0, this.p1, t2.p0, t2.p1);
          }
          if (arguments[0] instanceof C) {
            var e3 = arguments[0];
            return at.distancePointLine(e3, this.p0, this.p1);
          }
        }, dn.prototype.pointAlong = function(t2) {
          var e3 = new C();
          return e3.x = this.p0.x + t2 * (this.p1.x - this.p0.x), e3.y = this.p0.y + t2 * (this.p1.y - this.p0.y), e3;
        }, dn.prototype.hashCode = function() {
          var t2 = v.doubleToLongBits(this.p0.x);
          t2 ^= 31 * v.doubleToLongBits(this.p0.y);
          var e3 = Math.trunc(t2) ^ Math.trunc(t2 >> 32), n2 = v.doubleToLongBits(this.p1.x);
          n2 ^= 31 * v.doubleToLongBits(this.p1.y);
          return e3 ^ (Math.trunc(n2) ^ Math.trunc(n2 >> 32));
        }, dn.prototype.interfaces_ = function() {
          return [E, e];
        }, dn.prototype.getClass = function() {
          return dn;
        }, dn.midPoint = function(t2, e3) {
          return new C((t2.x + e3.x) / 2, (t2.y + e3.y) / 2);
        }, yn.serialVersionUID.get = function() {
          return 3252005833466256400;
        }, Object.defineProperties(dn, yn);
        var _n = function() {
          this.tempEnv1 = new j(), this.tempEnv2 = new j(), this._overlapSeg1 = new dn(), this._overlapSeg2 = new dn();
        };
        _n.prototype.overlap = function() {
          if (2 === arguments.length)
            ;
          else if (4 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2], i2 = arguments[3];
            t2.getLineSegment(e3, this._overlapSeg1), n2.getLineSegment(i2, this._overlapSeg2), this.overlap(this._overlapSeg1, this._overlapSeg2);
          }
        }, _n.prototype.interfaces_ = function() {
          return [];
        }, _n.prototype.getClass = function() {
          return _n;
        };
        var mn = function() {
          this._pts = null, this._start = null, this._end = null, this._env = null, this._context = null, this._id = null;
          var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2], i2 = arguments[3];
          this._pts = t2, this._start = e3, this._end = n2, this._context = i2;
        };
        mn.prototype.getLineSegment = function(t2, e3) {
          e3.p0 = this._pts[t2], e3.p1 = this._pts[t2 + 1];
        }, mn.prototype.computeSelect = function(t2, e3, n2, i2) {
          var r2 = this._pts[e3], o2 = this._pts[n2];
          if (i2.tempEnv1.init(r2, o2), n2 - e3 == 1)
            return i2.select(this, e3), null;
          if (!t2.intersects(i2.tempEnv1))
            return null;
          var s2 = Math.trunc((e3 + n2) / 2);
          e3 < s2 && this.computeSelect(t2, e3, s2, i2), s2 < n2 && this.computeSelect(t2, s2, n2, i2);
        }, mn.prototype.getCoordinates = function() {
          for (var t2 = new Array(this._end - this._start + 1).fill(null), e3 = 0, n2 = this._start; n2 <= this._end; n2++)
            t2[e3++] = this._pts[n2];
          return t2;
        }, mn.prototype.computeOverlaps = function(t2, e3) {
          this.computeOverlapsInternal(this._start, this._end, t2, t2._start, t2._end, e3);
        }, mn.prototype.setId = function(t2) {
          this._id = t2;
        }, mn.prototype.select = function(t2, e3) {
          this.computeSelect(t2, this._start, this._end, e3);
        }, mn.prototype.getEnvelope = function() {
          if (null === this._env) {
            var t2 = this._pts[this._start], e3 = this._pts[this._end];
            this._env = new j(t2, e3);
          }
          return this._env;
        }, mn.prototype.getEndIndex = function() {
          return this._end;
        }, mn.prototype.getStartIndex = function() {
          return this._start;
        }, mn.prototype.getContext = function() {
          return this._context;
        }, mn.prototype.getId = function() {
          return this._id;
        }, mn.prototype.computeOverlapsInternal = function(t2, e3, n2, i2, r2, o2) {
          var s2 = this._pts[t2], a2 = this._pts[e3], u2 = n2._pts[i2], l2 = n2._pts[r2];
          if (e3 - t2 == 1 && r2 - i2 == 1)
            return o2.overlap(this, t2, n2, i2), null;
          if (o2.tempEnv1.init(s2, a2), o2.tempEnv2.init(u2, l2), !o2.tempEnv1.intersects(o2.tempEnv2))
            return null;
          var c2 = Math.trunc((t2 + e3) / 2), p2 = Math.trunc((i2 + r2) / 2);
          t2 < c2 && (i2 < p2 && this.computeOverlapsInternal(t2, c2, n2, i2, p2, o2), p2 < r2 && this.computeOverlapsInternal(t2, c2, n2, p2, r2, o2)), c2 < e3 && (i2 < p2 && this.computeOverlapsInternal(c2, e3, n2, i2, p2, o2), p2 < r2 && this.computeOverlapsInternal(c2, e3, n2, p2, r2, o2));
        }, mn.prototype.interfaces_ = function() {
          return [];
        }, mn.prototype.getClass = function() {
          return mn;
        };
        var vn = function() {
        };
        vn.prototype.interfaces_ = function() {
          return [];
        }, vn.prototype.getClass = function() {
          return vn;
        }, vn.getChainStartIndices = function(t2) {
          var e3 = 0, n2 = new Nt();
          n2.add(new M(e3));
          do {
            var i2 = vn.findChainEnd(t2, e3);
            n2.add(new M(i2)), e3 = i2;
          } while (e3 < t2.length - 1);
          return vn.toIntArray(n2);
        }, vn.findChainEnd = function(t2, e3) {
          for (var n2 = e3; n2 < t2.length - 1 && t2[n2].equals2D(t2[n2 + 1]); )
            n2++;
          if (n2 >= t2.length - 1)
            return t2.length - 1;
          for (var i2 = Be.quadrant(t2[n2], t2[n2 + 1]), r2 = e3 + 1; r2 < t2.length; ) {
            if (!t2[r2 - 1].equals2D(t2[r2])) {
              if (Be.quadrant(t2[r2 - 1], t2[r2]) !== i2)
                break;
            }
            r2++;
          }
          return r2 - 1;
        }, vn.getChains = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return vn.getChains(t2, null);
          }
          if (2 === arguments.length) {
            for (var e3 = arguments[0], n2 = arguments[1], i2 = new Nt(), r2 = vn.getChainStartIndices(e3), o2 = 0; o2 < r2.length - 1; o2++) {
              var s2 = new mn(e3, r2[o2], r2[o2 + 1], n2);
              i2.add(s2);
            }
            return i2;
          }
        }, vn.toIntArray = function(t2) {
          for (var e3 = new Array(t2.size()).fill(null), n2 = 0; n2 < e3.length; n2++)
            e3[n2] = t2.get(n2).intValue();
          return e3;
        };
        var In = function() {
        };
        In.prototype.computeNodes = function(t2) {
        }, In.prototype.getNodedSubstrings = function() {
        }, In.prototype.interfaces_ = function() {
          return [];
        }, In.prototype.getClass = function() {
          return In;
        };
        var En = function() {
          if (this._segInt = null, 0 === arguments.length)
            ;
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            this.setSegmentIntersector(t2);
          }
        };
        En.prototype.setSegmentIntersector = function(t2) {
          this._segInt = t2;
        }, En.prototype.interfaces_ = function() {
          return [In];
        }, En.prototype.getClass = function() {
          return En;
        };
        var xn = function(t2) {
          function e3(e4) {
            e4 ? t2.call(this, e4) : t2.call(this), this._monoChains = new Nt(), this._index = new sn(), this._idCounter = 0, this._nodedSegStrings = null, this._nOverlaps = 0;
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { SegmentOverlapAction: { configurable: true } };
          return e3.prototype.getMonotoneChains = function() {
            return this._monoChains;
          }, e3.prototype.getNodedSubstrings = function() {
            return gn.getNodedSubstrings(this._nodedSegStrings);
          }, e3.prototype.getIndex = function() {
            return this._index;
          }, e3.prototype.add = function(t3) {
            for (var e4 = vn.getChains(t3.getCoordinates(), t3).iterator(); e4.hasNext(); ) {
              var n3 = e4.next();
              n3.setId(this._idCounter++), this._index.insert(n3.getEnvelope(), n3), this._monoChains.add(n3);
            }
          }, e3.prototype.computeNodes = function(t3) {
            this._nodedSegStrings = t3;
            for (var e4 = t3.iterator(); e4.hasNext(); )
              this.add(e4.next());
            this.intersectChains();
          }, e3.prototype.intersectChains = function() {
            for (var t3 = new Nn(this._segInt), e4 = this._monoChains.iterator(); e4.hasNext(); )
              for (var n3 = e4.next(), i2 = this._index.query(n3.getEnvelope()).iterator(); i2.hasNext(); ) {
                var r2 = i2.next();
                if (r2.getId() > n3.getId() && (n3.computeOverlaps(r2, t3), this._nOverlaps++), this._segInt.isDone())
                  return null;
              }
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.SegmentOverlapAction.get = function() {
            return Nn;
          }, Object.defineProperties(e3, n2), e3;
        }(En), Nn = function(t2) {
          function e3() {
            t2.call(this), this._si = null;
            var e4 = arguments[0];
            this._si = e4;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.overlap = function() {
            if (4 !== arguments.length)
              return t2.prototype.overlap.apply(this, arguments);
            var e4 = arguments[0], n2 = arguments[1], i2 = arguments[2], r2 = arguments[3], o2 = e4.getContext(), s2 = i2.getContext();
            this._si.processIntersections(o2, n2, s2, r2);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(_n), Cn = function t2() {
          if (this._quadrantSegments = t2.DEFAULT_QUADRANT_SEGMENTS, this._endCapStyle = t2.CAP_ROUND, this._joinStyle = t2.JOIN_ROUND, this._mitreLimit = t2.DEFAULT_MITRE_LIMIT, this._isSingleSided = false, this._simplifyFactor = t2.DEFAULT_SIMPLIFY_FACTOR, 0 === arguments.length)
            ;
          else if (1 === arguments.length) {
            var e3 = arguments[0];
            this.setQuadrantSegments(e3);
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            this.setQuadrantSegments(n2), this.setEndCapStyle(i2);
          } else if (4 === arguments.length) {
            var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2], a2 = arguments[3];
            this.setQuadrantSegments(r2), this.setEndCapStyle(o2), this.setJoinStyle(s2), this.setMitreLimit(a2);
          }
        }, Sn = { CAP_ROUND: { configurable: true }, CAP_FLAT: { configurable: true }, CAP_SQUARE: { configurable: true }, JOIN_ROUND: { configurable: true }, JOIN_MITRE: { configurable: true }, JOIN_BEVEL: { configurable: true }, DEFAULT_QUADRANT_SEGMENTS: { configurable: true }, DEFAULT_MITRE_LIMIT: { configurable: true }, DEFAULT_SIMPLIFY_FACTOR: { configurable: true } };
        Cn.prototype.getEndCapStyle = function() {
          return this._endCapStyle;
        }, Cn.prototype.isSingleSided = function() {
          return this._isSingleSided;
        }, Cn.prototype.setQuadrantSegments = function(t2) {
          this._quadrantSegments = t2, 0 === this._quadrantSegments && (this._joinStyle = Cn.JOIN_BEVEL), this._quadrantSegments < 0 && (this._joinStyle = Cn.JOIN_MITRE, this._mitreLimit = Math.abs(this._quadrantSegments)), t2 <= 0 && (this._quadrantSegments = 1), this._joinStyle !== Cn.JOIN_ROUND && (this._quadrantSegments = Cn.DEFAULT_QUADRANT_SEGMENTS);
        }, Cn.prototype.getJoinStyle = function() {
          return this._joinStyle;
        }, Cn.prototype.setJoinStyle = function(t2) {
          this._joinStyle = t2;
        }, Cn.prototype.setSimplifyFactor = function(t2) {
          this._simplifyFactor = t2 < 0 ? 0 : t2;
        }, Cn.prototype.getSimplifyFactor = function() {
          return this._simplifyFactor;
        }, Cn.prototype.getQuadrantSegments = function() {
          return this._quadrantSegments;
        }, Cn.prototype.setEndCapStyle = function(t2) {
          this._endCapStyle = t2;
        }, Cn.prototype.getMitreLimit = function() {
          return this._mitreLimit;
        }, Cn.prototype.setMitreLimit = function(t2) {
          this._mitreLimit = t2;
        }, Cn.prototype.setSingleSided = function(t2) {
          this._isSingleSided = t2;
        }, Cn.prototype.interfaces_ = function() {
          return [];
        }, Cn.prototype.getClass = function() {
          return Cn;
        }, Cn.bufferDistanceError = function(t2) {
          var e3 = Math.PI / 2 / t2;
          return 1 - Math.cos(e3 / 2);
        }, Sn.CAP_ROUND.get = function() {
          return 1;
        }, Sn.CAP_FLAT.get = function() {
          return 2;
        }, Sn.CAP_SQUARE.get = function() {
          return 3;
        }, Sn.JOIN_ROUND.get = function() {
          return 1;
        }, Sn.JOIN_MITRE.get = function() {
          return 2;
        }, Sn.JOIN_BEVEL.get = function() {
          return 3;
        }, Sn.DEFAULT_QUADRANT_SEGMENTS.get = function() {
          return 8;
        }, Sn.DEFAULT_MITRE_LIMIT.get = function() {
          return 5;
        }, Sn.DEFAULT_SIMPLIFY_FACTOR.get = function() {
          return 0.01;
        }, Object.defineProperties(Cn, Sn);
        var Ln = function(t2) {
          this._distanceTol = null, this._isDeleted = null, this._angleOrientation = at.COUNTERCLOCKWISE, this._inputLine = t2 || null;
        }, bn = { INIT: { configurable: true }, DELETE: { configurable: true }, KEEP: { configurable: true }, NUM_PTS_TO_CHECK: { configurable: true } };
        Ln.prototype.isDeletable = function(t2, e3, n2, i2) {
          var r2 = this._inputLine[t2], o2 = this._inputLine[e3], s2 = this._inputLine[n2];
          return !!this.isConcave(r2, o2, s2) && (!!this.isShallow(r2, o2, s2, i2) && this.isShallowSampled(r2, o2, t2, n2, i2));
        }, Ln.prototype.deleteShallowConcavities = function() {
          for (var t2 = 1, e3 = this.findNextNonDeletedIndex(t2), n2 = this.findNextNonDeletedIndex(e3), i2 = false; n2 < this._inputLine.length; ) {
            var r2 = false;
            this.isDeletable(t2, e3, n2, this._distanceTol) && (this._isDeleted[e3] = Ln.DELETE, r2 = true, i2 = true), t2 = r2 ? n2 : e3, e3 = this.findNextNonDeletedIndex(t2), n2 = this.findNextNonDeletedIndex(e3);
          }
          return i2;
        }, Ln.prototype.isShallowConcavity = function(t2, e3, n2, i2) {
          if (!(at.computeOrientation(t2, e3, n2) === this._angleOrientation))
            return false;
          return at.distancePointLine(e3, t2, n2) < i2;
        }, Ln.prototype.isShallowSampled = function(t2, e3, n2, i2, r2) {
          var o2 = Math.trunc((i2 - n2) / Ln.NUM_PTS_TO_CHECK);
          o2 <= 0 && (o2 = 1);
          for (var s2 = n2; s2 < i2; s2 += o2)
            if (!this.isShallow(t2, e3, this._inputLine[s2], r2))
              return false;
          return true;
        }, Ln.prototype.isConcave = function(t2, e3, n2) {
          var i2 = at.computeOrientation(t2, e3, n2) === this._angleOrientation;
          return i2;
        }, Ln.prototype.simplify = function(t2) {
          this._distanceTol = Math.abs(t2), t2 < 0 && (this._angleOrientation = at.CLOCKWISE), this._isDeleted = new Array(this._inputLine.length).fill(null);
          var e3 = false;
          do {
            e3 = this.deleteShallowConcavities();
          } while (e3);
          return this.collapseLine();
        }, Ln.prototype.findNextNonDeletedIndex = function(t2) {
          for (var e3 = t2 + 1; e3 < this._inputLine.length && this._isDeleted[e3] === Ln.DELETE; )
            e3++;
          return e3;
        }, Ln.prototype.isShallow = function(t2, e3, n2, i2) {
          return at.distancePointLine(e3, t2, n2) < i2;
        }, Ln.prototype.collapseLine = function() {
          for (var t2 = new St(), e3 = 0; e3 < this._inputLine.length; e3++)
            this._isDeleted[e3] !== Ln.DELETE && t2.add(this._inputLine[e3]);
          return t2.toCoordinateArray();
        }, Ln.prototype.interfaces_ = function() {
          return [];
        }, Ln.prototype.getClass = function() {
          return Ln;
        }, Ln.simplify = function(t2, e3) {
          return new Ln(t2).simplify(e3);
        }, bn.INIT.get = function() {
          return 0;
        }, bn.DELETE.get = function() {
          return 1;
        }, bn.KEEP.get = function() {
          return 1;
        }, bn.NUM_PTS_TO_CHECK.get = function() {
          return 10;
        }, Object.defineProperties(Ln, bn);
        var wn = function() {
          this._ptList = null, this._precisionModel = null, this._minimimVertexDistance = 0, this._ptList = new Nt();
        }, On = { COORDINATE_ARRAY_TYPE: { configurable: true } };
        wn.prototype.getCoordinates = function() {
          return this._ptList.toArray(wn.COORDINATE_ARRAY_TYPE);
        }, wn.prototype.setPrecisionModel = function(t2) {
          this._precisionModel = t2;
        }, wn.prototype.addPt = function(t2) {
          var e3 = new C(t2);
          if (this._precisionModel.makePrecise(e3), this.isRedundant(e3))
            return null;
          this._ptList.add(e3);
        }, wn.prototype.revere = function() {
        }, wn.prototype.addPts = function(t2, e3) {
          if (e3)
            for (var n2 = 0; n2 < t2.length; n2++)
              this.addPt(t2[n2]);
          else
            for (var i2 = t2.length - 1; i2 >= 0; i2--)
              this.addPt(t2[i2]);
        }, wn.prototype.isRedundant = function(t2) {
          if (this._ptList.size() < 1)
            return false;
          var e3 = this._ptList.get(this._ptList.size() - 1);
          return t2.distance(e3) < this._minimimVertexDistance;
        }, wn.prototype.toString = function() {
          return new _e().createLineString(this.getCoordinates()).toString();
        }, wn.prototype.closeRing = function() {
          if (this._ptList.size() < 1)
            return null;
          var t2 = new C(this._ptList.get(0)), e3 = this._ptList.get(this._ptList.size() - 1);
          if (t2.equals(e3))
            return null;
          this._ptList.add(t2);
        }, wn.prototype.setMinimumVertexDistance = function(t2) {
          this._minimimVertexDistance = t2;
        }, wn.prototype.interfaces_ = function() {
          return [];
        }, wn.prototype.getClass = function() {
          return wn;
        }, On.COORDINATE_ARRAY_TYPE.get = function() {
          return new Array(0).fill(null);
        }, Object.defineProperties(wn, On);
        var Tn = function() {
        }, Rn = { PI_TIMES_2: { configurable: true }, PI_OVER_2: { configurable: true }, PI_OVER_4: { configurable: true }, COUNTERCLOCKWISE: { configurable: true }, CLOCKWISE: { configurable: true }, NONE: { configurable: true } };
        Tn.prototype.interfaces_ = function() {
          return [];
        }, Tn.prototype.getClass = function() {
          return Tn;
        }, Tn.toDegrees = function(t2) {
          return 180 * t2 / Math.PI;
        }, Tn.normalize = function(t2) {
          for (; t2 > Math.PI; )
            t2 -= Tn.PI_TIMES_2;
          for (; t2 <= -Math.PI; )
            t2 += Tn.PI_TIMES_2;
          return t2;
        }, Tn.angle = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return Math.atan2(t2.y, t2.x);
          }
          if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1], i2 = n2.x - e3.x, r2 = n2.y - e3.y;
            return Math.atan2(r2, i2);
          }
        }, Tn.isAcute = function(t2, e3, n2) {
          var i2 = t2.x - e3.x, r2 = t2.y - e3.y;
          return i2 * (n2.x - e3.x) + r2 * (n2.y - e3.y) > 0;
        }, Tn.isObtuse = function(t2, e3, n2) {
          var i2 = t2.x - e3.x, r2 = t2.y - e3.y;
          return i2 * (n2.x - e3.x) + r2 * (n2.y - e3.y) < 0;
        }, Tn.interiorAngle = function(t2, e3, n2) {
          var i2 = Tn.angle(e3, t2), r2 = Tn.angle(e3, n2);
          return Math.abs(r2 - i2);
        }, Tn.normalizePositive = function(t2) {
          if (t2 < 0) {
            for (; t2 < 0; )
              t2 += Tn.PI_TIMES_2;
            t2 >= Tn.PI_TIMES_2 && (t2 = 0);
          } else {
            for (; t2 >= Tn.PI_TIMES_2; )
              t2 -= Tn.PI_TIMES_2;
            t2 < 0 && (t2 = 0);
          }
          return t2;
        }, Tn.angleBetween = function(t2, e3, n2) {
          var i2 = Tn.angle(e3, t2), r2 = Tn.angle(e3, n2);
          return Tn.diff(i2, r2);
        }, Tn.diff = function(t2, e3) {
          var n2 = null;
          return (n2 = t2 < e3 ? e3 - t2 : t2 - e3) > Math.PI && (n2 = 2 * Math.PI - n2), n2;
        }, Tn.toRadians = function(t2) {
          return t2 * Math.PI / 180;
        }, Tn.getTurn = function(t2, e3) {
          var n2 = Math.sin(e3 - t2);
          return n2 > 0 ? Tn.COUNTERCLOCKWISE : n2 < 0 ? Tn.CLOCKWISE : Tn.NONE;
        }, Tn.angleBetweenOriented = function(t2, e3, n2) {
          var i2 = Tn.angle(e3, t2), r2 = Tn.angle(e3, n2) - i2;
          return r2 <= -Math.PI ? r2 + Tn.PI_TIMES_2 : r2 > Math.PI ? r2 - Tn.PI_TIMES_2 : r2;
        }, Rn.PI_TIMES_2.get = function() {
          return 2 * Math.PI;
        }, Rn.PI_OVER_2.get = function() {
          return Math.PI / 2;
        }, Rn.PI_OVER_4.get = function() {
          return Math.PI / 4;
        }, Rn.COUNTERCLOCKWISE.get = function() {
          return at.COUNTERCLOCKWISE;
        }, Rn.CLOCKWISE.get = function() {
          return at.CLOCKWISE;
        }, Rn.NONE.get = function() {
          return at.COLLINEAR;
        }, Object.defineProperties(Tn, Rn);
        var Pn = function t2() {
          this._maxCurveSegmentError = 0, this._filletAngleQuantum = null, this._closingSegLengthFactor = 1, this._segList = null, this._distance = 0, this._precisionModel = null, this._bufParams = null, this._li = null, this._s0 = null, this._s1 = null, this._s2 = null, this._seg0 = new dn(), this._seg1 = new dn(), this._offset0 = new dn(), this._offset1 = new dn(), this._side = 0, this._hasNarrowConcaveAngle = false;
          var e3 = arguments[0], n2 = arguments[1], i2 = arguments[2];
          this._precisionModel = e3, this._bufParams = n2, this._li = new rt(), this._filletAngleQuantum = Math.PI / 2 / n2.getQuadrantSegments(), n2.getQuadrantSegments() >= 8 && n2.getJoinStyle() === Cn.JOIN_ROUND && (this._closingSegLengthFactor = t2.MAX_CLOSING_SEG_LEN_FACTOR), this.init(i2);
        }, Dn = { OFFSET_SEGMENT_SEPARATION_FACTOR: { configurable: true }, INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR: { configurable: true }, CURVE_VERTEX_SNAP_DISTANCE_FACTOR: { configurable: true }, MAX_CLOSING_SEG_LEN_FACTOR: { configurable: true } };
        Pn.prototype.addNextSegment = function(t2, e3) {
          if (this._s0 = this._s1, this._s1 = this._s2, this._s2 = t2, this._seg0.setCoordinates(this._s0, this._s1), this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0), this._seg1.setCoordinates(this._s1, this._s2), this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1), this._s1.equals(this._s2))
            return null;
          var n2 = at.computeOrientation(this._s0, this._s1, this._s2), i2 = n2 === at.CLOCKWISE && this._side === Se.LEFT || n2 === at.COUNTERCLOCKWISE && this._side === Se.RIGHT;
          0 === n2 ? this.addCollinear(e3) : i2 ? this.addOutsideTurn(n2, e3) : this.addInsideTurn(n2, e3);
        }, Pn.prototype.addLineEndCap = function(t2, e3) {
          var n2 = new dn(t2, e3), i2 = new dn();
          this.computeOffsetSegment(n2, Se.LEFT, this._distance, i2);
          var r2 = new dn();
          this.computeOffsetSegment(n2, Se.RIGHT, this._distance, r2);
          var o2 = e3.x - t2.x, s2 = e3.y - t2.y, a2 = Math.atan2(s2, o2);
          switch (this._bufParams.getEndCapStyle()) {
            case Cn.CAP_ROUND:
              this._segList.addPt(i2.p1), this.addFilletArc(e3, a2 + Math.PI / 2, a2 - Math.PI / 2, at.CLOCKWISE, this._distance), this._segList.addPt(r2.p1);
              break;
            case Cn.CAP_FLAT:
              this._segList.addPt(i2.p1), this._segList.addPt(r2.p1);
              break;
            case Cn.CAP_SQUARE:
              var u2 = new C();
              u2.x = Math.abs(this._distance) * Math.cos(a2), u2.y = Math.abs(this._distance) * Math.sin(a2);
              var l2 = new C(i2.p1.x + u2.x, i2.p1.y + u2.y), c2 = new C(r2.p1.x + u2.x, r2.p1.y + u2.y);
              this._segList.addPt(l2), this._segList.addPt(c2);
          }
        }, Pn.prototype.getCoordinates = function() {
          return this._segList.getCoordinates();
        }, Pn.prototype.addMitreJoin = function(t2, e3, n2, i2) {
          var r2 = true, o2 = null;
          try {
            o2 = k.intersection(e3.p0, e3.p1, n2.p0, n2.p1);
            (i2 <= 0 ? 1 : o2.distance(t2) / Math.abs(i2)) > this._bufParams.getMitreLimit() && (r2 = false);
          } catch (t3) {
            if (!(t3 instanceof X))
              throw t3;
            o2 = new C(0, 0), r2 = false;
          }
          r2 ? this._segList.addPt(o2) : this.addLimitedMitreJoin(e3, n2, i2, this._bufParams.getMitreLimit());
        }, Pn.prototype.addFilletCorner = function(t2, e3, n2, i2, r2) {
          var o2 = e3.x - t2.x, s2 = e3.y - t2.y, a2 = Math.atan2(s2, o2), u2 = n2.x - t2.x, l2 = n2.y - t2.y, c2 = Math.atan2(l2, u2);
          i2 === at.CLOCKWISE ? a2 <= c2 && (a2 += 2 * Math.PI) : a2 >= c2 && (a2 -= 2 * Math.PI), this._segList.addPt(e3), this.addFilletArc(t2, a2, c2, i2, r2), this._segList.addPt(n2);
        }, Pn.prototype.addOutsideTurn = function(t2, e3) {
          if (this._offset0.p1.distance(this._offset1.p0) < this._distance * Pn.OFFSET_SEGMENT_SEPARATION_FACTOR)
            return this._segList.addPt(this._offset0.p1), null;
          this._bufParams.getJoinStyle() === Cn.JOIN_MITRE ? this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance) : this._bufParams.getJoinStyle() === Cn.JOIN_BEVEL ? this.addBevelJoin(this._offset0, this._offset1) : (e3 && this._segList.addPt(this._offset0.p1), this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, t2, this._distance), this._segList.addPt(this._offset1.p0));
        }, Pn.prototype.createSquare = function(t2) {
          this._segList.addPt(new C(t2.x + this._distance, t2.y + this._distance)), this._segList.addPt(new C(t2.x + this._distance, t2.y - this._distance)), this._segList.addPt(new C(t2.x - this._distance, t2.y - this._distance)), this._segList.addPt(new C(t2.x - this._distance, t2.y + this._distance)), this._segList.closeRing();
        }, Pn.prototype.addSegments = function(t2, e3) {
          this._segList.addPts(t2, e3);
        }, Pn.prototype.addFirstSegment = function() {
          this._segList.addPt(this._offset1.p0);
        }, Pn.prototype.addLastSegment = function() {
          this._segList.addPt(this._offset1.p1);
        }, Pn.prototype.initSideSegments = function(t2, e3, n2) {
          this._s1 = t2, this._s2 = e3, this._side = n2, this._seg1.setCoordinates(t2, e3), this.computeOffsetSegment(this._seg1, n2, this._distance, this._offset1);
        }, Pn.prototype.addLimitedMitreJoin = function(t2, e3, n2, i2) {
          var r2 = this._seg0.p1, o2 = Tn.angle(r2, this._seg0.p0), s2 = Tn.angleBetweenOriented(this._seg0.p0, r2, this._seg1.p1) / 2, a2 = Tn.normalize(o2 + s2), u2 = Tn.normalize(a2 + Math.PI), l2 = i2 * n2, c2 = n2 - l2 * Math.abs(Math.sin(s2)), p2 = r2.x + l2 * Math.cos(u2), h2 = r2.y + l2 * Math.sin(u2), f2 = new C(p2, h2), g2 = new dn(r2, f2), d2 = g2.pointAlongOffset(1, c2), y3 = g2.pointAlongOffset(1, -c2);
          this._side === Se.LEFT ? (this._segList.addPt(d2), this._segList.addPt(y3)) : (this._segList.addPt(y3), this._segList.addPt(d2));
        }, Pn.prototype.computeOffsetSegment = function(t2, e3, n2, i2) {
          var r2 = e3 === Se.LEFT ? 1 : -1, o2 = t2.p1.x - t2.p0.x, s2 = t2.p1.y - t2.p0.y, a2 = Math.sqrt(o2 * o2 + s2 * s2), u2 = r2 * n2 * o2 / a2, l2 = r2 * n2 * s2 / a2;
          i2.p0.x = t2.p0.x - l2, i2.p0.y = t2.p0.y + u2, i2.p1.x = t2.p1.x - l2, i2.p1.y = t2.p1.y + u2;
        }, Pn.prototype.addFilletArc = function(t2, e3, n2, i2, r2) {
          var o2 = i2 === at.CLOCKWISE ? -1 : 1, s2 = Math.abs(e3 - n2), a2 = Math.trunc(s2 / this._filletAngleQuantum + 0.5);
          if (a2 < 1)
            return null;
          for (var u2 = s2 / a2, l2 = 0, c2 = new C(); l2 < s2; ) {
            var p2 = e3 + o2 * l2;
            c2.x = t2.x + r2 * Math.cos(p2), c2.y = t2.y + r2 * Math.sin(p2), this._segList.addPt(c2), l2 += u2;
          }
        }, Pn.prototype.addInsideTurn = function(t2, e3) {
          if (this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1), this._li.hasIntersection())
            this._segList.addPt(this._li.getIntersection(0));
          else if (this._hasNarrowConcaveAngle = true, this._offset0.p1.distance(this._offset1.p0) < this._distance * Pn.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR)
            this._segList.addPt(this._offset0.p1);
          else {
            if (this._segList.addPt(this._offset0.p1), this._closingSegLengthFactor > 0) {
              var n2 = new C((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));
              this._segList.addPt(n2);
              var i2 = new C((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));
              this._segList.addPt(i2);
            } else
              this._segList.addPt(this._s1);
            this._segList.addPt(this._offset1.p0);
          }
        }, Pn.prototype.createCircle = function(t2) {
          var e3 = new C(t2.x + this._distance, t2.y);
          this._segList.addPt(e3), this.addFilletArc(t2, 0, 2 * Math.PI, -1, this._distance), this._segList.closeRing();
        }, Pn.prototype.addBevelJoin = function(t2, e3) {
          this._segList.addPt(t2.p1), this._segList.addPt(e3.p0);
        }, Pn.prototype.init = function(t2) {
          this._distance = t2, this._maxCurveSegmentError = t2 * (1 - Math.cos(this._filletAngleQuantum / 2)), this._segList = new wn(), this._segList.setPrecisionModel(this._precisionModel), this._segList.setMinimumVertexDistance(t2 * Pn.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);
        }, Pn.prototype.addCollinear = function(t2) {
          this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2);
          this._li.getIntersectionNum() >= 2 && (this._bufParams.getJoinStyle() === Cn.JOIN_BEVEL || this._bufParams.getJoinStyle() === Cn.JOIN_MITRE ? (t2 && this._segList.addPt(this._offset0.p1), this._segList.addPt(this._offset1.p0)) : this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, at.CLOCKWISE, this._distance));
        }, Pn.prototype.closeRing = function() {
          this._segList.closeRing();
        }, Pn.prototype.hasNarrowConcaveAngle = function() {
          return this._hasNarrowConcaveAngle;
        }, Pn.prototype.interfaces_ = function() {
          return [];
        }, Pn.prototype.getClass = function() {
          return Pn;
        }, Dn.OFFSET_SEGMENT_SEPARATION_FACTOR.get = function() {
          return 1e-3;
        }, Dn.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR.get = function() {
          return 1e-3;
        }, Dn.CURVE_VERTEX_SNAP_DISTANCE_FACTOR.get = function() {
          return 1e-6;
        }, Dn.MAX_CLOSING_SEG_LEN_FACTOR.get = function() {
          return 80;
        }, Object.defineProperties(Pn, Dn);
        var Mn = function() {
          this._distance = 0, this._precisionModel = null, this._bufParams = null;
          var t2 = arguments[0], e3 = arguments[1];
          this._precisionModel = t2, this._bufParams = e3;
        };
        Mn.prototype.getOffsetCurve = function(t2, e3) {
          if (this._distance = e3, 0 === e3)
            return null;
          var n2 = e3 < 0, i2 = Math.abs(e3), r2 = this.getSegGen(i2);
          t2.length <= 1 ? this.computePointCurve(t2[0], r2) : this.computeOffsetCurve(t2, n2, r2);
          var o2 = r2.getCoordinates();
          return n2 && Lt.reverse(o2), o2;
        }, Mn.prototype.computeSingleSidedBufferCurve = function(t2, e3, n2) {
          var i2 = this.simplifyTolerance(this._distance);
          if (e3) {
            n2.addSegments(t2, true);
            var r2 = Ln.simplify(t2, -i2), o2 = r2.length - 1;
            n2.initSideSegments(r2[o2], r2[o2 - 1], Se.LEFT), n2.addFirstSegment();
            for (var s2 = o2 - 2; s2 >= 0; s2--)
              n2.addNextSegment(r2[s2], true);
          } else {
            n2.addSegments(t2, false);
            var a2 = Ln.simplify(t2, i2), u2 = a2.length - 1;
            n2.initSideSegments(a2[0], a2[1], Se.LEFT), n2.addFirstSegment();
            for (var l2 = 2; l2 <= u2; l2++)
              n2.addNextSegment(a2[l2], true);
          }
          n2.addLastSegment(), n2.closeRing();
        }, Mn.prototype.computeRingBufferCurve = function(t2, e3, n2) {
          var i2 = this.simplifyTolerance(this._distance);
          e3 === Se.RIGHT && (i2 = -i2);
          var r2 = Ln.simplify(t2, i2), o2 = r2.length - 1;
          n2.initSideSegments(r2[o2 - 1], r2[0], e3);
          for (var s2 = 1; s2 <= o2; s2++) {
            var a2 = 1 !== s2;
            n2.addNextSegment(r2[s2], a2);
          }
          n2.closeRing();
        }, Mn.prototype.computeLineBufferCurve = function(t2, e3) {
          var n2 = this.simplifyTolerance(this._distance), i2 = Ln.simplify(t2, n2), r2 = i2.length - 1;
          e3.initSideSegments(i2[0], i2[1], Se.LEFT);
          for (var o2 = 2; o2 <= r2; o2++)
            e3.addNextSegment(i2[o2], true);
          e3.addLastSegment(), e3.addLineEndCap(i2[r2 - 1], i2[r2]);
          var s2 = Ln.simplify(t2, -n2), a2 = s2.length - 1;
          e3.initSideSegments(s2[a2], s2[a2 - 1], Se.LEFT);
          for (var u2 = a2 - 2; u2 >= 0; u2--)
            e3.addNextSegment(s2[u2], true);
          e3.addLastSegment(), e3.addLineEndCap(s2[1], s2[0]), e3.closeRing();
        }, Mn.prototype.computePointCurve = function(t2, e3) {
          switch (this._bufParams.getEndCapStyle()) {
            case Cn.CAP_ROUND:
              e3.createCircle(t2);
              break;
            case Cn.CAP_SQUARE:
              e3.createSquare(t2);
          }
        }, Mn.prototype.getLineCurve = function(t2, e3) {
          if (this._distance = e3, e3 < 0 && !this._bufParams.isSingleSided())
            return null;
          if (0 === e3)
            return null;
          var n2 = Math.abs(e3), i2 = this.getSegGen(n2);
          if (t2.length <= 1)
            this.computePointCurve(t2[0], i2);
          else if (this._bufParams.isSingleSided()) {
            var r2 = e3 < 0;
            this.computeSingleSidedBufferCurve(t2, r2, i2);
          } else
            this.computeLineBufferCurve(t2, i2);
          return i2.getCoordinates();
        }, Mn.prototype.getBufferParameters = function() {
          return this._bufParams;
        }, Mn.prototype.simplifyTolerance = function(t2) {
          return t2 * this._bufParams.getSimplifyFactor();
        }, Mn.prototype.getRingCurve = function(t2, e3, n2) {
          if (this._distance = n2, t2.length <= 2)
            return this.getLineCurve(t2, n2);
          if (0 === n2)
            return Mn.copyCoordinates(t2);
          var i2 = this.getSegGen(n2);
          return this.computeRingBufferCurve(t2, e3, i2), i2.getCoordinates();
        }, Mn.prototype.computeOffsetCurve = function(t2, e3, n2) {
          var i2 = this.simplifyTolerance(this._distance);
          if (e3) {
            var r2 = Ln.simplify(t2, -i2), o2 = r2.length - 1;
            n2.initSideSegments(r2[o2], r2[o2 - 1], Se.LEFT), n2.addFirstSegment();
            for (var s2 = o2 - 2; s2 >= 0; s2--)
              n2.addNextSegment(r2[s2], true);
          } else {
            var a2 = Ln.simplify(t2, i2), u2 = a2.length - 1;
            n2.initSideSegments(a2[0], a2[1], Se.LEFT), n2.addFirstSegment();
            for (var l2 = 2; l2 <= u2; l2++)
              n2.addNextSegment(a2[l2], true);
          }
          n2.addLastSegment();
        }, Mn.prototype.getSegGen = function(t2) {
          return new Pn(this._precisionModel, this._bufParams, t2);
        }, Mn.prototype.interfaces_ = function() {
          return [];
        }, Mn.prototype.getClass = function() {
          return Mn;
        }, Mn.copyCoordinates = function(t2) {
          for (var e3 = new Array(t2.length).fill(null), n2 = 0; n2 < e3.length; n2++)
            e3[n2] = new C(t2[n2]);
          return e3;
        };
        var An = function() {
          this._subgraphs = null, this._seg = new dn(), this._cga = new at();
          var t2 = arguments[0];
          this._subgraphs = t2;
        }, Fn = { DepthSegment: { configurable: true } };
        An.prototype.findStabbedSegments = function() {
          if (1 === arguments.length) {
            for (var t2 = arguments[0], e3 = new Nt(), n2 = this._subgraphs.iterator(); n2.hasNext(); ) {
              var i2 = n2.next(), r2 = i2.getEnvelope();
              t2.y < r2.getMinY() || t2.y > r2.getMaxY() || this.findStabbedSegments(t2, i2.getDirectedEdges(), e3);
            }
            return e3;
          }
          if (3 === arguments.length) {
            if (T(arguments[2], xt) && arguments[0] instanceof C && arguments[1] instanceof ze)
              for (var o2 = arguments[0], s2 = arguments[1], a2 = arguments[2], u2 = s2.getEdge().getCoordinates(), l2 = 0; l2 < u2.length - 1; l2++) {
                this._seg.p0 = u2[l2], this._seg.p1 = u2[l2 + 1], this._seg.p0.y > this._seg.p1.y && this._seg.reverse();
                if (!(Math.max(this._seg.p0.x, this._seg.p1.x) < o2.x) && !(this._seg.isHorizontal() || o2.y < this._seg.p0.y || o2.y > this._seg.p1.y || at.computeOrientation(this._seg.p0, this._seg.p1, o2) === at.RIGHT)) {
                  var c2 = s2.getDepth(Se.LEFT);
                  this._seg.p0.equals(u2[l2]) || (c2 = s2.getDepth(Se.RIGHT));
                  var p2 = new Gn(this._seg, c2);
                  a2.add(p2);
                }
              }
            else if (T(arguments[2], xt) && arguments[0] instanceof C && T(arguments[1], xt))
              for (var h2 = arguments[0], f2 = arguments[1], g2 = arguments[2], d2 = f2.iterator(); d2.hasNext(); ) {
                var y3 = d2.next();
                y3.isForward() && this.findStabbedSegments(h2, y3, g2);
              }
          }
        }, An.prototype.getDepth = function(t2) {
          var e3 = this.findStabbedSegments(t2);
          if (0 === e3.size())
            return 0;
          return $e.min(e3)._leftDepth;
        }, An.prototype.interfaces_ = function() {
          return [];
        }, An.prototype.getClass = function() {
          return An;
        }, Fn.DepthSegment.get = function() {
          return Gn;
        }, Object.defineProperties(An, Fn);
        var Gn = function() {
          this._upwardSeg = null, this._leftDepth = null;
          var t2 = arguments[0], e3 = arguments[1];
          this._upwardSeg = new dn(t2), this._leftDepth = e3;
        };
        Gn.prototype.compareTo = function(t2) {
          var e3 = t2;
          if (this._upwardSeg.minX() >= e3._upwardSeg.maxX())
            return 1;
          if (this._upwardSeg.maxX() <= e3._upwardSeg.minX())
            return -1;
          var n2 = this._upwardSeg.orientationIndex(e3._upwardSeg);
          return 0 !== n2 ? n2 : 0 != (n2 = -1 * e3._upwardSeg.orientationIndex(this._upwardSeg)) ? n2 : this._upwardSeg.compareTo(e3._upwardSeg);
        }, Gn.prototype.compareX = function(t2, e3) {
          var n2 = t2.p0.compareTo(e3.p0);
          return 0 !== n2 ? n2 : t2.p1.compareTo(e3.p1);
        }, Gn.prototype.toString = function() {
          return this._upwardSeg.toString();
        }, Gn.prototype.interfaces_ = function() {
          return [E];
        }, Gn.prototype.getClass = function() {
          return Gn;
        };
        var qn = function(t2, e3, n2) {
          this.p0 = t2 || null, this.p1 = e3 || null, this.p2 = n2 || null;
        };
        qn.prototype.area = function() {
          return qn.area(this.p0, this.p1, this.p2);
        }, qn.prototype.signedArea = function() {
          return qn.signedArea(this.p0, this.p1, this.p2);
        }, qn.prototype.interpolateZ = function(t2) {
          if (null === t2)
            throw new m("Supplied point is null.");
          return qn.interpolateZ(t2, this.p0, this.p1, this.p2);
        }, qn.prototype.longestSideLength = function() {
          return qn.longestSideLength(this.p0, this.p1, this.p2);
        }, qn.prototype.isAcute = function() {
          return qn.isAcute(this.p0, this.p1, this.p2);
        }, qn.prototype.circumcentre = function() {
          return qn.circumcentre(this.p0, this.p1, this.p2);
        }, qn.prototype.area3D = function() {
          return qn.area3D(this.p0, this.p1, this.p2);
        }, qn.prototype.centroid = function() {
          return qn.centroid(this.p0, this.p1, this.p2);
        }, qn.prototype.inCentre = function() {
          return qn.inCentre(this.p0, this.p1, this.p2);
        }, qn.prototype.interfaces_ = function() {
          return [];
        }, qn.prototype.getClass = function() {
          return qn;
        }, qn.area = function(t2, e3, n2) {
          return Math.abs(((n2.x - t2.x) * (e3.y - t2.y) - (e3.x - t2.x) * (n2.y - t2.y)) / 2);
        }, qn.signedArea = function(t2, e3, n2) {
          return ((n2.x - t2.x) * (e3.y - t2.y) - (e3.x - t2.x) * (n2.y - t2.y)) / 2;
        }, qn.det = function(t2, e3, n2, i2) {
          return t2 * i2 - e3 * n2;
        }, qn.interpolateZ = function(t2, e3, n2, i2) {
          var r2 = e3.x, o2 = e3.y, s2 = n2.x - r2, a2 = i2.x - r2, u2 = n2.y - o2, l2 = i2.y - o2, c2 = s2 * l2 - a2 * u2, p2 = t2.x - r2, h2 = t2.y - o2, f2 = (l2 * p2 - a2 * h2) / c2, g2 = (-u2 * p2 + s2 * h2) / c2;
          return e3.z + f2 * (n2.z - e3.z) + g2 * (i2.z - e3.z);
        }, qn.longestSideLength = function(t2, e3, n2) {
          var i2 = t2.distance(e3), r2 = e3.distance(n2), o2 = n2.distance(t2), s2 = i2;
          return r2 > s2 && (s2 = r2), o2 > s2 && (s2 = o2), s2;
        }, qn.isAcute = function(t2, e3, n2) {
          return !!Tn.isAcute(t2, e3, n2) && (!!Tn.isAcute(e3, n2, t2) && !!Tn.isAcute(n2, t2, e3));
        }, qn.circumcentre = function(t2, e3, n2) {
          var i2 = n2.x, r2 = n2.y, o2 = t2.x - i2, s2 = t2.y - r2, a2 = e3.x - i2, u2 = e3.y - r2, l2 = 2 * qn.det(o2, s2, a2, u2), c2 = qn.det(s2, o2 * o2 + s2 * s2, u2, a2 * a2 + u2 * u2), p2 = qn.det(o2, o2 * o2 + s2 * s2, a2, a2 * a2 + u2 * u2);
          return new C(i2 - c2 / l2, r2 + p2 / l2);
        }, qn.perpendicularBisector = function(t2, e3) {
          var n2 = e3.x - t2.x, i2 = e3.y - t2.y, r2 = new k(t2.x + n2 / 2, t2.y + i2 / 2, 1), o2 = new k(t2.x - i2 + n2 / 2, t2.y + n2 + i2 / 2, 1);
          return new k(r2, o2);
        }, qn.angleBisector = function(t2, e3, n2) {
          var i2 = e3.distance(t2), r2 = i2 / (i2 + e3.distance(n2)), o2 = n2.x - t2.x, s2 = n2.y - t2.y;
          return new C(t2.x + r2 * o2, t2.y + r2 * s2);
        }, qn.area3D = function(t2, e3, n2) {
          var i2 = e3.x - t2.x, r2 = e3.y - t2.y, o2 = e3.z - t2.z, s2 = n2.x - t2.x, a2 = n2.y - t2.y, u2 = n2.z - t2.z, l2 = r2 * u2 - o2 * a2, c2 = o2 * s2 - i2 * u2, p2 = i2 * a2 - r2 * s2, h2 = l2 * l2 + c2 * c2 + p2 * p2, f2 = Math.sqrt(h2) / 2;
          return f2;
        }, qn.centroid = function(t2, e3, n2) {
          var i2 = (t2.x + e3.x + n2.x) / 3, r2 = (t2.y + e3.y + n2.y) / 3;
          return new C(i2, r2);
        }, qn.inCentre = function(t2, e3, n2) {
          var i2 = e3.distance(n2), r2 = t2.distance(n2), o2 = t2.distance(e3), s2 = i2 + r2 + o2, a2 = (i2 * t2.x + r2 * e3.x + o2 * n2.x) / s2, u2 = (i2 * t2.y + r2 * e3.y + o2 * n2.y) / s2;
          return new C(a2, u2);
        };
        var Bn = function() {
          this._inputGeom = null, this._distance = null, this._curveBuilder = null, this._curveList = new Nt();
          var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
          this._inputGeom = t2, this._distance = e3, this._curveBuilder = n2;
        };
        Bn.prototype.addPoint = function(t2) {
          if (this._distance <= 0)
            return null;
          var e3 = t2.getCoordinates(), n2 = this._curveBuilder.getLineCurve(e3, this._distance);
          this.addCurve(n2, w.EXTERIOR, w.INTERIOR);
        }, Bn.prototype.addPolygon = function(t2) {
          var e3 = this._distance, n2 = Se.LEFT;
          this._distance < 0 && (e3 = -this._distance, n2 = Se.RIGHT);
          var i2 = t2.getExteriorRing(), r2 = Lt.removeRepeatedPoints(i2.getCoordinates());
          if (this._distance < 0 && this.isErodedCompletely(i2, this._distance))
            return null;
          if (this._distance <= 0 && r2.length < 3)
            return null;
          this.addPolygonRing(r2, e3, n2, w.EXTERIOR, w.INTERIOR);
          for (var o2 = 0; o2 < t2.getNumInteriorRing(); o2++) {
            var s2 = t2.getInteriorRingN(o2), a2 = Lt.removeRepeatedPoints(s2.getCoordinates());
            this._distance > 0 && this.isErodedCompletely(s2, -this._distance) || this.addPolygonRing(a2, e3, Se.opposite(n2), w.INTERIOR, w.EXTERIOR);
          }
        }, Bn.prototype.isTriangleErodedCompletely = function(t2, e3) {
          var n2 = new qn(t2[0], t2[1], t2[2]), i2 = n2.inCentre();
          return at.distancePointLine(i2, n2.p0, n2.p1) < Math.abs(e3);
        }, Bn.prototype.addLineString = function(t2) {
          if (this._distance <= 0 && !this._curveBuilder.getBufferParameters().isSingleSided())
            return null;
          var e3 = Lt.removeRepeatedPoints(t2.getCoordinates()), n2 = this._curveBuilder.getLineCurve(e3, this._distance);
          this.addCurve(n2, w.EXTERIOR, w.INTERIOR);
        }, Bn.prototype.addCurve = function(t2, e3, n2) {
          if (null === t2 || t2.length < 2)
            return null;
          var i2 = new gn(t2, new Pe(0, w.BOUNDARY, e3, n2));
          this._curveList.add(i2);
        }, Bn.prototype.getCurves = function() {
          return this.add(this._inputGeom), this._curveList;
        }, Bn.prototype.addPolygonRing = function(t2, e3, n2, i2, r2) {
          if (0 === e3 && t2.length < ee.MINIMUM_VALID_SIZE)
            return null;
          var o2 = i2, s2 = r2;
          t2.length >= ee.MINIMUM_VALID_SIZE && at.isCCW(t2) && (o2 = r2, s2 = i2, n2 = Se.opposite(n2));
          var a2 = this._curveBuilder.getRingCurve(t2, n2, e3);
          this.addCurve(a2, o2, s2);
        }, Bn.prototype.add = function(t2) {
          if (t2.isEmpty())
            return null;
          t2 instanceof $t ? this.addPolygon(t2) : t2 instanceof Kt ? this.addLineString(t2) : t2 instanceof Qt ? this.addPoint(t2) : t2 instanceof te ? this.addCollection(t2) : t2 instanceof Xt ? this.addCollection(t2) : t2 instanceof ne ? this.addCollection(t2) : t2 instanceof zt && this.addCollection(t2);
        }, Bn.prototype.isErodedCompletely = function(t2, e3) {
          var n2 = t2.getCoordinates();
          if (n2.length < 4)
            return e3 < 0;
          if (4 === n2.length)
            return this.isTriangleErodedCompletely(n2, e3);
          var i2 = t2.getEnvelopeInternal(), r2 = Math.min(i2.getHeight(), i2.getWidth());
          return e3 < 0 && 2 * Math.abs(e3) > r2;
        }, Bn.prototype.addCollection = function(t2) {
          for (var e3 = 0; e3 < t2.getNumGeometries(); e3++) {
            var n2 = t2.getGeometryN(e3);
            this.add(n2);
          }
        }, Bn.prototype.interfaces_ = function() {
          return [];
        }, Bn.prototype.getClass = function() {
          return Bn;
        };
        var Vn = function() {
        };
        Vn.prototype.locate = function(t2) {
        }, Vn.prototype.interfaces_ = function() {
          return [];
        }, Vn.prototype.getClass = function() {
          return Vn;
        };
        var Un = function() {
          this._parent = null, this._atStart = null, this._max = null, this._index = null, this._subcollectionIterator = null;
          var t2 = arguments[0];
          this._parent = t2, this._atStart = true, this._index = 0, this._max = t2.getNumGeometries();
        };
        Un.prototype.next = function() {
          if (this._atStart)
            return this._atStart = false, Un.isAtomic(this._parent) && this._index++, this._parent;
          if (null !== this._subcollectionIterator) {
            if (this._subcollectionIterator.hasNext())
              return this._subcollectionIterator.next();
            this._subcollectionIterator = null;
          }
          if (this._index >= this._max)
            throw new i();
          var t2 = this._parent.getGeometryN(this._index++);
          return t2 instanceof zt ? (this._subcollectionIterator = new Un(t2), this._subcollectionIterator.next()) : t2;
        }, Un.prototype.remove = function() {
          throw new Error(this.getClass().getName());
        }, Un.prototype.hasNext = function() {
          if (this._atStart)
            return true;
          if (null !== this._subcollectionIterator) {
            if (this._subcollectionIterator.hasNext())
              return true;
            this._subcollectionIterator = null;
          }
          return !(this._index >= this._max);
        }, Un.prototype.interfaces_ = function() {
          return [Et];
        }, Un.prototype.getClass = function() {
          return Un;
        }, Un.isAtomic = function(t2) {
          return !(t2 instanceof zt);
        };
        var zn = function() {
          this._geom = null;
          var t2 = arguments[0];
          this._geom = t2;
        };
        zn.prototype.locate = function(t2) {
          return zn.locate(t2, this._geom);
        }, zn.prototype.interfaces_ = function() {
          return [Vn];
        }, zn.prototype.getClass = function() {
          return zn;
        }, zn.isPointInRing = function(t2, e3) {
          return !!e3.getEnvelopeInternal().intersects(t2) && at.isPointInRing(t2, e3.getCoordinates());
        }, zn.containsPointInPolygon = function(t2, e3) {
          if (e3.isEmpty())
            return false;
          var n2 = e3.getExteriorRing();
          if (!zn.isPointInRing(t2, n2))
            return false;
          for (var i2 = 0; i2 < e3.getNumInteriorRing(); i2++) {
            var r2 = e3.getInteriorRingN(i2);
            if (zn.isPointInRing(t2, r2))
              return false;
          }
          return true;
        }, zn.containsPoint = function(t2, e3) {
          if (e3 instanceof $t)
            return zn.containsPointInPolygon(t2, e3);
          if (e3 instanceof zt)
            for (var n2 = new Un(e3); n2.hasNext(); ) {
              var i2 = n2.next();
              if (i2 !== e3 && zn.containsPoint(t2, i2))
                return true;
            }
          return false;
        }, zn.locate = function(t2, e3) {
          return e3.isEmpty() ? w.EXTERIOR : zn.containsPoint(t2, e3) ? w.INTERIOR : w.EXTERIOR;
        };
        var Xn = function() {
          this._edgeMap = new p(), this._edgeList = null, this._ptInAreaLocation = [w.NONE, w.NONE];
        };
        Xn.prototype.getNextCW = function(t2) {
          this.getEdges();
          var e3 = this._edgeList.indexOf(t2), n2 = e3 - 1;
          return 0 === e3 && (n2 = this._edgeList.size() - 1), this._edgeList.get(n2);
        }, Xn.prototype.propagateSideLabels = function(t2) {
          for (var e3 = w.NONE, n2 = this.iterator(); n2.hasNext(); ) {
            var i2 = n2.next().getLabel();
            i2.isArea(t2) && i2.getLocation(t2, Se.LEFT) !== w.NONE && (e3 = i2.getLocation(t2, Se.LEFT));
          }
          if (e3 === w.NONE)
            return null;
          for (var r2 = e3, o2 = this.iterator(); o2.hasNext(); ) {
            var s2 = o2.next(), a2 = s2.getLabel();
            if (a2.getLocation(t2, Se.ON) === w.NONE && a2.setLocation(t2, Se.ON, r2), a2.isArea(t2)) {
              var u2 = a2.getLocation(t2, Se.LEFT), l2 = a2.getLocation(t2, Se.RIGHT);
              if (l2 !== w.NONE) {
                if (l2 !== r2)
                  throw new we("side location conflict", s2.getCoordinate());
                u2 === w.NONE && et.shouldNeverReachHere("found single null side (at " + s2.getCoordinate() + ")"), r2 = u2;
              } else
                et.isTrue(a2.getLocation(t2, Se.LEFT) === w.NONE, "found single null side"), a2.setLocation(t2, Se.RIGHT, r2), a2.setLocation(t2, Se.LEFT, r2);
            }
          }
        }, Xn.prototype.getCoordinate = function() {
          var t2 = this.iterator();
          if (!t2.hasNext())
            return null;
          return t2.next().getCoordinate();
        }, Xn.prototype.print = function(t2) {
          Y.out.println("EdgeEndStar:   " + this.getCoordinate());
          for (var e3 = this.iterator(); e3.hasNext(); ) {
            e3.next().print(t2);
          }
        }, Xn.prototype.isAreaLabelsConsistent = function(t2) {
          return this.computeEdgeEndLabels(t2.getBoundaryNodeRule()), this.checkAreaLabelsConsistent(0);
        }, Xn.prototype.checkAreaLabelsConsistent = function(t2) {
          var e3 = this.getEdges();
          if (e3.size() <= 0)
            return true;
          var n2 = e3.size() - 1, i2 = e3.get(n2).getLabel().getLocation(t2, Se.LEFT);
          et.isTrue(i2 !== w.NONE, "Found unlabelled area edge");
          for (var r2 = i2, o2 = this.iterator(); o2.hasNext(); ) {
            var s2 = o2.next().getLabel();
            et.isTrue(s2.isArea(t2), "Found non-area edge");
            var a2 = s2.getLocation(t2, Se.LEFT), u2 = s2.getLocation(t2, Se.RIGHT);
            if (a2 === u2)
              return false;
            if (u2 !== r2)
              return false;
            r2 = a2;
          }
          return true;
        }, Xn.prototype.findIndex = function(t2) {
          this.iterator();
          for (var e3 = 0; e3 < this._edgeList.size(); e3++) {
            if (this._edgeList.get(e3) === t2)
              return e3;
          }
          return -1;
        }, Xn.prototype.iterator = function() {
          return this.getEdges().iterator();
        }, Xn.prototype.getEdges = function() {
          return null === this._edgeList && (this._edgeList = new Nt(this._edgeMap.values())), this._edgeList;
        }, Xn.prototype.getLocation = function(t2, e3, n2) {
          return this._ptInAreaLocation[t2] === w.NONE && (this._ptInAreaLocation[t2] = zn.locate(e3, n2[t2].getGeometry())), this._ptInAreaLocation[t2];
        }, Xn.prototype.toString = function() {
          var t2 = new D();
          t2.append("EdgeEndStar:   " + this.getCoordinate()), t2.append("\n");
          for (var e3 = this.iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            t2.append(n2), t2.append("\n");
          }
          return t2.toString();
        }, Xn.prototype.computeEdgeEndLabels = function(t2) {
          for (var e3 = this.iterator(); e3.hasNext(); ) {
            e3.next().computeLabel(t2);
          }
        }, Xn.prototype.computeLabelling = function(t2) {
          this.computeEdgeEndLabels(t2[0].getBoundaryNodeRule()), this.propagateSideLabels(0), this.propagateSideLabels(1);
          for (var e3 = [false, false], n2 = this.iterator(); n2.hasNext(); )
            for (var i2 = n2.next().getLabel(), r2 = 0; r2 < 2; r2++)
              i2.isLine(r2) && i2.getLocation(r2) === w.BOUNDARY && (e3[r2] = true);
          for (var o2 = this.iterator(); o2.hasNext(); )
            for (var s2 = o2.next(), a2 = s2.getLabel(), u2 = 0; u2 < 2; u2++)
              if (a2.isAnyNull(u2)) {
                var l2 = w.NONE;
                if (e3[u2])
                  l2 = w.EXTERIOR;
                else {
                  var c2 = s2.getCoordinate();
                  l2 = this.getLocation(u2, c2, t2);
                }
                a2.setAllLocationsIfNull(u2, l2);
              }
        }, Xn.prototype.getDegree = function() {
          return this._edgeMap.size();
        }, Xn.prototype.insertEdgeEnd = function(t2, e3) {
          this._edgeMap.put(t2, e3), this._edgeList = null;
        }, Xn.prototype.interfaces_ = function() {
          return [];
        }, Xn.prototype.getClass = function() {
          return Xn;
        };
        var Yn = function(t2) {
          function e3() {
            t2.call(this), this._resultAreaEdgeList = null, this._label = null, this._SCANNING_FOR_INCOMING = 1, this._LINKING_TO_OUTGOING = 2;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.linkResultDirectedEdges = function() {
            this.getResultAreaEdges();
            for (var t3 = null, e4 = null, n2 = this._SCANNING_FOR_INCOMING, i2 = 0; i2 < this._resultAreaEdgeList.size(); i2++) {
              var r2 = this._resultAreaEdgeList.get(i2), o2 = r2.getSym();
              if (r2.getLabel().isArea())
                switch (null === t3 && r2.isInResult() && (t3 = r2), n2) {
                  case this._SCANNING_FOR_INCOMING:
                    if (!o2.isInResult())
                      continue;
                    e4 = o2, n2 = this._LINKING_TO_OUTGOING;
                    break;
                  case this._LINKING_TO_OUTGOING:
                    if (!r2.isInResult())
                      continue;
                    e4.setNext(r2), n2 = this._SCANNING_FOR_INCOMING;
                }
            }
            if (n2 === this._LINKING_TO_OUTGOING) {
              if (null === t3)
                throw new we("no outgoing dirEdge found", this.getCoordinate());
              et.isTrue(t3.isInResult(), "unable to link last incoming dirEdge"), e4.setNext(t3);
            }
          }, e3.prototype.insert = function(t3) {
            var e4 = t3;
            this.insertEdgeEnd(e4, e4);
          }, e3.prototype.getRightmostEdge = function() {
            var t3 = this.getEdges(), e4 = t3.size();
            if (e4 < 1)
              return null;
            var n2 = t3.get(0);
            if (1 === e4)
              return n2;
            var i2 = t3.get(e4 - 1), r2 = n2.getQuadrant(), o2 = i2.getQuadrant();
            return Be.isNorthern(r2) && Be.isNorthern(o2) ? n2 : Be.isNorthern(r2) || Be.isNorthern(o2) ? 0 !== n2.getDy() ? n2 : 0 !== i2.getDy() ? i2 : (et.shouldNeverReachHere("found two horizontal edges incident on node"), null) : i2;
          }, e3.prototype.print = function(t3) {
            Y.out.println("DirectedEdgeStar: " + this.getCoordinate());
            for (var e4 = this.iterator(); e4.hasNext(); ) {
              var n2 = e4.next();
              t3.print("out "), n2.print(t3), t3.println(), t3.print("in "), n2.getSym().print(t3), t3.println();
            }
          }, e3.prototype.getResultAreaEdges = function() {
            if (null !== this._resultAreaEdgeList)
              return this._resultAreaEdgeList;
            this._resultAreaEdgeList = new Nt();
            for (var t3 = this.iterator(); t3.hasNext(); ) {
              var e4 = t3.next();
              (e4.isInResult() || e4.getSym().isInResult()) && this._resultAreaEdgeList.add(e4);
            }
            return this._resultAreaEdgeList;
          }, e3.prototype.updateLabelling = function(t3) {
            for (var e4 = this.iterator(); e4.hasNext(); ) {
              var n2 = e4.next().getLabel();
              n2.setAllLocationsIfNull(0, t3.getLocation(0)), n2.setAllLocationsIfNull(1, t3.getLocation(1));
            }
          }, e3.prototype.linkAllDirectedEdges = function() {
            this.getEdges();
            for (var t3 = null, e4 = null, n2 = this._edgeList.size() - 1; n2 >= 0; n2--) {
              var i2 = this._edgeList.get(n2), r2 = i2.getSym();
              null === e4 && (e4 = r2), null !== t3 && r2.setNext(t3), t3 = i2;
            }
            e4.setNext(t3);
          }, e3.prototype.computeDepths = function() {
            if (1 === arguments.length) {
              var t3 = arguments[0], e4 = this.findIndex(t3), n2 = t3.getDepth(Se.LEFT), i2 = t3.getDepth(Se.RIGHT), r2 = this.computeDepths(e4 + 1, this._edgeList.size(), n2);
              if (this.computeDepths(0, e4, r2) !== i2)
                throw new we("depth mismatch at " + t3.getCoordinate());
            } else if (3 === arguments.length) {
              for (var o2 = arguments[0], s2 = arguments[1], a2 = arguments[2], u2 = o2; u2 < s2; u2++) {
                var l2 = this._edgeList.get(u2);
                l2.setEdgeDepths(Se.RIGHT, a2), a2 = l2.getDepth(Se.LEFT);
              }
              return a2;
            }
          }, e3.prototype.mergeSymLabels = function() {
            for (var t3 = this.iterator(); t3.hasNext(); ) {
              var e4 = t3.next();
              e4.getLabel().merge(e4.getSym().getLabel());
            }
          }, e3.prototype.linkMinimalDirectedEdges = function(t3) {
            for (var e4 = null, n2 = null, i2 = this._SCANNING_FOR_INCOMING, r2 = this._resultAreaEdgeList.size() - 1; r2 >= 0; r2--) {
              var o2 = this._resultAreaEdgeList.get(r2), s2 = o2.getSym();
              switch (null === e4 && o2.getEdgeRing() === t3 && (e4 = o2), i2) {
                case this._SCANNING_FOR_INCOMING:
                  if (s2.getEdgeRing() !== t3)
                    continue;
                  n2 = s2, i2 = this._LINKING_TO_OUTGOING;
                  break;
                case this._LINKING_TO_OUTGOING:
                  if (o2.getEdgeRing() !== t3)
                    continue;
                  n2.setNextMin(o2), i2 = this._SCANNING_FOR_INCOMING;
              }
            }
            i2 === this._LINKING_TO_OUTGOING && (et.isTrue(null !== e4, "found null for first outgoing dirEdge"), et.isTrue(e4.getEdgeRing() === t3, "unable to link last incoming dirEdge"), n2.setNextMin(e4));
          }, e3.prototype.getOutgoingDegree = function() {
            if (0 === arguments.length) {
              for (var t3 = 0, e4 = this.iterator(); e4.hasNext(); ) {
                e4.next().isInResult() && t3++;
              }
              return t3;
            }
            if (1 === arguments.length) {
              for (var n2 = arguments[0], i2 = 0, r2 = this.iterator(); r2.hasNext(); ) {
                r2.next().getEdgeRing() === n2 && i2++;
              }
              return i2;
            }
          }, e3.prototype.getLabel = function() {
            return this._label;
          }, e3.prototype.findCoveredLineEdges = function() {
            for (var t3 = w.NONE, e4 = this.iterator(); e4.hasNext(); ) {
              var n2 = e4.next(), i2 = n2.getSym();
              if (!n2.isLineEdge()) {
                if (n2.isInResult()) {
                  t3 = w.INTERIOR;
                  break;
                }
                if (i2.isInResult()) {
                  t3 = w.EXTERIOR;
                  break;
                }
              }
            }
            if (t3 === w.NONE)
              return null;
            for (var r2 = t3, o2 = this.iterator(); o2.hasNext(); ) {
              var s2 = o2.next(), a2 = s2.getSym();
              s2.isLineEdge() ? s2.getEdge().setCovered(r2 === w.INTERIOR) : (s2.isInResult() && (r2 = w.EXTERIOR), a2.isInResult() && (r2 = w.INTERIOR));
            }
          }, e3.prototype.computeLabelling = function(e4) {
            t2.prototype.computeLabelling.call(this, e4), this._label = new Pe(w.NONE);
            for (var n2 = this.iterator(); n2.hasNext(); )
              for (var i2 = n2.next().getEdge().getLabel(), r2 = 0; r2 < 2; r2++) {
                var o2 = i2.getLocation(r2);
                o2 !== w.INTERIOR && o2 !== w.BOUNDARY || this._label.setLocation(r2, w.INTERIOR);
              }
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(Xn), kn = function(t2) {
          function e3() {
            t2.apply(this, arguments);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.createNode = function(t3) {
            return new Ge(t3, new Yn());
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(Xe), jn = function t2() {
          this._pts = null, this._orientation = null;
          var e3 = arguments[0];
          this._pts = e3, this._orientation = t2.orientation(e3);
        };
        jn.prototype.compareTo = function(t2) {
          var e3 = t2;
          return jn.compareOriented(this._pts, this._orientation, e3._pts, e3._orientation);
        }, jn.prototype.interfaces_ = function() {
          return [E];
        }, jn.prototype.getClass = function() {
          return jn;
        }, jn.orientation = function(t2) {
          return 1 === Lt.increasingDirection(t2);
        }, jn.compareOriented = function(t2, e3, n2, i2) {
          for (var r2 = e3 ? 1 : -1, o2 = i2 ? 1 : -1, s2 = e3 ? t2.length : -1, a2 = i2 ? n2.length : -1, u2 = e3 ? 0 : t2.length - 1, l2 = i2 ? 0 : n2.length - 1; ; ) {
            var c2 = t2[u2].compareTo(n2[l2]);
            if (0 !== c2)
              return c2;
            var p2 = (u2 += r2) === s2, h2 = (l2 += o2) === a2;
            if (p2 && !h2)
              return -1;
            if (!p2 && h2)
              return 1;
            if (p2 && h2)
              return 0;
          }
        };
        var Hn = function() {
          this._edges = new Nt(), this._ocaMap = new p();
        };
        Hn.prototype.print = function(t2) {
          t2.print("MULTILINESTRING ( ");
          for (var e3 = 0; e3 < this._edges.size(); e3++) {
            var n2 = this._edges.get(e3);
            e3 > 0 && t2.print(","), t2.print("(");
            for (var i2 = n2.getCoordinates(), r2 = 0; r2 < i2.length; r2++)
              r2 > 0 && t2.print(","), t2.print(i2[r2].x + " " + i2[r2].y);
            t2.println(")");
          }
          t2.print(")  ");
        }, Hn.prototype.addAll = function(t2) {
          for (var e3 = t2.iterator(); e3.hasNext(); )
            this.add(e3.next());
        }, Hn.prototype.findEdgeIndex = function(t2) {
          for (var e3 = 0; e3 < this._edges.size(); e3++)
            if (this._edges.get(e3).equals(t2))
              return e3;
          return -1;
        }, Hn.prototype.iterator = function() {
          return this._edges.iterator();
        }, Hn.prototype.getEdges = function() {
          return this._edges;
        }, Hn.prototype.get = function(t2) {
          return this._edges.get(t2);
        }, Hn.prototype.findEqualEdge = function(t2) {
          var e3 = new jn(t2.getCoordinates());
          return this._ocaMap.get(e3);
        }, Hn.prototype.add = function(t2) {
          this._edges.add(t2);
          var e3 = new jn(t2.getCoordinates());
          this._ocaMap.put(e3, t2);
        }, Hn.prototype.interfaces_ = function() {
          return [];
        }, Hn.prototype.getClass = function() {
          return Hn;
        };
        var Wn = function() {
        };
        Wn.prototype.processIntersections = function(t2, e3, n2, i2) {
        }, Wn.prototype.isDone = function() {
        }, Wn.prototype.interfaces_ = function() {
          return [];
        }, Wn.prototype.getClass = function() {
          return Wn;
        };
        var Kn = function() {
          this._hasIntersection = false, this._hasProper = false, this._hasProperInterior = false, this._hasInterior = false, this._properIntersectionPoint = null, this._li = null, this._isSelfIntersection = null, this.numIntersections = 0, this.numInteriorIntersections = 0, this.numProperIntersections = 0, this.numTests = 0;
          var t2 = arguments[0];
          this._li = t2;
        };
        Kn.prototype.isTrivialIntersection = function(t2, e3, n2, i2) {
          if (t2 === n2 && 1 === this._li.getIntersectionNum()) {
            if (Kn.isAdjacentSegments(e3, i2))
              return true;
            if (t2.isClosed()) {
              var r2 = t2.size() - 1;
              if (0 === e3 && i2 === r2 || 0 === i2 && e3 === r2)
                return true;
            }
          }
          return false;
        }, Kn.prototype.getProperIntersectionPoint = function() {
          return this._properIntersectionPoint;
        }, Kn.prototype.hasProperInteriorIntersection = function() {
          return this._hasProperInterior;
        }, Kn.prototype.getLineIntersector = function() {
          return this._li;
        }, Kn.prototype.hasProperIntersection = function() {
          return this._hasProper;
        }, Kn.prototype.processIntersections = function(t2, e3, n2, i2) {
          if (t2 === n2 && e3 === i2)
            return null;
          this.numTests++;
          var r2 = t2.getCoordinates()[e3], o2 = t2.getCoordinates()[e3 + 1], s2 = n2.getCoordinates()[i2], a2 = n2.getCoordinates()[i2 + 1];
          this._li.computeIntersection(r2, o2, s2, a2), this._li.hasIntersection() && (this.numIntersections++, this._li.isInteriorIntersection() && (this.numInteriorIntersections++, this._hasInterior = true), this.isTrivialIntersection(t2, e3, n2, i2) || (this._hasIntersection = true, t2.addIntersections(this._li, e3, 0), n2.addIntersections(this._li, i2, 1), this._li.isProper() && (this.numProperIntersections++, this._hasProper = true, this._hasProperInterior = true)));
        }, Kn.prototype.hasIntersection = function() {
          return this._hasIntersection;
        }, Kn.prototype.isDone = function() {
          return false;
        }, Kn.prototype.hasInteriorIntersection = function() {
          return this._hasInterior;
        }, Kn.prototype.interfaces_ = function() {
          return [Wn];
        }, Kn.prototype.getClass = function() {
          return Kn;
        }, Kn.isAdjacentSegments = function(t2, e3) {
          return 1 === Math.abs(t2 - e3);
        };
        var Jn = function() {
          this.coord = null, this.segmentIndex = null, this.dist = null;
          var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
          this.coord = new C(t2), this.segmentIndex = e3, this.dist = n2;
        };
        Jn.prototype.getSegmentIndex = function() {
          return this.segmentIndex;
        }, Jn.prototype.getCoordinate = function() {
          return this.coord;
        }, Jn.prototype.print = function(t2) {
          t2.print(this.coord), t2.print(" seg # = " + this.segmentIndex), t2.println(" dist = " + this.dist);
        }, Jn.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this.compare(e3.segmentIndex, e3.dist);
        }, Jn.prototype.isEndPoint = function(t2) {
          return 0 === this.segmentIndex && 0 === this.dist || this.segmentIndex === t2;
        }, Jn.prototype.toString = function() {
          return this.coord + " seg # = " + this.segmentIndex + " dist = " + this.dist;
        }, Jn.prototype.getDistance = function() {
          return this.dist;
        }, Jn.prototype.compare = function(t2, e3) {
          return this.segmentIndex < t2 ? -1 : this.segmentIndex > t2 ? 1 : this.dist < e3 ? -1 : this.dist > e3 ? 1 : 0;
        }, Jn.prototype.interfaces_ = function() {
          return [E];
        }, Jn.prototype.getClass = function() {
          return Jn;
        };
        var Qn = function() {
          this._nodeMap = new p(), this.edge = null;
          var t2 = arguments[0];
          this.edge = t2;
        };
        Qn.prototype.print = function(t2) {
          t2.println("Intersections:");
          for (var e3 = this.iterator(); e3.hasNext(); ) {
            e3.next().print(t2);
          }
        }, Qn.prototype.iterator = function() {
          return this._nodeMap.values().iterator();
        }, Qn.prototype.addSplitEdges = function(t2) {
          this.addEndpoints();
          for (var e3 = this.iterator(), n2 = e3.next(); e3.hasNext(); ) {
            var i2 = e3.next(), r2 = this.createSplitEdge(n2, i2);
            t2.add(r2), n2 = i2;
          }
        }, Qn.prototype.addEndpoints = function() {
          var t2 = this.edge.pts.length - 1;
          this.add(this.edge.pts[0], 0, 0), this.add(this.edge.pts[t2], t2, 0);
        }, Qn.prototype.createSplitEdge = function(t2, e3) {
          var n2 = e3.segmentIndex - t2.segmentIndex + 2, i2 = this.edge.pts[e3.segmentIndex], r2 = e3.dist > 0 || !e3.coord.equals2D(i2);
          r2 || n2--;
          var o2 = new Array(n2).fill(null), s2 = 0;
          o2[s2++] = new C(t2.coord);
          for (var a2 = t2.segmentIndex + 1; a2 <= e3.segmentIndex; a2++)
            o2[s2++] = this.edge.pts[a2];
          return r2 && (o2[s2] = e3.coord), new ni(o2, new Pe(this.edge._label));
        }, Qn.prototype.add = function(t2, e3, n2) {
          var i2 = new Jn(t2, e3, n2), r2 = this._nodeMap.get(i2);
          return null !== r2 ? r2 : (this._nodeMap.put(i2, i2), i2);
        }, Qn.prototype.isIntersection = function(t2) {
          for (var e3 = this.iterator(); e3.hasNext(); ) {
            if (e3.next().coord.equals(t2))
              return true;
          }
          return false;
        }, Qn.prototype.interfaces_ = function() {
          return [];
        }, Qn.prototype.getClass = function() {
          return Qn;
        };
        var Zn = function() {
        };
        Zn.prototype.getChainStartIndices = function(t2) {
          var e3 = 0, n2 = new Nt();
          n2.add(new M(e3));
          do {
            var i2 = this.findChainEnd(t2, e3);
            n2.add(new M(i2)), e3 = i2;
          } while (e3 < t2.length - 1);
          return Zn.toIntArray(n2);
        }, Zn.prototype.findChainEnd = function(t2, e3) {
          for (var n2 = Be.quadrant(t2[e3], t2[e3 + 1]), i2 = e3 + 1; i2 < t2.length; ) {
            if (Be.quadrant(t2[i2 - 1], t2[i2]) !== n2)
              break;
            i2++;
          }
          return i2 - 1;
        }, Zn.prototype.interfaces_ = function() {
          return [];
        }, Zn.prototype.getClass = function() {
          return Zn;
        }, Zn.toIntArray = function(t2) {
          for (var e3 = new Array(t2.size()).fill(null), n2 = 0; n2 < e3.length; n2++)
            e3[n2] = t2.get(n2).intValue();
          return e3;
        };
        var $n = function() {
          this.e = null, this.pts = null, this.startIndex = null, this.env1 = new j(), this.env2 = new j();
          var t2 = arguments[0];
          this.e = t2, this.pts = t2.getCoordinates();
          var e3 = new Zn();
          this.startIndex = e3.getChainStartIndices(this.pts);
        };
        $n.prototype.getCoordinates = function() {
          return this.pts;
        }, $n.prototype.getMaxX = function(t2) {
          var e3 = this.pts[this.startIndex[t2]].x, n2 = this.pts[this.startIndex[t2 + 1]].x;
          return e3 > n2 ? e3 : n2;
        }, $n.prototype.getMinX = function(t2) {
          var e3 = this.pts[this.startIndex[t2]].x, n2 = this.pts[this.startIndex[t2 + 1]].x;
          return e3 < n2 ? e3 : n2;
        }, $n.prototype.computeIntersectsForChain = function() {
          if (4 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2], i2 = arguments[3];
            this.computeIntersectsForChain(this.startIndex[t2], this.startIndex[t2 + 1], e3, e3.startIndex[n2], e3.startIndex[n2 + 1], i2);
          } else if (6 === arguments.length) {
            var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2], a2 = arguments[3], u2 = arguments[4], l2 = arguments[5], c2 = this.pts[r2], p2 = this.pts[o2], h2 = s2.pts[a2], f2 = s2.pts[u2];
            if (o2 - r2 == 1 && u2 - a2 == 1)
              return l2.addIntersections(this.e, r2, s2.e, a2), null;
            if (this.env1.init(c2, p2), this.env2.init(h2, f2), !this.env1.intersects(this.env2))
              return null;
            var g2 = Math.trunc((r2 + o2) / 2), d2 = Math.trunc((a2 + u2) / 2);
            r2 < g2 && (a2 < d2 && this.computeIntersectsForChain(r2, g2, s2, a2, d2, l2), d2 < u2 && this.computeIntersectsForChain(r2, g2, s2, d2, u2, l2)), g2 < o2 && (a2 < d2 && this.computeIntersectsForChain(g2, o2, s2, a2, d2, l2), d2 < u2 && this.computeIntersectsForChain(g2, o2, s2, d2, u2, l2));
          }
        }, $n.prototype.getStartIndexes = function() {
          return this.startIndex;
        }, $n.prototype.computeIntersects = function(t2, e3) {
          for (var n2 = 0; n2 < this.startIndex.length - 1; n2++)
            for (var i2 = 0; i2 < t2.startIndex.length - 1; i2++)
              this.computeIntersectsForChain(n2, t2, i2, e3);
        }, $n.prototype.interfaces_ = function() {
          return [];
        }, $n.prototype.getClass = function() {
          return $n;
        };
        var ti = function t2() {
          this._depth = Array(2).fill().map(function() {
            return Array(3);
          });
          for (var e3 = 0; e3 < 2; e3++)
            for (var n2 = 0; n2 < 3; n2++)
              this._depth[e3][n2] = t2.NULL_VALUE;
        }, ei = { NULL_VALUE: { configurable: true } };
        ti.prototype.getDepth = function(t2, e3) {
          return this._depth[t2][e3];
        }, ti.prototype.setDepth = function(t2, e3, n2) {
          this._depth[t2][e3] = n2;
        }, ti.prototype.isNull = function() {
          if (0 === arguments.length) {
            for (var t2 = 0; t2 < 2; t2++)
              for (var e3 = 0; e3 < 3; e3++)
                if (this._depth[t2][e3] !== ti.NULL_VALUE)
                  return false;
            return true;
          }
          if (1 === arguments.length) {
            var n2 = arguments[0];
            return this._depth[n2][1] === ti.NULL_VALUE;
          }
          if (2 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1];
            return this._depth[i2][r2] === ti.NULL_VALUE;
          }
        }, ti.prototype.normalize = function() {
          for (var t2 = 0; t2 < 2; t2++)
            if (!this.isNull(t2)) {
              var e3 = this._depth[t2][1];
              this._depth[t2][2] < e3 && (e3 = this._depth[t2][2]), e3 < 0 && (e3 = 0);
              for (var n2 = 1; n2 < 3; n2++) {
                var i2 = 0;
                this._depth[t2][n2] > e3 && (i2 = 1), this._depth[t2][n2] = i2;
              }
            }
        }, ti.prototype.getDelta = function(t2) {
          return this._depth[t2][Se.RIGHT] - this._depth[t2][Se.LEFT];
        }, ti.prototype.getLocation = function(t2, e3) {
          return this._depth[t2][e3] <= 0 ? w.EXTERIOR : w.INTERIOR;
        }, ti.prototype.toString = function() {
          return "A: " + this._depth[0][1] + "," + this._depth[0][2] + " B: " + this._depth[1][1] + "," + this._depth[1][2];
        }, ti.prototype.add = function() {
          if (1 === arguments.length)
            for (var t2 = arguments[0], e3 = 0; e3 < 2; e3++)
              for (var n2 = 1; n2 < 3; n2++) {
                var i2 = t2.getLocation(e3, n2);
                i2 !== w.EXTERIOR && i2 !== w.INTERIOR || (this.isNull(e3, n2) ? this._depth[e3][n2] = ti.depthAtLocation(i2) : this._depth[e3][n2] += ti.depthAtLocation(i2));
              }
          else if (3 === arguments.length) {
            var r2 = arguments[0], o2 = arguments[1];
            arguments[2] === w.INTERIOR && this._depth[r2][o2]++;
          }
        }, ti.prototype.interfaces_ = function() {
          return [];
        }, ti.prototype.getClass = function() {
          return ti;
        }, ti.depthAtLocation = function(t2) {
          return t2 === w.EXTERIOR ? 0 : t2 === w.INTERIOR ? 1 : ti.NULL_VALUE;
        }, ei.NULL_VALUE.get = function() {
          return -1;
        }, Object.defineProperties(ti, ei);
        var ni = function(t2) {
          function e3() {
            if (t2.call(this), this.pts = null, this._env = null, this.eiList = new Qn(this), this._name = null, this._mce = null, this._isIsolated = true, this._depth = new ti(), this._depthDelta = 0, 1 === arguments.length) {
              var n2 = arguments[0];
              e3.call(this, n2, null);
            } else if (2 === arguments.length) {
              var i2 = arguments[0], r2 = arguments[1];
              this.pts = i2, this._label = r2;
            }
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.getDepth = function() {
            return this._depth;
          }, e3.prototype.getCollapsedEdge = function() {
            var t3 = new Array(2).fill(null);
            t3[0] = this.pts[0], t3[1] = this.pts[1];
            return new e3(t3, Pe.toLineLabel(this._label));
          }, e3.prototype.isIsolated = function() {
            return this._isIsolated;
          }, e3.prototype.getCoordinates = function() {
            return this.pts;
          }, e3.prototype.setIsolated = function(t3) {
            this._isIsolated = t3;
          }, e3.prototype.setName = function(t3) {
            this._name = t3;
          }, e3.prototype.equals = function(t3) {
            if (!(t3 instanceof e3))
              return false;
            var n2 = t3;
            if (this.pts.length !== n2.pts.length)
              return false;
            for (var i2 = true, r2 = true, o2 = this.pts.length, s2 = 0; s2 < this.pts.length; s2++)
              if (this.pts[s2].equals2D(n2.pts[s2]) || (i2 = false), this.pts[s2].equals2D(n2.pts[--o2]) || (r2 = false), !i2 && !r2)
                return false;
            return true;
          }, e3.prototype.getCoordinate = function() {
            if (0 === arguments.length)
              return this.pts.length > 0 ? this.pts[0] : null;
            if (1 === arguments.length) {
              var t3 = arguments[0];
              return this.pts[t3];
            }
          }, e3.prototype.print = function(t3) {
            t3.print("edge " + this._name + ": "), t3.print("LINESTRING (");
            for (var e4 = 0; e4 < this.pts.length; e4++)
              e4 > 0 && t3.print(","), t3.print(this.pts[e4].x + " " + this.pts[e4].y);
            t3.print(")  " + this._label + " " + this._depthDelta);
          }, e3.prototype.computeIM = function(t3) {
            e3.updateIM(this._label, t3);
          }, e3.prototype.isCollapsed = function() {
            return !!this._label.isArea() && (3 === this.pts.length && !!this.pts[0].equals(this.pts[2]));
          }, e3.prototype.isClosed = function() {
            return this.pts[0].equals(this.pts[this.pts.length - 1]);
          }, e3.prototype.getMaximumSegmentIndex = function() {
            return this.pts.length - 1;
          }, e3.prototype.getDepthDelta = function() {
            return this._depthDelta;
          }, e3.prototype.getNumPoints = function() {
            return this.pts.length;
          }, e3.prototype.printReverse = function(t3) {
            t3.print("edge " + this._name + ": ");
            for (var e4 = this.pts.length - 1; e4 >= 0; e4--)
              t3.print(this.pts[e4] + " ");
            t3.println("");
          }, e3.prototype.getMonotoneChainEdge = function() {
            return null === this._mce && (this._mce = new $n(this)), this._mce;
          }, e3.prototype.getEnvelope = function() {
            if (null === this._env) {
              this._env = new j();
              for (var t3 = 0; t3 < this.pts.length; t3++)
                this._env.expandToInclude(this.pts[t3]);
            }
            return this._env;
          }, e3.prototype.addIntersection = function(t3, e4, n2, i2) {
            var r2 = new C(t3.getIntersection(i2)), o2 = e4, s2 = t3.getEdgeDistance(n2, i2), a2 = o2 + 1;
            if (a2 < this.pts.length) {
              var u2 = this.pts[a2];
              r2.equals2D(u2) && (o2 = a2, s2 = 0);
            }
            this.eiList.add(r2, o2, s2);
          }, e3.prototype.toString = function() {
            var t3 = new D();
            t3.append("edge " + this._name + ": "), t3.append("LINESTRING (");
            for (var e4 = 0; e4 < this.pts.length; e4++)
              e4 > 0 && t3.append(","), t3.append(this.pts[e4].x + " " + this.pts[e4].y);
            return t3.append(")  " + this._label + " " + this._depthDelta), t3.toString();
          }, e3.prototype.isPointwiseEqual = function(t3) {
            if (this.pts.length !== t3.pts.length)
              return false;
            for (var e4 = 0; e4 < this.pts.length; e4++)
              if (!this.pts[e4].equals2D(t3.pts[e4]))
                return false;
            return true;
          }, e3.prototype.setDepthDelta = function(t3) {
            this._depthDelta = t3;
          }, e3.prototype.getEdgeIntersectionList = function() {
            return this.eiList;
          }, e3.prototype.addIntersections = function(t3, e4, n2) {
            for (var i2 = 0; i2 < t3.getIntersectionNum(); i2++)
              this.addIntersection(t3, e4, n2, i2);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3.updateIM = function() {
            if (2 !== arguments.length)
              return t2.prototype.updateIM.apply(this, arguments);
            var e4 = arguments[0], n2 = arguments[1];
            n2.setAtLeastIfValid(e4.getLocation(0, Se.ON), e4.getLocation(1, Se.ON), 1), e4.isArea() && (n2.setAtLeastIfValid(e4.getLocation(0, Se.LEFT), e4.getLocation(1, Se.LEFT), 2), n2.setAtLeastIfValid(e4.getLocation(0, Se.RIGHT), e4.getLocation(1, Se.RIGHT), 2));
          }, e3;
        }(Fe), ii = function(t2) {
          this._workingPrecisionModel = null, this._workingNoder = null, this._geomFact = null, this._graph = null, this._edgeList = new Hn(), this._bufParams = t2 || null;
        };
        ii.prototype.setWorkingPrecisionModel = function(t2) {
          this._workingPrecisionModel = t2;
        }, ii.prototype.insertUniqueEdge = function(t2) {
          var e3 = this._edgeList.findEqualEdge(t2);
          if (null !== e3) {
            var n2 = e3.getLabel(), i2 = t2.getLabel();
            e3.isPointwiseEqual(t2) || (i2 = new Pe(t2.getLabel())).flip(), n2.merge(i2);
            var r2 = ii.depthDelta(i2), o2 = e3.getDepthDelta() + r2;
            e3.setDepthDelta(o2);
          } else
            this._edgeList.add(t2), t2.setDepthDelta(ii.depthDelta(t2.getLabel()));
        }, ii.prototype.buildSubgraphs = function(t2, e3) {
          for (var n2 = new Nt(), i2 = t2.iterator(); i2.hasNext(); ) {
            var r2 = i2.next(), o2 = r2.getRightmostCoordinate(), s2 = new An(n2).getDepth(o2);
            r2.computeDepth(s2), r2.findResultEdges(), n2.add(r2), e3.add(r2.getDirectedEdges(), r2.getNodes());
          }
        }, ii.prototype.createSubgraphs = function(t2) {
          for (var e3 = new Nt(), n2 = t2.getNodes().iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            if (!i2.isVisited()) {
              var r2 = new Te();
              r2.create(i2), e3.add(r2);
            }
          }
          return $e.sort(e3, $e.reverseOrder()), e3;
        }, ii.prototype.createEmptyResultGeometry = function() {
          return this._geomFact.createPolygon();
        }, ii.prototype.getNoder = function(t2) {
          if (null !== this._workingNoder)
            return this._workingNoder;
          var e3 = new xn(), n2 = new rt();
          return n2.setPrecisionModel(t2), e3.setSegmentIntersector(new Kn(n2)), e3;
        }, ii.prototype.buffer = function(t2, e3) {
          var n2 = this._workingPrecisionModel;
          null === n2 && (n2 = t2.getPrecisionModel()), this._geomFact = t2.getFactory();
          var i2 = new Mn(n2, this._bufParams), r2 = new Bn(t2, e3, i2).getCurves();
          if (r2.size() <= 0)
            return this.createEmptyResultGeometry();
          this.computeNodedEdges(r2, n2), this._graph = new Ye(new kn()), this._graph.addEdges(this._edgeList.getEdges());
          var o2 = this.createSubgraphs(this._graph), s2 = new ke(this._geomFact);
          this.buildSubgraphs(o2, s2);
          var a2 = s2.getPolygons();
          if (a2.size() <= 0)
            return this.createEmptyResultGeometry();
          return this._geomFact.buildGeometry(a2);
        }, ii.prototype.computeNodedEdges = function(t2, e3) {
          var n2 = this.getNoder(e3);
          n2.computeNodes(t2);
          for (var i2 = n2.getNodedSubstrings().iterator(); i2.hasNext(); ) {
            var r2 = i2.next(), o2 = r2.getCoordinates();
            if (2 !== o2.length || !o2[0].equals2D(o2[1])) {
              var s2 = r2.getData(), a2 = new ni(r2.getCoordinates(), new Pe(s2));
              this.insertUniqueEdge(a2);
            }
          }
        }, ii.prototype.setNoder = function(t2) {
          this._workingNoder = t2;
        }, ii.prototype.interfaces_ = function() {
          return [];
        }, ii.prototype.getClass = function() {
          return ii;
        }, ii.depthDelta = function(t2) {
          var e3 = t2.getLocation(0, Se.LEFT), n2 = t2.getLocation(0, Se.RIGHT);
          return e3 === w.INTERIOR && n2 === w.EXTERIOR ? 1 : e3 === w.EXTERIOR && n2 === w.INTERIOR ? -1 : 0;
        }, ii.convertSegStrings = function(t2) {
          for (var e3 = new _e(), n2 = new Nt(); t2.hasNext(); ) {
            var i2 = t2.next(), r2 = e3.createLineString(i2.getCoordinates());
            n2.add(r2);
          }
          return e3.buildGeometry(n2);
        };
        var ri = function() {
          if (this._noder = null, this._scaleFactor = null, this._offsetX = null, this._offsetY = null, this._isScaled = false, 2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            this._noder = t2, this._scaleFactor = e3, this._offsetX = 0, this._offsetY = 0, this._isScaled = !this.isIntegerPrecision();
          } else if (4 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2], o2 = arguments[3];
            this._noder = n2, this._scaleFactor = i2, this._offsetX = r2, this._offsetY = o2, this._isScaled = !this.isIntegerPrecision();
          }
        };
        ri.prototype.rescale = function() {
          if (T(arguments[0], It))
            for (var t2 = arguments[0].iterator(); t2.hasNext(); ) {
              var e3 = t2.next();
              this.rescale(e3.getCoordinates());
            }
          else if (arguments[0] instanceof Array) {
            for (var n2 = arguments[0], i2 = 0; i2 < n2.length; i2++)
              n2[i2].x = n2[i2].x / this._scaleFactor + this._offsetX, n2[i2].y = n2[i2].y / this._scaleFactor + this._offsetY;
            2 === n2.length && n2[0].equals2D(n2[1]) && Y.out.println(n2);
          }
        }, ri.prototype.scale = function() {
          if (T(arguments[0], It)) {
            for (var t2 = arguments[0], e3 = new Nt(), n2 = t2.iterator(); n2.hasNext(); ) {
              var i2 = n2.next();
              e3.add(new gn(this.scale(i2.getCoordinates()), i2.getData()));
            }
            return e3;
          }
          if (arguments[0] instanceof Array) {
            for (var r2 = arguments[0], o2 = new Array(r2.length).fill(null), s2 = 0; s2 < r2.length; s2++)
              o2[s2] = new C(Math.round((r2[s2].x - this._offsetX) * this._scaleFactor), Math.round((r2[s2].y - this._offsetY) * this._scaleFactor), r2[s2].z);
            return Lt.removeRepeatedPoints(o2);
          }
        }, ri.prototype.isIntegerPrecision = function() {
          return 1 === this._scaleFactor;
        }, ri.prototype.getNodedSubstrings = function() {
          var t2 = this._noder.getNodedSubstrings();
          return this._isScaled && this.rescale(t2), t2;
        }, ri.prototype.computeNodes = function(t2) {
          var e3 = t2;
          this._isScaled && (e3 = this.scale(t2)), this._noder.computeNodes(e3);
        }, ri.prototype.interfaces_ = function() {
          return [In];
        }, ri.prototype.getClass = function() {
          return ri;
        };
        var oi = function() {
          this._li = new rt(), this._segStrings = null;
          var t2 = arguments[0];
          this._segStrings = t2;
        }, si = { fact: { configurable: true } };
        oi.prototype.checkEndPtVertexIntersections = function() {
          if (0 === arguments.length)
            for (var t2 = this._segStrings.iterator(); t2.hasNext(); ) {
              var e3 = t2.next().getCoordinates();
              this.checkEndPtVertexIntersections(e3[0], this._segStrings), this.checkEndPtVertexIntersections(e3[e3.length - 1], this._segStrings);
            }
          else if (2 === arguments.length) {
            for (var n2 = arguments[0], i2 = arguments[1].iterator(); i2.hasNext(); )
              for (var r2 = i2.next().getCoordinates(), o2 = 1; o2 < r2.length - 1; o2++)
                if (r2[o2].equals(n2))
                  throw new $("found endpt/interior pt intersection at index " + o2 + " :pt " + n2);
          }
        }, oi.prototype.checkInteriorIntersections = function() {
          if (0 === arguments.length)
            for (var t2 = this._segStrings.iterator(); t2.hasNext(); )
              for (var e3 = t2.next(), n2 = this._segStrings.iterator(); n2.hasNext(); ) {
                var i2 = n2.next();
                this.checkInteriorIntersections(e3, i2);
              }
          else if (2 === arguments.length)
            for (var r2 = arguments[0], o2 = arguments[1], s2 = r2.getCoordinates(), a2 = o2.getCoordinates(), u2 = 0; u2 < s2.length - 1; u2++)
              for (var l2 = 0; l2 < a2.length - 1; l2++)
                this.checkInteriorIntersections(r2, u2, o2, l2);
          else if (4 === arguments.length) {
            var c2 = arguments[0], p2 = arguments[1], h2 = arguments[2], f2 = arguments[3];
            if (c2 === h2 && p2 === f2)
              return null;
            var g2 = c2.getCoordinates()[p2], d2 = c2.getCoordinates()[p2 + 1], y3 = h2.getCoordinates()[f2], _2 = h2.getCoordinates()[f2 + 1];
            if (this._li.computeIntersection(g2, d2, y3, _2), this._li.hasIntersection() && (this._li.isProper() || this.hasInteriorIntersection(this._li, g2, d2) || this.hasInteriorIntersection(this._li, y3, _2)))
              throw new $("found non-noded intersection at " + g2 + "-" + d2 + " and " + y3 + "-" + _2);
          }
        }, oi.prototype.checkValid = function() {
          this.checkEndPtVertexIntersections(), this.checkInteriorIntersections(), this.checkCollapses();
        }, oi.prototype.checkCollapses = function() {
          if (0 === arguments.length)
            for (var t2 = this._segStrings.iterator(); t2.hasNext(); ) {
              var e3 = t2.next();
              this.checkCollapses(e3);
            }
          else if (1 === arguments.length)
            for (var n2 = arguments[0].getCoordinates(), i2 = 0; i2 < n2.length - 2; i2++)
              this.checkCollapse(n2[i2], n2[i2 + 1], n2[i2 + 2]);
        }, oi.prototype.hasInteriorIntersection = function(t2, e3, n2) {
          for (var i2 = 0; i2 < t2.getIntersectionNum(); i2++) {
            var r2 = t2.getIntersection(i2);
            if (!r2.equals(e3) && !r2.equals(n2))
              return true;
          }
          return false;
        }, oi.prototype.checkCollapse = function(t2, e3, n2) {
          if (t2.equals(n2))
            throw new $("found non-noded collapse at " + oi.fact.createLineString([t2, e3, n2]));
        }, oi.prototype.interfaces_ = function() {
          return [];
        }, oi.prototype.getClass = function() {
          return oi;
        }, si.fact.get = function() {
          return new _e();
        }, Object.defineProperties(oi, si);
        var ai = function() {
          this._li = null, this._pt = null, this._originalPt = null, this._ptScaled = null, this._p0Scaled = null, this._p1Scaled = null, this._scaleFactor = null, this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, this._corner = new Array(4).fill(null), this._safeEnv = null;
          var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
          if (this._originalPt = t2, this._pt = t2, this._scaleFactor = e3, this._li = n2, e3 <= 0)
            throw new m("Scale factor must be non-zero");
          1 !== e3 && (this._pt = new C(this.scale(t2.x), this.scale(t2.y)), this._p0Scaled = new C(), this._p1Scaled = new C()), this.initCorners(this._pt);
        }, ui = { SAFE_ENV_EXPANSION_FACTOR: { configurable: true } };
        ai.prototype.intersectsScaled = function(t2, e3) {
          var n2 = Math.min(t2.x, e3.x), i2 = Math.max(t2.x, e3.x), r2 = Math.min(t2.y, e3.y), o2 = Math.max(t2.y, e3.y), s2 = this._maxx < n2 || this._minx > i2 || this._maxy < r2 || this._miny > o2;
          if (s2)
            return false;
          var a2 = this.intersectsToleranceSquare(t2, e3);
          return et.isTrue(!(s2 && a2), "Found bad envelope test"), a2;
        }, ai.prototype.initCorners = function(t2) {
          this._minx = t2.x - 0.5, this._maxx = t2.x + 0.5, this._miny = t2.y - 0.5, this._maxy = t2.y + 0.5, this._corner[0] = new C(this._maxx, this._maxy), this._corner[1] = new C(this._minx, this._maxy), this._corner[2] = new C(this._minx, this._miny), this._corner[3] = new C(this._maxx, this._miny);
        }, ai.prototype.intersects = function(t2, e3) {
          return 1 === this._scaleFactor ? this.intersectsScaled(t2, e3) : (this.copyScaled(t2, this._p0Scaled), this.copyScaled(e3, this._p1Scaled), this.intersectsScaled(this._p0Scaled, this._p1Scaled));
        }, ai.prototype.scale = function(t2) {
          return Math.round(t2 * this._scaleFactor);
        }, ai.prototype.getCoordinate = function() {
          return this._originalPt;
        }, ai.prototype.copyScaled = function(t2, e3) {
          e3.x = this.scale(t2.x), e3.y = this.scale(t2.y);
        }, ai.prototype.getSafeEnvelope = function() {
          if (null === this._safeEnv) {
            var t2 = ai.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;
            this._safeEnv = new j(this._originalPt.x - t2, this._originalPt.x + t2, this._originalPt.y - t2, this._originalPt.y + t2);
          }
          return this._safeEnv;
        }, ai.prototype.intersectsPixelClosure = function(t2, e3) {
          return this._li.computeIntersection(t2, e3, this._corner[0], this._corner[1]), !!this._li.hasIntersection() || (this._li.computeIntersection(t2, e3, this._corner[1], this._corner[2]), !!this._li.hasIntersection() || (this._li.computeIntersection(t2, e3, this._corner[2], this._corner[3]), !!this._li.hasIntersection() || (this._li.computeIntersection(t2, e3, this._corner[3], this._corner[0]), !!this._li.hasIntersection())));
        }, ai.prototype.intersectsToleranceSquare = function(t2, e3) {
          var n2 = false, i2 = false;
          return this._li.computeIntersection(t2, e3, this._corner[0], this._corner[1]), !!this._li.isProper() || (this._li.computeIntersection(t2, e3, this._corner[1], this._corner[2]), !!this._li.isProper() || (this._li.hasIntersection() && (n2 = true), this._li.computeIntersection(t2, e3, this._corner[2], this._corner[3]), !!this._li.isProper() || (this._li.hasIntersection() && (i2 = true), this._li.computeIntersection(t2, e3, this._corner[3], this._corner[0]), !!this._li.isProper() || (!(!n2 || !i2) || (!!t2.equals(this._pt) || !!e3.equals(this._pt))))));
        }, ai.prototype.addSnappedNode = function(t2, e3) {
          var n2 = t2.getCoordinate(e3), i2 = t2.getCoordinate(e3 + 1);
          return !!this.intersects(n2, i2) && (t2.addIntersection(this.getCoordinate(), e3), true);
        }, ai.prototype.interfaces_ = function() {
          return [];
        }, ai.prototype.getClass = function() {
          return ai;
        }, ui.SAFE_ENV_EXPANSION_FACTOR.get = function() {
          return 0.75;
        }, Object.defineProperties(ai, ui);
        var li = function() {
          this.tempEnv1 = new j(), this.selectedSegment = new dn();
        };
        li.prototype.select = function() {
          if (1 === arguments.length)
            ;
          else if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            t2.getLineSegment(e3, this.selectedSegment), this.select(this.selectedSegment);
          }
        }, li.prototype.interfaces_ = function() {
          return [];
        }, li.prototype.getClass = function() {
          return li;
        };
        var ci = function() {
          this._index = null;
          var t2 = arguments[0];
          this._index = t2;
        }, pi3 = { HotPixelSnapAction: { configurable: true } };
        ci.prototype.snap = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return this.snap(t2, null, -1);
          }
          if (3 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1], i2 = arguments[2], r2 = e3.getSafeEnvelope(), o2 = new hi(e3, n2, i2);
            return this._index.query(r2, { interfaces_: function() {
              return [Ke];
            }, visitItem: function(t3) {
              t3.select(r2, o2);
            } }), o2.isNodeAdded();
          }
        }, ci.prototype.interfaces_ = function() {
          return [];
        }, ci.prototype.getClass = function() {
          return ci;
        }, pi3.HotPixelSnapAction.get = function() {
          return hi;
        }, Object.defineProperties(ci, pi3);
        var hi = function(t2) {
          function e3() {
            t2.call(this), this._hotPixel = null, this._parentEdge = null, this._hotPixelVertexIndex = null, this._isNodeAdded = false;
            var e4 = arguments[0], n2 = arguments[1], i2 = arguments[2];
            this._hotPixel = e4, this._parentEdge = n2, this._hotPixelVertexIndex = i2;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.isNodeAdded = function() {
            return this._isNodeAdded;
          }, e3.prototype.select = function() {
            if (2 !== arguments.length)
              return t2.prototype.select.apply(this, arguments);
            var e4 = arguments[0], n2 = arguments[1], i2 = e4.getContext();
            if (null !== this._parentEdge && i2 === this._parentEdge && n2 === this._hotPixelVertexIndex)
              return null;
            this._isNodeAdded = this._hotPixel.addSnappedNode(i2, n2);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(li), fi = function() {
          this._li = null, this._interiorIntersections = null;
          var t2 = arguments[0];
          this._li = t2, this._interiorIntersections = new Nt();
        };
        fi.prototype.processIntersections = function(t2, e3, n2, i2) {
          if (t2 === n2 && e3 === i2)
            return null;
          var r2 = t2.getCoordinates()[e3], o2 = t2.getCoordinates()[e3 + 1], s2 = n2.getCoordinates()[i2], a2 = n2.getCoordinates()[i2 + 1];
          if (this._li.computeIntersection(r2, o2, s2, a2), this._li.hasIntersection() && this._li.isInteriorIntersection()) {
            for (var u2 = 0; u2 < this._li.getIntersectionNum(); u2++)
              this._interiorIntersections.add(this._li.getIntersection(u2));
            t2.addIntersections(this._li, e3, 0), n2.addIntersections(this._li, i2, 1);
          }
        }, fi.prototype.isDone = function() {
          return false;
        }, fi.prototype.getInteriorIntersections = function() {
          return this._interiorIntersections;
        }, fi.prototype.interfaces_ = function() {
          return [Wn];
        }, fi.prototype.getClass = function() {
          return fi;
        };
        var gi = function() {
          this._pm = null, this._li = null, this._scaleFactor = null, this._noder = null, this._pointSnapper = null, this._nodedSegStrings = null;
          var t2 = arguments[0];
          this._pm = t2, this._li = new rt(), this._li.setPrecisionModel(t2), this._scaleFactor = t2.getScale();
        };
        gi.prototype.checkCorrectness = function(t2) {
          var e3 = gn.getNodedSubstrings(t2), n2 = new oi(e3);
          try {
            n2.checkValid();
          } catch (t3) {
            if (!(t3 instanceof z))
              throw t3;
            t3.printStackTrace();
          }
        }, gi.prototype.getNodedSubstrings = function() {
          return gn.getNodedSubstrings(this._nodedSegStrings);
        }, gi.prototype.snapRound = function(t2, e3) {
          var n2 = this.findInteriorIntersections(t2, e3);
          this.computeIntersectionSnaps(n2), this.computeVertexSnaps(t2);
        }, gi.prototype.findInteriorIntersections = function(t2, e3) {
          var n2 = new fi(e3);
          return this._noder.setSegmentIntersector(n2), this._noder.computeNodes(t2), n2.getInteriorIntersections();
        }, gi.prototype.computeVertexSnaps = function() {
          if (T(arguments[0], It))
            for (var t2 = arguments[0].iterator(); t2.hasNext(); ) {
              var e3 = t2.next();
              this.computeVertexSnaps(e3);
            }
          else if (arguments[0] instanceof gn)
            for (var n2 = arguments[0], i2 = n2.getCoordinates(), r2 = 0; r2 < i2.length; r2++) {
              var o2 = new ai(i2[r2], this._scaleFactor, this._li);
              this._pointSnapper.snap(o2, n2, r2) && n2.addIntersection(i2[r2], r2);
            }
        }, gi.prototype.computeNodes = function(t2) {
          this._nodedSegStrings = t2, this._noder = new xn(), this._pointSnapper = new ci(this._noder.getIndex()), this.snapRound(t2, this._li);
        }, gi.prototype.computeIntersectionSnaps = function(t2) {
          for (var e3 = t2.iterator(); e3.hasNext(); ) {
            var n2 = e3.next(), i2 = new ai(n2, this._scaleFactor, this._li);
            this._pointSnapper.snap(i2);
          }
        }, gi.prototype.interfaces_ = function() {
          return [In];
        }, gi.prototype.getClass = function() {
          return gi;
        };
        var di = function() {
          if (this._argGeom = null, this._distance = null, this._bufParams = new Cn(), this._resultGeometry = null, this._saveException = null, 1 === arguments.length) {
            var t2 = arguments[0];
            this._argGeom = t2;
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            this._argGeom = e3, this._bufParams = n2;
          }
        }, yi = { CAP_ROUND: { configurable: true }, CAP_BUTT: { configurable: true }, CAP_FLAT: { configurable: true }, CAP_SQUARE: { configurable: true }, MAX_PRECISION_DIGITS: { configurable: true } };
        di.prototype.bufferFixedPrecision = function(t2) {
          var e3 = new ri(new gi(new fe(1)), t2.getScale()), n2 = new ii(this._bufParams);
          n2.setWorkingPrecisionModel(t2), n2.setNoder(e3), this._resultGeometry = n2.buffer(this._argGeom, this._distance);
        }, di.prototype.bufferReducedPrecision = function() {
          var t2 = this;
          if (0 === arguments.length) {
            for (var e3 = di.MAX_PRECISION_DIGITS; e3 >= 0; e3--) {
              try {
                t2.bufferReducedPrecision(e3);
              } catch (e4) {
                if (!(e4 instanceof we))
                  throw e4;
                t2._saveException = e4;
              }
              if (null !== t2._resultGeometry)
                return null;
            }
            throw this._saveException;
          }
          if (1 === arguments.length) {
            var n2 = arguments[0], i2 = di.precisionScaleFactor(this._argGeom, this._distance, n2), r2 = new fe(i2);
            this.bufferFixedPrecision(r2);
          }
        }, di.prototype.computeGeometry = function() {
          if (this.bufferOriginalPrecision(), null !== this._resultGeometry)
            return null;
          var t2 = this._argGeom.getFactory().getPrecisionModel();
          t2.getType() === fe.FIXED ? this.bufferFixedPrecision(t2) : this.bufferReducedPrecision();
        }, di.prototype.setQuadrantSegments = function(t2) {
          this._bufParams.setQuadrantSegments(t2);
        }, di.prototype.bufferOriginalPrecision = function() {
          try {
            var t2 = new ii(this._bufParams);
            this._resultGeometry = t2.buffer(this._argGeom, this._distance);
          } catch (t3) {
            if (!(t3 instanceof $))
              throw t3;
            this._saveException = t3;
          }
        }, di.prototype.getResultGeometry = function(t2) {
          return this._distance = t2, this.computeGeometry(), this._resultGeometry;
        }, di.prototype.setEndCapStyle = function(t2) {
          this._bufParams.setEndCapStyle(t2);
        }, di.prototype.interfaces_ = function() {
          return [];
        }, di.prototype.getClass = function() {
          return di;
        }, di.bufferOp = function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            return new di(t2).getResultGeometry(e3);
          }
          if (3 === arguments.length) {
            if (Number.isInteger(arguments[2]) && arguments[0] instanceof ct && "number" == typeof arguments[1]) {
              var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2], o2 = new di(n2);
              o2.setQuadrantSegments(r2);
              return o2.getResultGeometry(i2);
            }
            if (arguments[2] instanceof Cn && arguments[0] instanceof ct && "number" == typeof arguments[1]) {
              var s2 = arguments[0], a2 = arguments[1], u2 = arguments[2];
              return new di(s2, u2).getResultGeometry(a2);
            }
          } else if (4 === arguments.length) {
            var l2 = arguments[0], c2 = arguments[1], p2 = arguments[2], h2 = arguments[3], f2 = new di(l2);
            f2.setQuadrantSegments(p2), f2.setEndCapStyle(h2);
            return f2.getResultGeometry(c2);
          }
        }, di.precisionScaleFactor = function(t2, e3, n2) {
          var i2 = t2.getEnvelopeInternal(), r2 = R.max(Math.abs(i2.getMaxX()), Math.abs(i2.getMaxY()), Math.abs(i2.getMinX()), Math.abs(i2.getMinY())) + 2 * (e3 > 0 ? e3 : 0), o2 = n2 - Math.trunc(Math.log(r2) / Math.log(10) + 1);
          return Math.pow(10, o2);
        }, yi.CAP_ROUND.get = function() {
          return Cn.CAP_ROUND;
        }, yi.CAP_BUTT.get = function() {
          return Cn.CAP_FLAT;
        }, yi.CAP_FLAT.get = function() {
          return Cn.CAP_FLAT;
        }, yi.CAP_SQUARE.get = function() {
          return Cn.CAP_SQUARE;
        }, yi.MAX_PRECISION_DIGITS.get = function() {
          return 12;
        }, Object.defineProperties(di, yi);
        var _i = function() {
          this._pt = [new C(), new C()], this._distance = v.NaN, this._isNull = true;
        };
        _i.prototype.getCoordinates = function() {
          return this._pt;
        }, _i.prototype.getCoordinate = function(t2) {
          return this._pt[t2];
        }, _i.prototype.setMinimum = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.setMinimum(t2._pt[0], t2._pt[1]);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            if (this._isNull)
              return this.initialize(e3, n2), null;
            var i2 = e3.distance(n2);
            i2 < this._distance && this.initialize(e3, n2, i2);
          }
        }, _i.prototype.initialize = function() {
          if (0 === arguments.length)
            this._isNull = true;
          else if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            this._pt[0].setCoordinate(t2), this._pt[1].setCoordinate(e3), this._distance = t2.distance(e3), this._isNull = false;
          } else if (3 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2];
            this._pt[0].setCoordinate(n2), this._pt[1].setCoordinate(i2), this._distance = r2, this._isNull = false;
          }
        }, _i.prototype.getDistance = function() {
          return this._distance;
        }, _i.prototype.setMaximum = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.setMaximum(t2._pt[0], t2._pt[1]);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            if (this._isNull)
              return this.initialize(e3, n2), null;
            var i2 = e3.distance(n2);
            i2 > this._distance && this.initialize(e3, n2, i2);
          }
        }, _i.prototype.interfaces_ = function() {
          return [];
        }, _i.prototype.getClass = function() {
          return _i;
        };
        var mi = function() {
        };
        mi.prototype.interfaces_ = function() {
          return [];
        }, mi.prototype.getClass = function() {
          return mi;
        }, mi.computeDistance = function() {
          if (arguments[2] instanceof _i && arguments[0] instanceof Kt && arguments[1] instanceof C)
            for (var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2], i2 = t2.getCoordinates(), r2 = new dn(), o2 = 0; o2 < i2.length - 1; o2++) {
              r2.setCoordinates(i2[o2], i2[o2 + 1]);
              var s2 = r2.closestPoint(e3);
              n2.setMinimum(s2, e3);
            }
          else if (arguments[2] instanceof _i && arguments[0] instanceof $t && arguments[1] instanceof C) {
            var a2 = arguments[0], u2 = arguments[1], l2 = arguments[2];
            mi.computeDistance(a2.getExteriorRing(), u2, l2);
            for (var c2 = 0; c2 < a2.getNumInteriorRing(); c2++)
              mi.computeDistance(a2.getInteriorRingN(c2), u2, l2);
          } else if (arguments[2] instanceof _i && arguments[0] instanceof ct && arguments[1] instanceof C) {
            var p2 = arguments[0], h2 = arguments[1], f2 = arguments[2];
            if (p2 instanceof Kt)
              mi.computeDistance(p2, h2, f2);
            else if (p2 instanceof $t)
              mi.computeDistance(p2, h2, f2);
            else if (p2 instanceof zt)
              for (var g2 = p2, d2 = 0; d2 < g2.getNumGeometries(); d2++) {
                var y3 = g2.getGeometryN(d2);
                mi.computeDistance(y3, h2, f2);
              }
            else
              f2.setMinimum(p2.getCoordinate(), h2);
          } else if (arguments[2] instanceof _i && arguments[0] instanceof dn && arguments[1] instanceof C) {
            var _2 = arguments[0], m2 = arguments[1], v2 = arguments[2], I2 = _2.closestPoint(m2);
            v2.setMinimum(I2, m2);
          }
        };
        var vi = function(t2) {
          this._maxPtDist = new _i(), this._inputGeom = t2 || null;
        }, Ii = { MaxPointDistanceFilter: { configurable: true }, MaxMidpointDistanceFilter: { configurable: true } };
        vi.prototype.computeMaxMidpointDistance = function(t2) {
          var e3 = new xi(this._inputGeom);
          t2.apply(e3), this._maxPtDist.setMaximum(e3.getMaxPointDistance());
        }, vi.prototype.computeMaxVertexDistance = function(t2) {
          var e3 = new Ei(this._inputGeom);
          t2.apply(e3), this._maxPtDist.setMaximum(e3.getMaxPointDistance());
        }, vi.prototype.findDistance = function(t2) {
          return this.computeMaxVertexDistance(t2), this.computeMaxMidpointDistance(t2), this._maxPtDist.getDistance();
        }, vi.prototype.getDistancePoints = function() {
          return this._maxPtDist;
        }, vi.prototype.interfaces_ = function() {
          return [];
        }, vi.prototype.getClass = function() {
          return vi;
        }, Ii.MaxPointDistanceFilter.get = function() {
          return Ei;
        }, Ii.MaxMidpointDistanceFilter.get = function() {
          return xi;
        }, Object.defineProperties(vi, Ii);
        var Ei = function(t2) {
          this._maxPtDist = new _i(), this._minPtDist = new _i(), this._geom = t2 || null;
        };
        Ei.prototype.filter = function(t2) {
          this._minPtDist.initialize(), mi.computeDistance(this._geom, t2, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);
        }, Ei.prototype.getMaxPointDistance = function() {
          return this._maxPtDist;
        }, Ei.prototype.interfaces_ = function() {
          return [ft];
        }, Ei.prototype.getClass = function() {
          return Ei;
        };
        var xi = function(t2) {
          this._maxPtDist = new _i(), this._minPtDist = new _i(), this._geom = t2 || null;
        };
        xi.prototype.filter = function(t2, e3) {
          if (0 === e3)
            return null;
          var n2 = t2.getCoordinate(e3 - 1), i2 = t2.getCoordinate(e3), r2 = new C((n2.x + i2.x) / 2, (n2.y + i2.y) / 2);
          this._minPtDist.initialize(), mi.computeDistance(this._geom, r2, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);
        }, xi.prototype.isDone = function() {
          return false;
        }, xi.prototype.isGeometryChanged = function() {
          return false;
        }, xi.prototype.getMaxPointDistance = function() {
          return this._maxPtDist;
        }, xi.prototype.interfaces_ = function() {
          return [Ut];
        }, xi.prototype.getClass = function() {
          return xi;
        };
        var Ni = function(t2) {
          this._comps = t2 || null;
        };
        Ni.prototype.filter = function(t2) {
          t2 instanceof $t && this._comps.add(t2);
        }, Ni.prototype.interfaces_ = function() {
          return [Vt];
        }, Ni.prototype.getClass = function() {
          return Ni;
        }, Ni.getPolygons = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return Ni.getPolygons(t2, new Nt());
          }
          if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            return e3 instanceof $t ? n2.add(e3) : e3 instanceof zt && e3.apply(new Ni(n2)), n2;
          }
        };
        var Ci = function() {
          if (this._lines = null, this._isForcedToLineString = false, 1 === arguments.length) {
            var t2 = arguments[0];
            this._lines = t2;
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            this._lines = e3, this._isForcedToLineString = n2;
          }
        };
        Ci.prototype.filter = function(t2) {
          if (this._isForcedToLineString && t2 instanceof ee) {
            var e3 = t2.getFactory().createLineString(t2.getCoordinateSequence());
            return this._lines.add(e3), null;
          }
          t2 instanceof Kt && this._lines.add(t2);
        }, Ci.prototype.setForceToLineString = function(t2) {
          this._isForcedToLineString = t2;
        }, Ci.prototype.interfaces_ = function() {
          return [lt];
        }, Ci.prototype.getClass = function() {
          return Ci;
        }, Ci.getGeometry = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return t2.getFactory().buildGeometry(Ci.getLines(t2));
          }
          if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            return e3.getFactory().buildGeometry(Ci.getLines(e3, n2));
          }
        }, Ci.getLines = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return Ci.getLines(t2, false);
          }
          if (2 === arguments.length) {
            if (T(arguments[0], It) && T(arguments[1], It)) {
              for (var e3 = arguments[0], n2 = arguments[1], i2 = e3.iterator(); i2.hasNext(); ) {
                var r2 = i2.next();
                Ci.getLines(r2, n2);
              }
              return n2;
            }
            if (arguments[0] instanceof ct && "boolean" == typeof arguments[1]) {
              var o2 = arguments[0], s2 = arguments[1], a2 = new Nt();
              return o2.apply(new Ci(a2, s2)), a2;
            }
            if (arguments[0] instanceof ct && T(arguments[1], It)) {
              var u2 = arguments[0], l2 = arguments[1];
              return u2 instanceof Kt ? l2.add(u2) : u2.apply(new Ci(l2)), l2;
            }
          } else if (3 === arguments.length) {
            if ("boolean" == typeof arguments[2] && T(arguments[0], It) && T(arguments[1], It)) {
              for (var c2 = arguments[0], p2 = arguments[1], h2 = arguments[2], f2 = c2.iterator(); f2.hasNext(); ) {
                var g2 = f2.next();
                Ci.getLines(g2, p2, h2);
              }
              return p2;
            }
            if ("boolean" == typeof arguments[2] && arguments[0] instanceof ct && T(arguments[1], It)) {
              var d2 = arguments[0], y3 = arguments[1], _2 = arguments[2];
              return d2.apply(new Ci(y3, _2)), y3;
            }
          }
        };
        var Si = function() {
          if (this._boundaryRule = gt.OGC_SFS_BOUNDARY_RULE, this._isIn = null, this._numBoundaries = null, 0 === arguments.length)
            ;
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            if (null === t2)
              throw new m("Rule must be non-null");
            this._boundaryRule = t2;
          }
        };
        Si.prototype.locateInternal = function() {
          if (arguments[0] instanceof C && arguments[1] instanceof $t) {
            var t2 = arguments[0], e3 = arguments[1];
            if (e3.isEmpty())
              return w.EXTERIOR;
            var n2 = e3.getExteriorRing(), i2 = this.locateInPolygonRing(t2, n2);
            if (i2 === w.EXTERIOR)
              return w.EXTERIOR;
            if (i2 === w.BOUNDARY)
              return w.BOUNDARY;
            for (var r2 = 0; r2 < e3.getNumInteriorRing(); r2++) {
              var o2 = e3.getInteriorRingN(r2), s2 = this.locateInPolygonRing(t2, o2);
              if (s2 === w.INTERIOR)
                return w.EXTERIOR;
              if (s2 === w.BOUNDARY)
                return w.BOUNDARY;
            }
            return w.INTERIOR;
          }
          if (arguments[0] instanceof C && arguments[1] instanceof Kt) {
            var a2 = arguments[0], u2 = arguments[1];
            if (!u2.getEnvelopeInternal().intersects(a2))
              return w.EXTERIOR;
            var l2 = u2.getCoordinates();
            return u2.isClosed() || !a2.equals(l2[0]) && !a2.equals(l2[l2.length - 1]) ? at.isOnLine(a2, l2) ? w.INTERIOR : w.EXTERIOR : w.BOUNDARY;
          }
          if (arguments[0] instanceof C && arguments[1] instanceof Qt) {
            var c2 = arguments[0];
            return arguments[1].getCoordinate().equals2D(c2) ? w.INTERIOR : w.EXTERIOR;
          }
        }, Si.prototype.locateInPolygonRing = function(t2, e3) {
          return e3.getEnvelopeInternal().intersects(t2) ? at.locatePointInRing(t2, e3.getCoordinates()) : w.EXTERIOR;
        }, Si.prototype.intersects = function(t2, e3) {
          return this.locate(t2, e3) !== w.EXTERIOR;
        }, Si.prototype.updateLocationInfo = function(t2) {
          t2 === w.INTERIOR && (this._isIn = true), t2 === w.BOUNDARY && this._numBoundaries++;
        }, Si.prototype.computeLocation = function(t2, e3) {
          if (e3 instanceof Qt && this.updateLocationInfo(this.locateInternal(t2, e3)), e3 instanceof Kt)
            this.updateLocationInfo(this.locateInternal(t2, e3));
          else if (e3 instanceof $t)
            this.updateLocationInfo(this.locateInternal(t2, e3));
          else if (e3 instanceof Xt)
            for (var n2 = e3, i2 = 0; i2 < n2.getNumGeometries(); i2++) {
              var r2 = n2.getGeometryN(i2);
              this.updateLocationInfo(this.locateInternal(t2, r2));
            }
          else if (e3 instanceof ne)
            for (var o2 = e3, s2 = 0; s2 < o2.getNumGeometries(); s2++) {
              var a2 = o2.getGeometryN(s2);
              this.updateLocationInfo(this.locateInternal(t2, a2));
            }
          else if (e3 instanceof zt)
            for (var u2 = new Un(e3); u2.hasNext(); ) {
              var l2 = u2.next();
              l2 !== e3 && this.computeLocation(t2, l2);
            }
        }, Si.prototype.locate = function(t2, e3) {
          return e3.isEmpty() ? w.EXTERIOR : e3 instanceof Kt ? this.locateInternal(t2, e3) : e3 instanceof $t ? this.locateInternal(t2, e3) : (this._isIn = false, this._numBoundaries = 0, this.computeLocation(t2, e3), this._boundaryRule.isInBoundary(this._numBoundaries) ? w.BOUNDARY : this._numBoundaries > 0 || this._isIn ? w.INTERIOR : w.EXTERIOR);
        }, Si.prototype.interfaces_ = function() {
          return [];
        }, Si.prototype.getClass = function() {
          return Si;
        };
        var Li = function t2() {
          if (this._component = null, this._segIndex = null, this._pt = null, 2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            t2.call(this, e3, t2.INSIDE_AREA, n2);
          } else if (3 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2];
            this._component = i2, this._segIndex = r2, this._pt = o2;
          }
        }, bi = { INSIDE_AREA: { configurable: true } };
        Li.prototype.isInsideArea = function() {
          return this._segIndex === Li.INSIDE_AREA;
        }, Li.prototype.getCoordinate = function() {
          return this._pt;
        }, Li.prototype.getGeometryComponent = function() {
          return this._component;
        }, Li.prototype.getSegmentIndex = function() {
          return this._segIndex;
        }, Li.prototype.interfaces_ = function() {
          return [];
        }, Li.prototype.getClass = function() {
          return Li;
        }, bi.INSIDE_AREA.get = function() {
          return -1;
        }, Object.defineProperties(Li, bi);
        var wi = function(t2) {
          this._pts = t2 || null;
        };
        wi.prototype.filter = function(t2) {
          t2 instanceof Qt && this._pts.add(t2);
        }, wi.prototype.interfaces_ = function() {
          return [Vt];
        }, wi.prototype.getClass = function() {
          return wi;
        }, wi.getPoints = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return t2 instanceof Qt ? $e.singletonList(t2) : wi.getPoints(t2, new Nt());
          }
          if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            return e3 instanceof Qt ? n2.add(e3) : e3 instanceof zt && e3.apply(new wi(n2)), n2;
          }
        };
        var Oi = function() {
          this._locations = null;
          var t2 = arguments[0];
          this._locations = t2;
        };
        Oi.prototype.filter = function(t2) {
          (t2 instanceof Qt || t2 instanceof Kt || t2 instanceof $t) && this._locations.add(new Li(t2, 0, t2.getCoordinate()));
        }, Oi.prototype.interfaces_ = function() {
          return [Vt];
        }, Oi.prototype.getClass = function() {
          return Oi;
        }, Oi.getLocations = function(t2) {
          var e3 = new Nt();
          return t2.apply(new Oi(e3)), e3;
        };
        var Ti = function() {
          if (this._geom = null, this._terminateDistance = 0, this._ptLocator = new Si(), this._minDistanceLocation = null, this._minDistance = v.MAX_VALUE, 2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            this._geom = [t2, e3], this._terminateDistance = 0;
          } else if (3 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2];
            this._geom = new Array(2).fill(null), this._geom[0] = n2, this._geom[1] = i2, this._terminateDistance = r2;
          }
        };
        Ti.prototype.computeContainmentDistance = function() {
          if (0 === arguments.length) {
            var t2 = new Array(2).fill(null);
            if (this.computeContainmentDistance(0, t2), this._minDistance <= this._terminateDistance)
              return null;
            this.computeContainmentDistance(1, t2);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1], i2 = 1 - e3, r2 = Ni.getPolygons(this._geom[e3]);
            if (r2.size() > 0) {
              var o2 = Oi.getLocations(this._geom[i2]);
              if (this.computeContainmentDistance(o2, r2, n2), this._minDistance <= this._terminateDistance)
                return this._minDistanceLocation[i2] = n2[0], this._minDistanceLocation[e3] = n2[1], null;
            }
          } else if (3 === arguments.length) {
            if (arguments[2] instanceof Array && T(arguments[0], xt) && T(arguments[1], xt)) {
              for (var s2 = arguments[0], a2 = arguments[1], u2 = arguments[2], l2 = 0; l2 < s2.size(); l2++)
                for (var c2 = s2.get(l2), p2 = 0; p2 < a2.size(); p2++)
                  if (this.computeContainmentDistance(c2, a2.get(p2), u2), this._minDistance <= this._terminateDistance)
                    return null;
            } else if (arguments[2] instanceof Array && arguments[0] instanceof Li && arguments[1] instanceof $t) {
              var h2 = arguments[0], f2 = arguments[1], g2 = arguments[2], d2 = h2.getCoordinate();
              if (w.EXTERIOR !== this._ptLocator.locate(d2, f2))
                return this._minDistance = 0, g2[0] = h2, g2[1] = new Li(f2, d2), null;
            }
          }
        }, Ti.prototype.computeMinDistanceLinesPoints = function(t2, e3, n2) {
          for (var i2 = 0; i2 < t2.size(); i2++)
            for (var r2 = t2.get(i2), o2 = 0; o2 < e3.size(); o2++) {
              var s2 = e3.get(o2);
              if (this.computeMinDistance(r2, s2, n2), this._minDistance <= this._terminateDistance)
                return null;
            }
        }, Ti.prototype.computeFacetDistance = function() {
          var t2 = new Array(2).fill(null), e3 = Ci.getLines(this._geom[0]), n2 = Ci.getLines(this._geom[1]), i2 = wi.getPoints(this._geom[0]), r2 = wi.getPoints(this._geom[1]);
          return this.computeMinDistanceLines(e3, n2, t2), this.updateMinDistance(t2, false), this._minDistance <= this._terminateDistance ? null : (t2[0] = null, t2[1] = null, this.computeMinDistanceLinesPoints(e3, r2, t2), this.updateMinDistance(t2, false), this._minDistance <= this._terminateDistance ? null : (t2[0] = null, t2[1] = null, this.computeMinDistanceLinesPoints(n2, i2, t2), this.updateMinDistance(t2, true), this._minDistance <= this._terminateDistance ? null : (t2[0] = null, t2[1] = null, this.computeMinDistancePoints(i2, r2, t2), void this.updateMinDistance(t2, false))));
        }, Ti.prototype.nearestLocations = function() {
          return this.computeMinDistance(), this._minDistanceLocation;
        }, Ti.prototype.updateMinDistance = function(t2, e3) {
          if (null === t2[0])
            return null;
          e3 ? (this._minDistanceLocation[0] = t2[1], this._minDistanceLocation[1] = t2[0]) : (this._minDistanceLocation[0] = t2[0], this._minDistanceLocation[1] = t2[1]);
        }, Ti.prototype.nearestPoints = function() {
          this.computeMinDistance();
          return [this._minDistanceLocation[0].getCoordinate(), this._minDistanceLocation[1].getCoordinate()];
        }, Ti.prototype.computeMinDistance = function() {
          if (0 === arguments.length) {
            if (null !== this._minDistanceLocation)
              return null;
            if (this._minDistanceLocation = new Array(2).fill(null), this.computeContainmentDistance(), this._minDistance <= this._terminateDistance)
              return null;
            this.computeFacetDistance();
          } else if (3 === arguments.length) {
            if (arguments[2] instanceof Array && arguments[0] instanceof Kt && arguments[1] instanceof Qt) {
              var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
              if (t2.getEnvelopeInternal().distance(e3.getEnvelopeInternal()) > this._minDistance)
                return null;
              for (var i2 = t2.getCoordinates(), r2 = e3.getCoordinate(), o2 = 0; o2 < i2.length - 1; o2++) {
                var s2 = at.distancePointLine(r2, i2[o2], i2[o2 + 1]);
                if (s2 < this._minDistance) {
                  this._minDistance = s2;
                  var a2 = new dn(i2[o2], i2[o2 + 1]).closestPoint(r2);
                  n2[0] = new Li(t2, o2, a2), n2[1] = new Li(e3, 0, r2);
                }
                if (this._minDistance <= this._terminateDistance)
                  return null;
              }
            } else if (arguments[2] instanceof Array && arguments[0] instanceof Kt && arguments[1] instanceof Kt) {
              var u2 = arguments[0], l2 = arguments[1], c2 = arguments[2];
              if (u2.getEnvelopeInternal().distance(l2.getEnvelopeInternal()) > this._minDistance)
                return null;
              for (var p2 = u2.getCoordinates(), h2 = l2.getCoordinates(), f2 = 0; f2 < p2.length - 1; f2++)
                for (var g2 = 0; g2 < h2.length - 1; g2++) {
                  var d2 = at.distanceLineLine(p2[f2], p2[f2 + 1], h2[g2], h2[g2 + 1]);
                  if (d2 < this._minDistance) {
                    this._minDistance = d2;
                    var y3 = new dn(p2[f2], p2[f2 + 1]), _2 = new dn(h2[g2], h2[g2 + 1]), m2 = y3.closestPoints(_2);
                    c2[0] = new Li(u2, f2, m2[0]), c2[1] = new Li(l2, g2, m2[1]);
                  }
                  if (this._minDistance <= this._terminateDistance)
                    return null;
                }
            }
          }
        }, Ti.prototype.computeMinDistancePoints = function(t2, e3, n2) {
          for (var i2 = 0; i2 < t2.size(); i2++)
            for (var r2 = t2.get(i2), o2 = 0; o2 < e3.size(); o2++) {
              var s2 = e3.get(o2), a2 = r2.getCoordinate().distance(s2.getCoordinate());
              if (a2 < this._minDistance && (this._minDistance = a2, n2[0] = new Li(r2, 0, r2.getCoordinate()), n2[1] = new Li(s2, 0, s2.getCoordinate())), this._minDistance <= this._terminateDistance)
                return null;
            }
        }, Ti.prototype.distance = function() {
          if (null === this._geom[0] || null === this._geom[1])
            throw new m("null geometries are not supported");
          return this._geom[0].isEmpty() || this._geom[1].isEmpty() ? 0 : (this.computeMinDistance(), this._minDistance);
        }, Ti.prototype.computeMinDistanceLines = function(t2, e3, n2) {
          for (var i2 = 0; i2 < t2.size(); i2++)
            for (var r2 = t2.get(i2), o2 = 0; o2 < e3.size(); o2++) {
              var s2 = e3.get(o2);
              if (this.computeMinDistance(r2, s2, n2), this._minDistance <= this._terminateDistance)
                return null;
            }
        }, Ti.prototype.interfaces_ = function() {
          return [];
        }, Ti.prototype.getClass = function() {
          return Ti;
        }, Ti.distance = function(t2, e3) {
          return new Ti(t2, e3).distance();
        }, Ti.isWithinDistance = function(t2, e3, n2) {
          return new Ti(t2, e3, n2).distance() <= n2;
        }, Ti.nearestPoints = function(t2, e3) {
          return new Ti(t2, e3).nearestPoints();
        };
        var Ri = function() {
          this._pt = [new C(), new C()], this._distance = v.NaN, this._isNull = true;
        };
        Ri.prototype.getCoordinates = function() {
          return this._pt;
        }, Ri.prototype.getCoordinate = function(t2) {
          return this._pt[t2];
        }, Ri.prototype.setMinimum = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.setMinimum(t2._pt[0], t2._pt[1]);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            if (this._isNull)
              return this.initialize(e3, n2), null;
            var i2 = e3.distance(n2);
            i2 < this._distance && this.initialize(e3, n2, i2);
          }
        }, Ri.prototype.initialize = function() {
          if (0 === arguments.length)
            this._isNull = true;
          else if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            this._pt[0].setCoordinate(t2), this._pt[1].setCoordinate(e3), this._distance = t2.distance(e3), this._isNull = false;
          } else if (3 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2];
            this._pt[0].setCoordinate(n2), this._pt[1].setCoordinate(i2), this._distance = r2, this._isNull = false;
          }
        }, Ri.prototype.toString = function() {
          return Z.toLineString(this._pt[0], this._pt[1]);
        }, Ri.prototype.getDistance = function() {
          return this._distance;
        }, Ri.prototype.setMaximum = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.setMaximum(t2._pt[0], t2._pt[1]);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            if (this._isNull)
              return this.initialize(e3, n2), null;
            var i2 = e3.distance(n2);
            i2 > this._distance && this.initialize(e3, n2, i2);
          }
        }, Ri.prototype.interfaces_ = function() {
          return [];
        }, Ri.prototype.getClass = function() {
          return Ri;
        };
        var Pi = function() {
        };
        Pi.prototype.interfaces_ = function() {
          return [];
        }, Pi.prototype.getClass = function() {
          return Pi;
        }, Pi.computeDistance = function() {
          if (arguments[2] instanceof Ri && arguments[0] instanceof Kt && arguments[1] instanceof C)
            for (var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2], i2 = new dn(), r2 = t2.getCoordinates(), o2 = 0; o2 < r2.length - 1; o2++) {
              i2.setCoordinates(r2[o2], r2[o2 + 1]);
              var s2 = i2.closestPoint(e3);
              n2.setMinimum(s2, e3);
            }
          else if (arguments[2] instanceof Ri && arguments[0] instanceof $t && arguments[1] instanceof C) {
            var a2 = arguments[0], u2 = arguments[1], l2 = arguments[2];
            Pi.computeDistance(a2.getExteriorRing(), u2, l2);
            for (var c2 = 0; c2 < a2.getNumInteriorRing(); c2++)
              Pi.computeDistance(a2.getInteriorRingN(c2), u2, l2);
          } else if (arguments[2] instanceof Ri && arguments[0] instanceof ct && arguments[1] instanceof C) {
            var p2 = arguments[0], h2 = arguments[1], f2 = arguments[2];
            if (p2 instanceof Kt)
              Pi.computeDistance(p2, h2, f2);
            else if (p2 instanceof $t)
              Pi.computeDistance(p2, h2, f2);
            else if (p2 instanceof zt)
              for (var g2 = p2, d2 = 0; d2 < g2.getNumGeometries(); d2++) {
                var y3 = g2.getGeometryN(d2);
                Pi.computeDistance(y3, h2, f2);
              }
            else
              f2.setMinimum(p2.getCoordinate(), h2);
          } else if (arguments[2] instanceof Ri && arguments[0] instanceof dn && arguments[1] instanceof C) {
            var _2 = arguments[0], m2 = arguments[1], v2 = arguments[2], I2 = _2.closestPoint(m2);
            v2.setMinimum(I2, m2);
          }
        };
        var Di = function() {
          this._g0 = null, this._g1 = null, this._ptDist = new Ri(), this._densifyFrac = 0;
          var t2 = arguments[0], e3 = arguments[1];
          this._g0 = t2, this._g1 = e3;
        }, Mi = { MaxPointDistanceFilter: { configurable: true }, MaxDensifiedByFractionDistanceFilter: { configurable: true } };
        Di.prototype.getCoordinates = function() {
          return this._ptDist.getCoordinates();
        }, Di.prototype.setDensifyFraction = function(t2) {
          if (t2 > 1 || t2 <= 0)
            throw new m("Fraction is not in range (0.0 - 1.0]");
          this._densifyFrac = t2;
        }, Di.prototype.compute = function(t2, e3) {
          this.computeOrientedDistance(t2, e3, this._ptDist), this.computeOrientedDistance(e3, t2, this._ptDist);
        }, Di.prototype.distance = function() {
          return this.compute(this._g0, this._g1), this._ptDist.getDistance();
        }, Di.prototype.computeOrientedDistance = function(t2, e3, n2) {
          var i2 = new Ai(e3);
          if (t2.apply(i2), n2.setMaximum(i2.getMaxPointDistance()), this._densifyFrac > 0) {
            var r2 = new Fi(e3, this._densifyFrac);
            t2.apply(r2), n2.setMaximum(r2.getMaxPointDistance());
          }
        }, Di.prototype.orientedDistance = function() {
          return this.computeOrientedDistance(this._g0, this._g1, this._ptDist), this._ptDist.getDistance();
        }, Di.prototype.interfaces_ = function() {
          return [];
        }, Di.prototype.getClass = function() {
          return Di;
        }, Di.distance = function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            return new Di(t2, e3).distance();
          }
          if (3 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2], o2 = new Di(n2, i2);
            return o2.setDensifyFraction(r2), o2.distance();
          }
        }, Mi.MaxPointDistanceFilter.get = function() {
          return Ai;
        }, Mi.MaxDensifiedByFractionDistanceFilter.get = function() {
          return Fi;
        }, Object.defineProperties(Di, Mi);
        var Ai = function() {
          this._maxPtDist = new Ri(), this._minPtDist = new Ri(), this._euclideanDist = new Pi(), this._geom = null;
          var t2 = arguments[0];
          this._geom = t2;
        };
        Ai.prototype.filter = function(t2) {
          this._minPtDist.initialize(), Pi.computeDistance(this._geom, t2, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);
        }, Ai.prototype.getMaxPointDistance = function() {
          return this._maxPtDist;
        }, Ai.prototype.interfaces_ = function() {
          return [ft];
        }, Ai.prototype.getClass = function() {
          return Ai;
        };
        var Fi = function() {
          this._maxPtDist = new Ri(), this._minPtDist = new Ri(), this._geom = null, this._numSubSegs = 0;
          var t2 = arguments[0], e3 = arguments[1];
          this._geom = t2, this._numSubSegs = Math.trunc(Math.round(1 / e3));
        };
        Fi.prototype.filter = function(t2, e3) {
          if (0 === e3)
            return null;
          for (var n2 = t2.getCoordinate(e3 - 1), i2 = t2.getCoordinate(e3), r2 = (i2.x - n2.x) / this._numSubSegs, o2 = (i2.y - n2.y) / this._numSubSegs, s2 = 0; s2 < this._numSubSegs; s2++) {
            var a2 = n2.x + s2 * r2, u2 = n2.y + s2 * o2, l2 = new C(a2, u2);
            this._minPtDist.initialize(), Pi.computeDistance(this._geom, l2, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);
          }
        }, Fi.prototype.isDone = function() {
          return false;
        }, Fi.prototype.isGeometryChanged = function() {
          return false;
        }, Fi.prototype.getMaxPointDistance = function() {
          return this._maxPtDist;
        }, Fi.prototype.interfaces_ = function() {
          return [Ut];
        }, Fi.prototype.getClass = function() {
          return Fi;
        };
        var Gi = function(t2, e3, n2) {
          this._minValidDistance = null, this._maxValidDistance = null, this._minDistanceFound = null, this._maxDistanceFound = null, this._isValid = true, this._errMsg = null, this._errorLocation = null, this._errorIndicator = null, this._input = t2 || null, this._bufDistance = e3 || null, this._result = n2 || null;
        }, qi = { VERBOSE: { configurable: true }, MAX_DISTANCE_DIFF_FRAC: { configurable: true } };
        Gi.prototype.checkMaximumDistance = function(t2, e3, n2) {
          var i2 = new Di(e3, t2);
          if (i2.setDensifyFraction(0.25), this._maxDistanceFound = i2.orientedDistance(), this._maxDistanceFound > n2) {
            this._isValid = false;
            var r2 = i2.getCoordinates();
            this._errorLocation = r2[1], this._errorIndicator = t2.getFactory().createLineString(r2), this._errMsg = "Distance between buffer curve and input is too large (" + this._maxDistanceFound + " at " + Z.toLineString(r2[0], r2[1]) + ")";
          }
        }, Gi.prototype.isValid = function() {
          var t2 = Math.abs(this._bufDistance), e3 = Gi.MAX_DISTANCE_DIFF_FRAC * t2;
          return this._minValidDistance = t2 - e3, this._maxValidDistance = t2 + e3, !(!this._input.isEmpty() && !this._result.isEmpty()) || (this._bufDistance > 0 ? this.checkPositiveValid() : this.checkNegativeValid(), Gi.VERBOSE && Y.out.println("Min Dist= " + this._minDistanceFound + "  err= " + (1 - this._minDistanceFound / this._bufDistance) + "  Max Dist= " + this._maxDistanceFound + "  err= " + (this._maxDistanceFound / this._bufDistance - 1)), this._isValid);
        }, Gi.prototype.checkNegativeValid = function() {
          if (!(this._input instanceof $t || this._input instanceof ne || this._input instanceof zt))
            return null;
          var t2 = this.getPolygonLines(this._input);
          if (this.checkMinimumDistance(t2, this._result, this._minValidDistance), !this._isValid)
            return null;
          this.checkMaximumDistance(t2, this._result, this._maxValidDistance);
        }, Gi.prototype.getErrorIndicator = function() {
          return this._errorIndicator;
        }, Gi.prototype.checkMinimumDistance = function(t2, e3, n2) {
          var i2 = new Ti(t2, e3, n2);
          if (this._minDistanceFound = i2.distance(), this._minDistanceFound < n2) {
            this._isValid = false;
            var r2 = i2.nearestPoints();
            this._errorLocation = i2.nearestPoints()[1], this._errorIndicator = t2.getFactory().createLineString(r2), this._errMsg = "Distance between buffer curve and input is too small (" + this._minDistanceFound + " at " + Z.toLineString(r2[0], r2[1]) + " )";
          }
        }, Gi.prototype.checkPositiveValid = function() {
          var t2 = this._result.getBoundary();
          if (this.checkMinimumDistance(this._input, t2, this._minValidDistance), !this._isValid)
            return null;
          this.checkMaximumDistance(this._input, t2, this._maxValidDistance);
        }, Gi.prototype.getErrorLocation = function() {
          return this._errorLocation;
        }, Gi.prototype.getPolygonLines = function(t2) {
          for (var e3 = new Nt(), n2 = new Ci(e3), i2 = Ni.getPolygons(t2).iterator(); i2.hasNext(); ) {
            i2.next().apply(n2);
          }
          return t2.getFactory().buildGeometry(e3);
        }, Gi.prototype.getErrorMessage = function() {
          return this._errMsg;
        }, Gi.prototype.interfaces_ = function() {
          return [];
        }, Gi.prototype.getClass = function() {
          return Gi;
        }, qi.VERBOSE.get = function() {
          return false;
        }, qi.MAX_DISTANCE_DIFF_FRAC.get = function() {
          return 0.012;
        }, Object.defineProperties(Gi, qi);
        var Bi = function(t2, e3, n2) {
          this._isValid = true, this._errorMsg = null, this._errorLocation = null, this._errorIndicator = null, this._input = t2 || null, this._distance = e3 || null, this._result = n2 || null;
        }, Vi = { VERBOSE: { configurable: true }, MAX_ENV_DIFF_FRAC: { configurable: true } };
        Bi.prototype.isValid = function() {
          return this.checkPolygonal(), this._isValid ? (this.checkExpectedEmpty(), this._isValid ? (this.checkEnvelope(), this._isValid ? (this.checkArea(), this._isValid ? (this.checkDistance(), this._isValid) : this._isValid) : this._isValid) : this._isValid) : this._isValid;
        }, Bi.prototype.checkEnvelope = function() {
          if (this._distance < 0)
            return null;
          var t2 = this._distance * Bi.MAX_ENV_DIFF_FRAC;
          0 === t2 && (t2 = 1e-3);
          var e3 = new j(this._input.getEnvelopeInternal());
          e3.expandBy(this._distance);
          var n2 = new j(this._result.getEnvelopeInternal());
          n2.expandBy(t2), n2.contains(e3) || (this._isValid = false, this._errorMsg = "Buffer envelope is incorrect", this._errorIndicator = this._input.getFactory().toGeometry(n2)), this.report("Envelope");
        }, Bi.prototype.checkDistance = function() {
          var t2 = new Gi(this._input, this._distance, this._result);
          t2.isValid() || (this._isValid = false, this._errorMsg = t2.getErrorMessage(), this._errorLocation = t2.getErrorLocation(), this._errorIndicator = t2.getErrorIndicator()), this.report("Distance");
        }, Bi.prototype.checkArea = function() {
          var t2 = this._input.getArea(), e3 = this._result.getArea();
          this._distance > 0 && t2 > e3 && (this._isValid = false, this._errorMsg = "Area of positive buffer is smaller than input", this._errorIndicator = this._result), this._distance < 0 && t2 < e3 && (this._isValid = false, this._errorMsg = "Area of negative buffer is larger than input", this._errorIndicator = this._result), this.report("Area");
        }, Bi.prototype.checkPolygonal = function() {
          this._result instanceof $t || this._result instanceof ne || (this._isValid = false), this._errorMsg = "Result is not polygonal", this._errorIndicator = this._result, this.report("Polygonal");
        }, Bi.prototype.getErrorIndicator = function() {
          return this._errorIndicator;
        }, Bi.prototype.getErrorLocation = function() {
          return this._errorLocation;
        }, Bi.prototype.checkExpectedEmpty = function() {
          return this._input.getDimension() >= 2 ? null : this._distance > 0 ? null : (this._result.isEmpty() || (this._isValid = false, this._errorMsg = "Result is non-empty", this._errorIndicator = this._result), void this.report("ExpectedEmpty"));
        }, Bi.prototype.report = function(t2) {
          if (!Bi.VERBOSE)
            return null;
          Y.out.println("Check " + t2 + ": " + (this._isValid ? "passed" : "FAILED"));
        }, Bi.prototype.getErrorMessage = function() {
          return this._errorMsg;
        }, Bi.prototype.interfaces_ = function() {
          return [];
        }, Bi.prototype.getClass = function() {
          return Bi;
        }, Bi.isValidMsg = function(t2, e3, n2) {
          var i2 = new Bi(t2, e3, n2);
          return i2.isValid() ? null : i2.getErrorMessage();
        }, Bi.isValid = function(t2, e3, n2) {
          return !!new Bi(t2, e3, n2).isValid();
        }, Vi.VERBOSE.get = function() {
          return false;
        }, Vi.MAX_ENV_DIFF_FRAC.get = function() {
          return 0.012;
        }, Object.defineProperties(Bi, Vi);
        var Ui = function() {
          this._pts = null, this._data = null;
          var t2 = arguments[0], e3 = arguments[1];
          this._pts = t2, this._data = e3;
        };
        Ui.prototype.getCoordinates = function() {
          return this._pts;
        }, Ui.prototype.size = function() {
          return this._pts.length;
        }, Ui.prototype.getCoordinate = function(t2) {
          return this._pts[t2];
        }, Ui.prototype.isClosed = function() {
          return this._pts[0].equals(this._pts[this._pts.length - 1]);
        }, Ui.prototype.getSegmentOctant = function(t2) {
          return t2 === this._pts.length - 1 ? -1 : pn.octant(this.getCoordinate(t2), this.getCoordinate(t2 + 1));
        }, Ui.prototype.setData = function(t2) {
          this._data = t2;
        }, Ui.prototype.getData = function() {
          return this._data;
        }, Ui.prototype.toString = function() {
          return Z.toLineString(new ue(this._pts));
        }, Ui.prototype.interfaces_ = function() {
          return [hn];
        }, Ui.prototype.getClass = function() {
          return Ui;
        };
        var zi = function() {
          this._findAllIntersections = false, this._isCheckEndSegmentsOnly = false, this._li = null, this._interiorIntersection = null, this._intSegments = null, this._intersections = new Nt(), this._intersectionCount = 0, this._keepIntersections = true;
          var t2 = arguments[0];
          this._li = t2, this._interiorIntersection = null;
        };
        zi.prototype.getInteriorIntersection = function() {
          return this._interiorIntersection;
        }, zi.prototype.setCheckEndSegmentsOnly = function(t2) {
          this._isCheckEndSegmentsOnly = t2;
        }, zi.prototype.getIntersectionSegments = function() {
          return this._intSegments;
        }, zi.prototype.count = function() {
          return this._intersectionCount;
        }, zi.prototype.getIntersections = function() {
          return this._intersections;
        }, zi.prototype.setFindAllIntersections = function(t2) {
          this._findAllIntersections = t2;
        }, zi.prototype.setKeepIntersections = function(t2) {
          this._keepIntersections = t2;
        }, zi.prototype.processIntersections = function(t2, e3, n2, i2) {
          if (!this._findAllIntersections && this.hasIntersection())
            return null;
          if (t2 === n2 && e3 === i2)
            return null;
          if (this._isCheckEndSegmentsOnly) {
            if (!(this.isEndSegment(t2, e3) || this.isEndSegment(n2, i2)))
              return null;
          }
          var r2 = t2.getCoordinates()[e3], o2 = t2.getCoordinates()[e3 + 1], s2 = n2.getCoordinates()[i2], a2 = n2.getCoordinates()[i2 + 1];
          this._li.computeIntersection(r2, o2, s2, a2), this._li.hasIntersection() && this._li.isInteriorIntersection() && (this._intSegments = new Array(4).fill(null), this._intSegments[0] = r2, this._intSegments[1] = o2, this._intSegments[2] = s2, this._intSegments[3] = a2, this._interiorIntersection = this._li.getIntersection(0), this._keepIntersections && this._intersections.add(this._interiorIntersection), this._intersectionCount++);
        }, zi.prototype.isEndSegment = function(t2, e3) {
          return 0 === e3 || e3 >= t2.size() - 2;
        }, zi.prototype.hasIntersection = function() {
          return null !== this._interiorIntersection;
        }, zi.prototype.isDone = function() {
          return !this._findAllIntersections && null !== this._interiorIntersection;
        }, zi.prototype.interfaces_ = function() {
          return [Wn];
        }, zi.prototype.getClass = function() {
          return zi;
        }, zi.createAllIntersectionsFinder = function(t2) {
          var e3 = new zi(t2);
          return e3.setFindAllIntersections(true), e3;
        }, zi.createAnyIntersectionFinder = function(t2) {
          return new zi(t2);
        }, zi.createIntersectionCounter = function(t2) {
          var e3 = new zi(t2);
          return e3.setFindAllIntersections(true), e3.setKeepIntersections(false), e3;
        };
        var Xi = function() {
          this._li = new rt(), this._segStrings = null, this._findAllIntersections = false, this._segInt = null, this._isValid = true;
          var t2 = arguments[0];
          this._segStrings = t2;
        };
        Xi.prototype.execute = function() {
          if (null !== this._segInt)
            return null;
          this.checkInteriorIntersections();
        }, Xi.prototype.getIntersections = function() {
          return this._segInt.getIntersections();
        }, Xi.prototype.isValid = function() {
          return this.execute(), this._isValid;
        }, Xi.prototype.setFindAllIntersections = function(t2) {
          this._findAllIntersections = t2;
        }, Xi.prototype.checkInteriorIntersections = function() {
          this._isValid = true, this._segInt = new zi(this._li), this._segInt.setFindAllIntersections(this._findAllIntersections);
          var t2 = new xn();
          if (t2.setSegmentIntersector(this._segInt), t2.computeNodes(this._segStrings), this._segInt.hasIntersection())
            return this._isValid = false, null;
        }, Xi.prototype.checkValid = function() {
          if (this.execute(), !this._isValid)
            throw new we(this.getErrorMessage(), this._segInt.getInteriorIntersection());
        }, Xi.prototype.getErrorMessage = function() {
          if (this._isValid)
            return "no intersections found";
          var t2 = this._segInt.getIntersectionSegments();
          return "found non-noded intersection between " + Z.toLineString(t2[0], t2[1]) + " and " + Z.toLineString(t2[2], t2[3]);
        }, Xi.prototype.interfaces_ = function() {
          return [];
        }, Xi.prototype.getClass = function() {
          return Xi;
        }, Xi.computeIntersections = function(t2) {
          var e3 = new Xi(t2);
          return e3.setFindAllIntersections(true), e3.isValid(), e3.getIntersections();
        };
        var Yi = function t2() {
          this._nv = null;
          var e3 = arguments[0];
          this._nv = new Xi(t2.toSegmentStrings(e3));
        };
        Yi.prototype.checkValid = function() {
          this._nv.checkValid();
        }, Yi.prototype.interfaces_ = function() {
          return [];
        }, Yi.prototype.getClass = function() {
          return Yi;
        }, Yi.toSegmentStrings = function(t2) {
          for (var e3 = new Nt(), n2 = t2.iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            e3.add(new Ui(i2.getCoordinates(), i2));
          }
          return e3;
        }, Yi.checkValid = function(t2) {
          new Yi(t2).checkValid();
        };
        var ki = function(t2) {
          this._mapOp = t2;
        };
        ki.prototype.map = function(t2) {
          for (var e3 = new Nt(), n2 = 0; n2 < t2.getNumGeometries(); n2++) {
            var i2 = this._mapOp.map(t2.getGeometryN(n2));
            i2.isEmpty() || e3.add(i2);
          }
          return t2.getFactory().createGeometryCollection(_e.toGeometryArray(e3));
        }, ki.prototype.interfaces_ = function() {
          return [];
        }, ki.prototype.getClass = function() {
          return ki;
        }, ki.map = function(t2, e3) {
          return new ki(e3).map(t2);
        };
        var ji = function() {
          this._op = null, this._geometryFactory = null, this._ptLocator = null, this._lineEdgesList = new Nt(), this._resultLineList = new Nt();
          var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
          this._op = t2, this._geometryFactory = e3, this._ptLocator = n2;
        };
        ji.prototype.collectLines = function(t2) {
          for (var e3 = this._op.getGraph().getEdgeEnds().iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            this.collectLineEdge(n2, t2, this._lineEdgesList), this.collectBoundaryTouchEdge(n2, t2, this._lineEdgesList);
          }
        }, ji.prototype.labelIsolatedLine = function(t2, e3) {
          var n2 = this._ptLocator.locate(t2.getCoordinate(), this._op.getArgGeometry(e3));
          t2.getLabel().setLocation(e3, n2);
        }, ji.prototype.build = function(t2) {
          return this.findCoveredLineEdges(), this.collectLines(t2), this.buildLines(t2), this._resultLineList;
        }, ji.prototype.collectLineEdge = function(t2, e3, n2) {
          var i2 = t2.getLabel(), r2 = t2.getEdge();
          t2.isLineEdge() && (t2.isVisited() || !Lr.isResultOfOp(i2, e3) || r2.isCovered() || (n2.add(r2), t2.setVisitedEdge(true)));
        }, ji.prototype.findCoveredLineEdges = function() {
          for (var t2 = this._op.getGraph().getNodes().iterator(); t2.hasNext(); ) {
            t2.next().getEdges().findCoveredLineEdges();
          }
          for (var e3 = this._op.getGraph().getEdgeEnds().iterator(); e3.hasNext(); ) {
            var n2 = e3.next(), i2 = n2.getEdge();
            if (n2.isLineEdge() && !i2.isCoveredSet()) {
              var r2 = this._op.isCoveredByA(n2.getCoordinate());
              i2.setCovered(r2);
            }
          }
        }, ji.prototype.labelIsolatedLines = function(t2) {
          for (var e3 = t2.iterator(); e3.hasNext(); ) {
            var n2 = e3.next(), i2 = n2.getLabel();
            n2.isIsolated() && (i2.isNull(0) ? this.labelIsolatedLine(n2, 0) : this.labelIsolatedLine(n2, 1));
          }
        }, ji.prototype.buildLines = function(t2) {
          for (var e3 = this._lineEdgesList.iterator(); e3.hasNext(); ) {
            var n2 = e3.next(), i2 = this._geometryFactory.createLineString(n2.getCoordinates());
            this._resultLineList.add(i2), n2.setInResult(true);
          }
        }, ji.prototype.collectBoundaryTouchEdge = function(t2, e3, n2) {
          var i2 = t2.getLabel();
          return t2.isLineEdge() ? null : t2.isVisited() ? null : t2.isInteriorAreaEdge() ? null : t2.getEdge().isInResult() ? null : (et.isTrue(!(t2.isInResult() || t2.getSym().isInResult()) || !t2.getEdge().isInResult()), void (Lr.isResultOfOp(i2, e3) && e3 === Lr.INTERSECTION && (n2.add(t2.getEdge()), t2.setVisitedEdge(true))));
        }, ji.prototype.interfaces_ = function() {
          return [];
        }, ji.prototype.getClass = function() {
          return ji;
        };
        var Hi = function() {
          this._op = null, this._geometryFactory = null, this._resultPointList = new Nt();
          var t2 = arguments[0], e3 = arguments[1];
          this._op = t2, this._geometryFactory = e3;
        };
        Hi.prototype.filterCoveredNodeToPoint = function(t2) {
          var e3 = t2.getCoordinate();
          if (!this._op.isCoveredByLA(e3)) {
            var n2 = this._geometryFactory.createPoint(e3);
            this._resultPointList.add(n2);
          }
        }, Hi.prototype.extractNonCoveredResultNodes = function(t2) {
          for (var e3 = this._op.getGraph().getNodes().iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            if (!n2.isInResult() && (!n2.isIncidentEdgeInResult() && (0 === n2.getEdges().getDegree() || t2 === Lr.INTERSECTION))) {
              var i2 = n2.getLabel();
              Lr.isResultOfOp(i2, t2) && this.filterCoveredNodeToPoint(n2);
            }
          }
        }, Hi.prototype.build = function(t2) {
          return this.extractNonCoveredResultNodes(t2), this._resultPointList;
        }, Hi.prototype.interfaces_ = function() {
          return [];
        }, Hi.prototype.getClass = function() {
          return Hi;
        };
        var Wi = function() {
          this._inputGeom = null, this._factory = null, this._pruneEmptyGeometry = true, this._preserveGeometryCollectionType = true, this._preserveCollections = false, this._preserveType = false;
        };
        Wi.prototype.transformPoint = function(t2, e3) {
          return this._factory.createPoint(this.transformCoordinates(t2.getCoordinateSequence(), t2));
        }, Wi.prototype.transformPolygon = function(t2, e3) {
          var n2 = true, i2 = this.transformLinearRing(t2.getExteriorRing(), t2);
          null !== i2 && i2 instanceof ee && !i2.isEmpty() || (n2 = false);
          for (var r2 = new Nt(), o2 = 0; o2 < t2.getNumInteriorRing(); o2++) {
            var s2 = this.transformLinearRing(t2.getInteriorRingN(o2), t2);
            null === s2 || s2.isEmpty() || (s2 instanceof ee || (n2 = false), r2.add(s2));
          }
          if (n2)
            return this._factory.createPolygon(i2, r2.toArray([]));
          var a2 = new Nt();
          return null !== i2 && a2.add(i2), a2.addAll(r2), this._factory.buildGeometry(a2);
        }, Wi.prototype.createCoordinateSequence = function(t2) {
          return this._factory.getCoordinateSequenceFactory().create(t2);
        }, Wi.prototype.getInputGeometry = function() {
          return this._inputGeom;
        }, Wi.prototype.transformMultiLineString = function(t2, e3) {
          for (var n2 = new Nt(), i2 = 0; i2 < t2.getNumGeometries(); i2++) {
            var r2 = this.transformLineString(t2.getGeometryN(i2), t2);
            null !== r2 && (r2.isEmpty() || n2.add(r2));
          }
          return this._factory.buildGeometry(n2);
        }, Wi.prototype.transformCoordinates = function(t2, e3) {
          return this.copy(t2);
        }, Wi.prototype.transformLineString = function(t2, e3) {
          return this._factory.createLineString(this.transformCoordinates(t2.getCoordinateSequence(), t2));
        }, Wi.prototype.transformMultiPoint = function(t2, e3) {
          for (var n2 = new Nt(), i2 = 0; i2 < t2.getNumGeometries(); i2++) {
            var r2 = this.transformPoint(t2.getGeometryN(i2), t2);
            null !== r2 && (r2.isEmpty() || n2.add(r2));
          }
          return this._factory.buildGeometry(n2);
        }, Wi.prototype.transformMultiPolygon = function(t2, e3) {
          for (var n2 = new Nt(), i2 = 0; i2 < t2.getNumGeometries(); i2++) {
            var r2 = this.transformPolygon(t2.getGeometryN(i2), t2);
            null !== r2 && (r2.isEmpty() || n2.add(r2));
          }
          return this._factory.buildGeometry(n2);
        }, Wi.prototype.copy = function(t2) {
          return t2.copy();
        }, Wi.prototype.transformGeometryCollection = function(t2, e3) {
          for (var n2 = new Nt(), i2 = 0; i2 < t2.getNumGeometries(); i2++) {
            var r2 = this.transform(t2.getGeometryN(i2));
            null !== r2 && (this._pruneEmptyGeometry && r2.isEmpty() || n2.add(r2));
          }
          return this._preserveGeometryCollectionType ? this._factory.createGeometryCollection(_e.toGeometryArray(n2)) : this._factory.buildGeometry(n2);
        }, Wi.prototype.transform = function(t2) {
          if (this._inputGeom = t2, this._factory = t2.getFactory(), t2 instanceof Qt)
            return this.transformPoint(t2, null);
          if (t2 instanceof te)
            return this.transformMultiPoint(t2, null);
          if (t2 instanceof ee)
            return this.transformLinearRing(t2, null);
          if (t2 instanceof Kt)
            return this.transformLineString(t2, null);
          if (t2 instanceof Xt)
            return this.transformMultiLineString(t2, null);
          if (t2 instanceof $t)
            return this.transformPolygon(t2, null);
          if (t2 instanceof ne)
            return this.transformMultiPolygon(t2, null);
          if (t2 instanceof zt)
            return this.transformGeometryCollection(t2, null);
          throw new m("Unknown Geometry subtype: " + t2.getClass().getName());
        }, Wi.prototype.transformLinearRing = function(t2, e3) {
          var n2 = this.transformCoordinates(t2.getCoordinateSequence(), t2);
          if (null === n2)
            return this._factory.createLinearRing(null);
          var i2 = n2.size();
          return i2 > 0 && i2 < 4 && !this._preserveType ? this._factory.createLineString(n2) : this._factory.createLinearRing(n2);
        }, Wi.prototype.interfaces_ = function() {
          return [];
        }, Wi.prototype.getClass = function() {
          return Wi;
        };
        var Ki = function t2() {
          if (this._snapTolerance = 0, this._srcPts = null, this._seg = new dn(), this._allowSnappingToSourceVertices = false, this._isClosed = false, arguments[0] instanceof Kt && "number" == typeof arguments[1]) {
            var e3 = arguments[0], n2 = arguments[1];
            t2.call(this, e3.getCoordinates(), n2);
          } else if (arguments[0] instanceof Array && "number" == typeof arguments[1]) {
            var i2 = arguments[0], r2 = arguments[1];
            this._srcPts = i2, this._isClosed = t2.isClosed(i2), this._snapTolerance = r2;
          }
        };
        Ki.prototype.snapVertices = function(t2, e3) {
          for (var n2 = this._isClosed ? t2.size() - 1 : t2.size(), i2 = 0; i2 < n2; i2++) {
            var r2 = t2.get(i2), o2 = this.findSnapForVertex(r2, e3);
            null !== o2 && (t2.set(i2, new C(o2)), 0 === i2 && this._isClosed && t2.set(t2.size() - 1, new C(o2)));
          }
        }, Ki.prototype.findSnapForVertex = function(t2, e3) {
          for (var n2 = 0; n2 < e3.length; n2++) {
            if (t2.equals2D(e3[n2]))
              return null;
            if (t2.distance(e3[n2]) < this._snapTolerance)
              return e3[n2];
          }
          return null;
        }, Ki.prototype.snapTo = function(t2) {
          var e3 = new St(this._srcPts);
          this.snapVertices(e3, t2), this.snapSegments(e3, t2);
          return e3.toCoordinateArray();
        }, Ki.prototype.snapSegments = function(t2, e3) {
          if (0 === e3.length)
            return null;
          var n2 = e3.length;
          e3[0].equals2D(e3[e3.length - 1]) && (n2 = e3.length - 1);
          for (var i2 = 0; i2 < n2; i2++) {
            var r2 = e3[i2], o2 = this.findSegmentIndexToSnap(r2, t2);
            o2 >= 0 && t2.add(o2 + 1, new C(r2), false);
          }
        }, Ki.prototype.findSegmentIndexToSnap = function(t2, e3) {
          for (var n2 = v.MAX_VALUE, i2 = -1, r2 = 0; r2 < e3.size() - 1; r2++) {
            if (this._seg.p0 = e3.get(r2), this._seg.p1 = e3.get(r2 + 1), this._seg.p0.equals2D(t2) || this._seg.p1.equals2D(t2)) {
              if (this._allowSnappingToSourceVertices)
                continue;
              return -1;
            }
            var o2 = this._seg.distance(t2);
            o2 < this._snapTolerance && o2 < n2 && (n2 = o2, i2 = r2);
          }
          return i2;
        }, Ki.prototype.setAllowSnappingToSourceVertices = function(t2) {
          this._allowSnappingToSourceVertices = t2;
        }, Ki.prototype.interfaces_ = function() {
          return [];
        }, Ki.prototype.getClass = function() {
          return Ki;
        }, Ki.isClosed = function(t2) {
          return !(t2.length <= 1) && t2[0].equals2D(t2[t2.length - 1]);
        };
        var Ji = function(t2) {
          this._srcGeom = t2 || null;
        }, Qi = { SNAP_PRECISION_FACTOR: { configurable: true } };
        Ji.prototype.snapTo = function(t2, e3) {
          var n2 = this.extractTargetCoordinates(t2);
          return new Zi(e3, n2).transform(this._srcGeom);
        }, Ji.prototype.snapToSelf = function(t2, e3) {
          var n2 = this.extractTargetCoordinates(this._srcGeom), i2 = new Zi(t2, n2, true).transform(this._srcGeom), r2 = i2;
          return e3 && T(r2, Zt) && (r2 = i2.buffer(0)), r2;
        }, Ji.prototype.computeSnapTolerance = function(t2) {
          return this.computeMinimumSegmentLength(t2) / 10;
        }, Ji.prototype.extractTargetCoordinates = function(t2) {
          for (var e3 = new f(), n2 = t2.getCoordinates(), i2 = 0; i2 < n2.length; i2++)
            e3.add(n2[i2]);
          return e3.toArray(new Array(0).fill(null));
        }, Ji.prototype.computeMinimumSegmentLength = function(t2) {
          for (var e3 = v.MAX_VALUE, n2 = 0; n2 < t2.length - 1; n2++) {
            var i2 = t2[n2].distance(t2[n2 + 1]);
            i2 < e3 && (e3 = i2);
          }
          return e3;
        }, Ji.prototype.interfaces_ = function() {
          return [];
        }, Ji.prototype.getClass = function() {
          return Ji;
        }, Ji.snap = function(t2, e3, n2) {
          var i2 = new Array(2).fill(null), r2 = new Ji(t2);
          i2[0] = r2.snapTo(e3, n2);
          var o2 = new Ji(e3);
          return i2[1] = o2.snapTo(i2[0], n2), i2;
        }, Ji.computeOverlaySnapTolerance = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0], e3 = Ji.computeSizeBasedSnapTolerance(t2), n2 = t2.getPrecisionModel();
            if (n2.getType() === fe.FIXED) {
              var i2 = 1 / n2.getScale() * 2 / 1.415;
              i2 > e3 && (e3 = i2);
            }
            return e3;
          }
          if (2 === arguments.length) {
            var r2 = arguments[0], o2 = arguments[1];
            return Math.min(Ji.computeOverlaySnapTolerance(r2), Ji.computeOverlaySnapTolerance(o2));
          }
        }, Ji.computeSizeBasedSnapTolerance = function(t2) {
          var e3 = t2.getEnvelopeInternal();
          return Math.min(e3.getHeight(), e3.getWidth()) * Ji.SNAP_PRECISION_FACTOR;
        }, Ji.snapToSelf = function(t2, e3, n2) {
          return new Ji(t2).snapToSelf(e3, n2);
        }, Qi.SNAP_PRECISION_FACTOR.get = function() {
          return 1e-9;
        }, Object.defineProperties(Ji, Qi);
        var Zi = function(t2) {
          function e3(e4, n2, i2) {
            t2.call(this), this._snapTolerance = e4 || null, this._snapPts = n2 || null, this._isSelfSnap = void 0 !== i2 && i2;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.snapLine = function(t3, e4) {
            var n2 = new Ki(t3, this._snapTolerance);
            return n2.setAllowSnappingToSourceVertices(this._isSelfSnap), n2.snapTo(e4);
          }, e3.prototype.transformCoordinates = function(t3, e4) {
            var n2 = t3.toCoordinateArray(), i2 = this.snapLine(n2, this._snapPts);
            return this._factory.getCoordinateSequenceFactory().create(i2);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(Wi), $i = function() {
          this._isFirst = true, this._commonMantissaBitsCount = 53, this._commonBits = 0, this._commonSignExp = null;
        };
        $i.prototype.getCommon = function() {
          return v.longBitsToDouble(this._commonBits);
        }, $i.prototype.add = function(t2) {
          var e3 = v.doubleToLongBits(t2);
          if (this._isFirst)
            return this._commonBits = e3, this._commonSignExp = $i.signExpBits(this._commonBits), this._isFirst = false, null;
          if ($i.signExpBits(e3) !== this._commonSignExp)
            return this._commonBits = 0, null;
          this._commonMantissaBitsCount = $i.numCommonMostSigMantissaBits(this._commonBits, e3), this._commonBits = $i.zeroLowerBits(this._commonBits, 64 - (12 + this._commonMantissaBitsCount));
        }, $i.prototype.toString = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0], e3 = v.longBitsToDouble(t2), n2 = "0000000000000000000000000000000000000000000000000000000000000000" + v.toBinaryString(t2), i2 = n2.substring(n2.length - 64);
            return i2.substring(0, 1) + "  " + i2.substring(1, 12) + "(exp) " + i2.substring(12) + " [ " + e3 + " ]";
          }
        }, $i.prototype.interfaces_ = function() {
          return [];
        }, $i.prototype.getClass = function() {
          return $i;
        }, $i.getBit = function(t2, e3) {
          return 0 != (t2 & 1 << e3) ? 1 : 0;
        }, $i.signExpBits = function(t2) {
          return t2 >> 52;
        }, $i.zeroLowerBits = function(t2, e3) {
          return t2 & ~((1 << e3) - 1);
        }, $i.numCommonMostSigMantissaBits = function(t2, e3) {
          for (var n2 = 0, i2 = 52; i2 >= 0; i2--) {
            if ($i.getBit(t2, i2) !== $i.getBit(e3, i2))
              return n2;
            n2++;
          }
          return 52;
        };
        var tr = function() {
          this._commonCoord = null, this._ccFilter = new nr();
        }, er = { CommonCoordinateFilter: { configurable: true }, Translater: { configurable: true } };
        tr.prototype.addCommonBits = function(t2) {
          var e3 = new ir(this._commonCoord);
          t2.apply(e3), t2.geometryChanged();
        }, tr.prototype.removeCommonBits = function(t2) {
          if (0 === this._commonCoord.x && 0 === this._commonCoord.y)
            return t2;
          var e3 = new C(this._commonCoord);
          e3.x = -e3.x, e3.y = -e3.y;
          var n2 = new ir(e3);
          return t2.apply(n2), t2.geometryChanged(), t2;
        }, tr.prototype.getCommonCoordinate = function() {
          return this._commonCoord;
        }, tr.prototype.add = function(t2) {
          t2.apply(this._ccFilter), this._commonCoord = this._ccFilter.getCommonCoordinate();
        }, tr.prototype.interfaces_ = function() {
          return [];
        }, tr.prototype.getClass = function() {
          return tr;
        }, er.CommonCoordinateFilter.get = function() {
          return nr;
        }, er.Translater.get = function() {
          return ir;
        }, Object.defineProperties(tr, er);
        var nr = function() {
          this._commonBitsX = new $i(), this._commonBitsY = new $i();
        };
        nr.prototype.filter = function(t2) {
          this._commonBitsX.add(t2.x), this._commonBitsY.add(t2.y);
        }, nr.prototype.getCommonCoordinate = function() {
          return new C(this._commonBitsX.getCommon(), this._commonBitsY.getCommon());
        }, nr.prototype.interfaces_ = function() {
          return [ft];
        }, nr.prototype.getClass = function() {
          return nr;
        };
        var ir = function() {
          this.trans = null;
          var t2 = arguments[0];
          this.trans = t2;
        };
        ir.prototype.filter = function(t2, e3) {
          var n2 = t2.getOrdinate(e3, 0) + this.trans.x, i2 = t2.getOrdinate(e3, 1) + this.trans.y;
          t2.setOrdinate(e3, 0, n2), t2.setOrdinate(e3, 1, i2);
        }, ir.prototype.isDone = function() {
          return false;
        }, ir.prototype.isGeometryChanged = function() {
          return true;
        }, ir.prototype.interfaces_ = function() {
          return [Ut];
        }, ir.prototype.getClass = function() {
          return ir;
        };
        var rr = function(t2, e3) {
          this._geom = new Array(2).fill(null), this._snapTolerance = null, this._cbr = null, this._geom[0] = t2, this._geom[1] = e3, this.computeSnapTolerance();
        };
        rr.prototype.selfSnap = function(t2) {
          return new Ji(t2).snapTo(t2, this._snapTolerance);
        }, rr.prototype.removeCommonBits = function(t2) {
          this._cbr = new tr(), this._cbr.add(t2[0]), this._cbr.add(t2[1]);
          var e3 = new Array(2).fill(null);
          return e3[0] = this._cbr.removeCommonBits(t2[0].copy()), e3[1] = this._cbr.removeCommonBits(t2[1].copy()), e3;
        }, rr.prototype.prepareResult = function(t2) {
          return this._cbr.addCommonBits(t2), t2;
        }, rr.prototype.getResultGeometry = function(t2) {
          var e3 = this.snap(this._geom), n2 = Lr.overlayOp(e3[0], e3[1], t2);
          return this.prepareResult(n2);
        }, rr.prototype.checkValid = function(t2) {
          t2.isValid() || Y.out.println("Snapped geometry is invalid");
        }, rr.prototype.computeSnapTolerance = function() {
          this._snapTolerance = Ji.computeOverlaySnapTolerance(this._geom[0], this._geom[1]);
        }, rr.prototype.snap = function(t2) {
          var e3 = this.removeCommonBits(t2);
          return Ji.snap(e3[0], e3[1], this._snapTolerance);
        }, rr.prototype.interfaces_ = function() {
          return [];
        }, rr.prototype.getClass = function() {
          return rr;
        }, rr.overlayOp = function(t2, e3, n2) {
          return new rr(t2, e3).getResultGeometry(n2);
        }, rr.union = function(t2, e3) {
          return rr.overlayOp(t2, e3, Lr.UNION);
        }, rr.intersection = function(t2, e3) {
          return rr.overlayOp(t2, e3, Lr.INTERSECTION);
        }, rr.symDifference = function(t2, e3) {
          return rr.overlayOp(t2, e3, Lr.SYMDIFFERENCE);
        }, rr.difference = function(t2, e3) {
          return rr.overlayOp(t2, e3, Lr.DIFFERENCE);
        };
        var or = function(t2, e3) {
          this._geom = new Array(2).fill(null), this._geom[0] = t2, this._geom[1] = e3;
        };
        or.prototype.getResultGeometry = function(t2) {
          var e3 = null, n2 = false, i2 = null;
          try {
            e3 = Lr.overlayOp(this._geom[0], this._geom[1], t2);
            n2 = true;
          } catch (t3) {
            if (!(t3 instanceof $))
              throw t3;
            i2 = t3;
          }
          if (!n2)
            try {
              e3 = rr.overlayOp(this._geom[0], this._geom[1], t2);
            } catch (t3) {
              throw t3 instanceof $ ? i2 : t3;
            }
          return e3;
        }, or.prototype.interfaces_ = function() {
          return [];
        }, or.prototype.getClass = function() {
          return or;
        }, or.overlayOp = function(t2, e3, n2) {
          return new or(t2, e3).getResultGeometry(n2);
        }, or.union = function(t2, e3) {
          return or.overlayOp(t2, e3, Lr.UNION);
        }, or.intersection = function(t2, e3) {
          return or.overlayOp(t2, e3, Lr.INTERSECTION);
        }, or.symDifference = function(t2, e3) {
          return or.overlayOp(t2, e3, Lr.SYMDIFFERENCE);
        }, or.difference = function(t2, e3) {
          return or.overlayOp(t2, e3, Lr.DIFFERENCE);
        };
        var sr = function() {
          this.mce = null, this.chainIndex = null;
          var t2 = arguments[0], e3 = arguments[1];
          this.mce = t2, this.chainIndex = e3;
        };
        sr.prototype.computeIntersections = function(t2, e3) {
          this.mce.computeIntersectsForChain(this.chainIndex, t2.mce, t2.chainIndex, e3);
        }, sr.prototype.interfaces_ = function() {
          return [];
        }, sr.prototype.getClass = function() {
          return sr;
        };
        var ar = function t2() {
          if (this._label = null, this._xValue = null, this._eventType = null, this._insertEvent = null, this._deleteEventIndex = null, this._obj = null, 2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            this._eventType = t2.DELETE, this._xValue = e3, this._insertEvent = n2;
          } else if (3 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2];
            this._eventType = t2.INSERT, this._label = i2, this._xValue = r2, this._obj = o2;
          }
        }, ur = { INSERT: { configurable: true }, DELETE: { configurable: true } };
        ar.prototype.isDelete = function() {
          return this._eventType === ar.DELETE;
        }, ar.prototype.setDeleteEventIndex = function(t2) {
          this._deleteEventIndex = t2;
        }, ar.prototype.getObject = function() {
          return this._obj;
        }, ar.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this._xValue < e3._xValue ? -1 : this._xValue > e3._xValue ? 1 : this._eventType < e3._eventType ? -1 : this._eventType > e3._eventType ? 1 : 0;
        }, ar.prototype.getInsertEvent = function() {
          return this._insertEvent;
        }, ar.prototype.isInsert = function() {
          return this._eventType === ar.INSERT;
        }, ar.prototype.isSameLabel = function(t2) {
          return null !== this._label && this._label === t2._label;
        }, ar.prototype.getDeleteEventIndex = function() {
          return this._deleteEventIndex;
        }, ar.prototype.interfaces_ = function() {
          return [E];
        }, ar.prototype.getClass = function() {
          return ar;
        }, ur.INSERT.get = function() {
          return 1;
        }, ur.DELETE.get = function() {
          return 2;
        }, Object.defineProperties(ar, ur);
        var lr = function() {
        };
        lr.prototype.interfaces_ = function() {
          return [];
        }, lr.prototype.getClass = function() {
          return lr;
        };
        var cr = function() {
          this._hasIntersection = false, this._hasProper = false, this._hasProperInterior = false, this._properIntersectionPoint = null, this._li = null, this._includeProper = null, this._recordIsolated = null, this._isSelfIntersection = null, this._numIntersections = 0, this.numTests = 0, this._bdyNodes = null, this._isDone = false, this._isDoneWhenProperInt = false;
          var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
          this._li = t2, this._includeProper = e3, this._recordIsolated = n2;
        };
        cr.prototype.isTrivialIntersection = function(t2, e3, n2, i2) {
          if (t2 === n2 && 1 === this._li.getIntersectionNum()) {
            if (cr.isAdjacentSegments(e3, i2))
              return true;
            if (t2.isClosed()) {
              var r2 = t2.getNumPoints() - 1;
              if (0 === e3 && i2 === r2 || 0 === i2 && e3 === r2)
                return true;
            }
          }
          return false;
        }, cr.prototype.getProperIntersectionPoint = function() {
          return this._properIntersectionPoint;
        }, cr.prototype.setIsDoneIfProperInt = function(t2) {
          this._isDoneWhenProperInt = t2;
        }, cr.prototype.hasProperInteriorIntersection = function() {
          return this._hasProperInterior;
        }, cr.prototype.isBoundaryPointInternal = function(t2, e3) {
          for (var n2 = e3.iterator(); n2.hasNext(); ) {
            var i2 = n2.next().getCoordinate();
            if (t2.isIntersection(i2))
              return true;
          }
          return false;
        }, cr.prototype.hasProperIntersection = function() {
          return this._hasProper;
        }, cr.prototype.hasIntersection = function() {
          return this._hasIntersection;
        }, cr.prototype.isDone = function() {
          return this._isDone;
        }, cr.prototype.isBoundaryPoint = function(t2, e3) {
          return null !== e3 && (!!this.isBoundaryPointInternal(t2, e3[0]) || !!this.isBoundaryPointInternal(t2, e3[1]));
        }, cr.prototype.setBoundaryNodes = function(t2, e3) {
          this._bdyNodes = new Array(2).fill(null), this._bdyNodes[0] = t2, this._bdyNodes[1] = e3;
        }, cr.prototype.addIntersections = function(t2, e3, n2, i2) {
          if (t2 === n2 && e3 === i2)
            return null;
          this.numTests++;
          var r2 = t2.getCoordinates()[e3], o2 = t2.getCoordinates()[e3 + 1], s2 = n2.getCoordinates()[i2], a2 = n2.getCoordinates()[i2 + 1];
          this._li.computeIntersection(r2, o2, s2, a2), this._li.hasIntersection() && (this._recordIsolated && (t2.setIsolated(false), n2.setIsolated(false)), this._numIntersections++, this.isTrivialIntersection(t2, e3, n2, i2) || (this._hasIntersection = true, !this._includeProper && this._li.isProper() || (t2.addIntersections(this._li, e3, 0), n2.addIntersections(this._li, i2, 1)), this._li.isProper() && (this._properIntersectionPoint = this._li.getIntersection(0).copy(), this._hasProper = true, this._isDoneWhenProperInt && (this._isDone = true), this.isBoundaryPoint(this._li, this._bdyNodes) || (this._hasProperInterior = true))));
        }, cr.prototype.interfaces_ = function() {
          return [];
        }, cr.prototype.getClass = function() {
          return cr;
        }, cr.isAdjacentSegments = function(t2, e3) {
          return 1 === Math.abs(t2 - e3);
        };
        var pr = function(t2) {
          function e3() {
            t2.call(this), this.events = new Nt(), this.nOverlaps = null;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.prepareEvents = function() {
            $e.sort(this.events);
            for (var t3 = 0; t3 < this.events.size(); t3++) {
              var e4 = this.events.get(t3);
              e4.isDelete() && e4.getInsertEvent().setDeleteEventIndex(t3);
            }
          }, e3.prototype.computeIntersections = function() {
            if (1 === arguments.length) {
              var t3 = arguments[0];
              this.nOverlaps = 0, this.prepareEvents();
              for (var e4 = 0; e4 < this.events.size(); e4++) {
                var n2 = this.events.get(e4);
                if (n2.isInsert() && this.processOverlaps(e4, n2.getDeleteEventIndex(), n2, t3), t3.isDone())
                  break;
              }
            } else if (3 === arguments.length) {
              if (arguments[2] instanceof cr && T(arguments[0], xt) && T(arguments[1], xt)) {
                var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2];
                this.addEdges(i2, i2), this.addEdges(r2, r2), this.computeIntersections(o2);
              } else if ("boolean" == typeof arguments[2] && T(arguments[0], xt) && arguments[1] instanceof cr) {
                var s2 = arguments[0], a2 = arguments[1];
                arguments[2] ? this.addEdges(s2, null) : this.addEdges(s2), this.computeIntersections(a2);
              }
            }
          }, e3.prototype.addEdge = function(t3, e4) {
            for (var n2 = t3.getMonotoneChainEdge(), i2 = n2.getStartIndexes(), r2 = 0; r2 < i2.length - 1; r2++) {
              var o2 = new sr(n2, r2), s2 = new ar(e4, n2.getMinX(r2), o2);
              this.events.add(s2), this.events.add(new ar(n2.getMaxX(r2), s2));
            }
          }, e3.prototype.processOverlaps = function(t3, e4, n2, i2) {
            for (var r2 = n2.getObject(), o2 = t3; o2 < e4; o2++) {
              var s2 = this.events.get(o2);
              if (s2.isInsert()) {
                var a2 = s2.getObject();
                n2.isSameLabel(s2) || (r2.computeIntersections(a2, i2), this.nOverlaps++);
              }
            }
          }, e3.prototype.addEdges = function() {
            if (1 === arguments.length)
              for (var t3 = arguments[0].iterator(); t3.hasNext(); ) {
                var e4 = t3.next();
                this.addEdge(e4, e4);
              }
            else if (2 === arguments.length)
              for (var n2 = arguments[0], i2 = arguments[1], r2 = n2.iterator(); r2.hasNext(); ) {
                var o2 = r2.next();
                this.addEdge(o2, i2);
              }
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(lr), hr = function() {
          this._min = v.POSITIVE_INFINITY, this._max = v.NEGATIVE_INFINITY;
        }, fr = { NodeComparator: { configurable: true } };
        hr.prototype.getMin = function() {
          return this._min;
        }, hr.prototype.intersects = function(t2, e3) {
          return !(this._min > e3 || this._max < t2);
        }, hr.prototype.getMax = function() {
          return this._max;
        }, hr.prototype.toString = function() {
          return Z.toLineString(new C(this._min, 0), new C(this._max, 0));
        }, hr.prototype.interfaces_ = function() {
          return [];
        }, hr.prototype.getClass = function() {
          return hr;
        }, fr.NodeComparator.get = function() {
          return gr;
        }, Object.defineProperties(hr, fr);
        var gr = function() {
        };
        gr.prototype.compare = function(t2, e3) {
          var n2 = t2, i2 = e3, r2 = (n2._min + n2._max) / 2, o2 = (i2._min + i2._max) / 2;
          return r2 < o2 ? -1 : r2 > o2 ? 1 : 0;
        }, gr.prototype.interfaces_ = function() {
          return [N];
        }, gr.prototype.getClass = function() {
          return gr;
        };
        var dr = function(t2) {
          function e3() {
            t2.call(this), this._item = null;
            var e4 = arguments[0], n2 = arguments[1], i2 = arguments[2];
            this._min = e4, this._max = n2, this._item = i2;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.query = function(t3, e4, n2) {
            if (!this.intersects(t3, e4))
              return null;
            n2.visitItem(this._item);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(hr), yr = function(t2) {
          function e3() {
            t2.call(this), this._node1 = null, this._node2 = null;
            var e4 = arguments[0], n2 = arguments[1];
            this._node1 = e4, this._node2 = n2, this.buildExtent(this._node1, this._node2);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.buildExtent = function(t3, e4) {
            this._min = Math.min(t3._min, e4._min), this._max = Math.max(t3._max, e4._max);
          }, e3.prototype.query = function(t3, e4, n2) {
            if (!this.intersects(t3, e4))
              return null;
            null !== this._node1 && this._node1.query(t3, e4, n2), null !== this._node2 && this._node2.query(t3, e4, n2);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(hr), _r = function() {
          this._leaves = new Nt(), this._root = null, this._level = 0;
        };
        _r.prototype.buildTree = function() {
          $e.sort(this._leaves, new hr.NodeComparator());
          for (var t2 = this._leaves, e3 = null, n2 = new Nt(); ; ) {
            if (this.buildLevel(t2, n2), 1 === n2.size())
              return n2.get(0);
            e3 = t2, t2 = n2, n2 = e3;
          }
        }, _r.prototype.insert = function(t2, e3, n2) {
          if (null !== this._root)
            throw new Error("Index cannot be added to once it has been queried");
          this._leaves.add(new dr(t2, e3, n2));
        }, _r.prototype.query = function(t2, e3, n2) {
          this.init(), this._root.query(t2, e3, n2);
        }, _r.prototype.buildRoot = function() {
          if (null !== this._root)
            return null;
          this._root = this.buildTree();
        }, _r.prototype.printNode = function(t2) {
          Y.out.println(Z.toLineString(new C(t2._min, this._level), new C(t2._max, this._level)));
        }, _r.prototype.init = function() {
          if (null !== this._root)
            return null;
          this.buildRoot();
        }, _r.prototype.buildLevel = function(t2, e3) {
          this._level++, e3.clear();
          for (var n2 = 0; n2 < t2.size(); n2 += 2) {
            var i2 = t2.get(n2);
            if (null === (n2 + 1 < t2.size() ? t2.get(n2) : null))
              e3.add(i2);
            else {
              var r2 = new yr(t2.get(n2), t2.get(n2 + 1));
              e3.add(r2);
            }
          }
        }, _r.prototype.interfaces_ = function() {
          return [];
        }, _r.prototype.getClass = function() {
          return _r;
        };
        var mr = function() {
          this._items = new Nt();
        };
        mr.prototype.visitItem = function(t2) {
          this._items.add(t2);
        }, mr.prototype.getItems = function() {
          return this._items;
        }, mr.prototype.interfaces_ = function() {
          return [Ke];
        }, mr.prototype.getClass = function() {
          return mr;
        };
        var vr = function() {
          this._index = null;
          var t2 = arguments[0];
          if (!T(t2, Zt))
            throw new m("Argument must be Polygonal");
          this._index = new xr(t2);
        }, Ir = { SegmentVisitor: { configurable: true }, IntervalIndexedGeometry: { configurable: true } };
        vr.prototype.locate = function(t2) {
          var e3 = new st(t2), n2 = new Er(e3);
          return this._index.query(t2.y, t2.y, n2), e3.getLocation();
        }, vr.prototype.interfaces_ = function() {
          return [Vn];
        }, vr.prototype.getClass = function() {
          return vr;
        }, Ir.SegmentVisitor.get = function() {
          return Er;
        }, Ir.IntervalIndexedGeometry.get = function() {
          return xr;
        }, Object.defineProperties(vr, Ir);
        var Er = function() {
          this._counter = null;
          var t2 = arguments[0];
          this._counter = t2;
        };
        Er.prototype.visitItem = function(t2) {
          var e3 = t2;
          this._counter.countSegment(e3.getCoordinate(0), e3.getCoordinate(1));
        }, Er.prototype.interfaces_ = function() {
          return [Ke];
        }, Er.prototype.getClass = function() {
          return Er;
        };
        var xr = function() {
          this._index = new _r();
          var t2 = arguments[0];
          this.init(t2);
        };
        xr.prototype.init = function(t2) {
          for (var e3 = Ci.getLines(t2).iterator(); e3.hasNext(); ) {
            var n2 = e3.next().getCoordinates();
            this.addLine(n2);
          }
        }, xr.prototype.addLine = function(t2) {
          for (var e3 = 1; e3 < t2.length; e3++) {
            var n2 = new dn(t2[e3 - 1], t2[e3]), i2 = Math.min(n2.p0.y, n2.p1.y), r2 = Math.max(n2.p0.y, n2.p1.y);
            this._index.insert(i2, r2, n2);
          }
        }, xr.prototype.query = function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1], n2 = new mr();
            return this._index.query(t2, e3, n2), n2.getItems();
          }
          if (3 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2];
            this._index.query(i2, r2, o2);
          }
        }, xr.prototype.interfaces_ = function() {
          return [];
        }, xr.prototype.getClass = function() {
          return xr;
        };
        var Nr = function(t2) {
          function e3() {
            if (t2.call(this), this._parentGeom = null, this._lineEdgeMap = new he(), this._boundaryNodeRule = null, this._useBoundaryDeterminationRule = true, this._argIndex = null, this._boundaryNodes = null, this._hasTooFewPoints = false, this._invalidPoint = null, this._areaPtLocator = null, this._ptLocator = new Si(), 2 === arguments.length) {
              var e4 = arguments[0], n2 = arguments[1], i2 = gt.OGC_SFS_BOUNDARY_RULE;
              this._argIndex = e4, this._parentGeom = n2, this._boundaryNodeRule = i2, null !== n2 && this.add(n2);
            } else if (3 === arguments.length) {
              var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2];
              this._argIndex = r2, this._parentGeom = o2, this._boundaryNodeRule = s2, null !== o2 && this.add(o2);
            }
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.insertBoundaryPoint = function(t3, n2) {
            var i2 = this._nodes.addNode(n2).getLabel(), r2 = 1;
            w.NONE;
            i2.getLocation(t3, Se.ON) === w.BOUNDARY && r2++;
            var o2 = e3.determineBoundary(this._boundaryNodeRule, r2);
            i2.setLocation(t3, o2);
          }, e3.prototype.computeSelfNodes = function() {
            if (2 === arguments.length) {
              var t3 = arguments[0], e4 = arguments[1];
              return this.computeSelfNodes(t3, e4, false);
            }
            if (3 === arguments.length) {
              var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2], o2 = new cr(n2, true, false);
              o2.setIsDoneIfProperInt(r2);
              var s2 = this.createEdgeSetIntersector(), a2 = this._parentGeom instanceof ee || this._parentGeom instanceof $t || this._parentGeom instanceof ne, u2 = i2 || !a2;
              return s2.computeIntersections(this._edges, o2, u2), this.addSelfIntersectionNodes(this._argIndex), o2;
            }
          }, e3.prototype.computeSplitEdges = function(t3) {
            for (var e4 = this._edges.iterator(); e4.hasNext(); ) {
              e4.next().eiList.addSplitEdges(t3);
            }
          }, e3.prototype.computeEdgeIntersections = function(t3, e4, n2) {
            var i2 = new cr(e4, n2, true);
            i2.setBoundaryNodes(this.getBoundaryNodes(), t3.getBoundaryNodes());
            return this.createEdgeSetIntersector().computeIntersections(this._edges, t3._edges, i2), i2;
          }, e3.prototype.getGeometry = function() {
            return this._parentGeom;
          }, e3.prototype.getBoundaryNodeRule = function() {
            return this._boundaryNodeRule;
          }, e3.prototype.hasTooFewPoints = function() {
            return this._hasTooFewPoints;
          }, e3.prototype.addPoint = function() {
            if (arguments[0] instanceof Qt) {
              var t3 = arguments[0].getCoordinate();
              this.insertPoint(this._argIndex, t3, w.INTERIOR);
            } else if (arguments[0] instanceof C) {
              var e4 = arguments[0];
              this.insertPoint(this._argIndex, e4, w.INTERIOR);
            }
          }, e3.prototype.addPolygon = function(t3) {
            this.addPolygonRing(t3.getExteriorRing(), w.EXTERIOR, w.INTERIOR);
            for (var e4 = 0; e4 < t3.getNumInteriorRing(); e4++) {
              var n2 = t3.getInteriorRingN(e4);
              this.addPolygonRing(n2, w.INTERIOR, w.EXTERIOR);
            }
          }, e3.prototype.addEdge = function(t3) {
            this.insertEdge(t3);
            var e4 = t3.getCoordinates();
            this.insertPoint(this._argIndex, e4[0], w.BOUNDARY), this.insertPoint(this._argIndex, e4[e4.length - 1], w.BOUNDARY);
          }, e3.prototype.addLineString = function(t3) {
            var e4 = Lt.removeRepeatedPoints(t3.getCoordinates());
            if (e4.length < 2)
              return this._hasTooFewPoints = true, this._invalidPoint = e4[0], null;
            var n2 = new ni(e4, new Pe(this._argIndex, w.INTERIOR));
            this._lineEdgeMap.put(t3, n2), this.insertEdge(n2), et.isTrue(e4.length >= 2, "found LineString with single point"), this.insertBoundaryPoint(this._argIndex, e4[0]), this.insertBoundaryPoint(this._argIndex, e4[e4.length - 1]);
          }, e3.prototype.getInvalidPoint = function() {
            return this._invalidPoint;
          }, e3.prototype.getBoundaryPoints = function() {
            for (var t3 = this.getBoundaryNodes(), e4 = new Array(t3.size()).fill(null), n2 = 0, i2 = t3.iterator(); i2.hasNext(); ) {
              var r2 = i2.next();
              e4[n2++] = r2.getCoordinate().copy();
            }
            return e4;
          }, e3.prototype.getBoundaryNodes = function() {
            return null === this._boundaryNodes && (this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex)), this._boundaryNodes;
          }, e3.prototype.addSelfIntersectionNode = function(t3, e4, n2) {
            if (this.isBoundaryNode(t3, e4))
              return null;
            n2 === w.BOUNDARY && this._useBoundaryDeterminationRule ? this.insertBoundaryPoint(t3, e4) : this.insertPoint(t3, e4, n2);
          }, e3.prototype.addPolygonRing = function(t3, e4, n2) {
            if (t3.isEmpty())
              return null;
            var i2 = Lt.removeRepeatedPoints(t3.getCoordinates());
            if (i2.length < 4)
              return this._hasTooFewPoints = true, this._invalidPoint = i2[0], null;
            var r2 = e4, o2 = n2;
            at.isCCW(i2) && (r2 = n2, o2 = e4);
            var s2 = new ni(i2, new Pe(this._argIndex, w.BOUNDARY, r2, o2));
            this._lineEdgeMap.put(t3, s2), this.insertEdge(s2), this.insertPoint(this._argIndex, i2[0], w.BOUNDARY);
          }, e3.prototype.insertPoint = function(t3, e4, n2) {
            var i2 = this._nodes.addNode(e4), r2 = i2.getLabel();
            null === r2 ? i2._label = new Pe(t3, n2) : r2.setLocation(t3, n2);
          }, e3.prototype.createEdgeSetIntersector = function() {
            return new pr();
          }, e3.prototype.addSelfIntersectionNodes = function(t3) {
            for (var e4 = this._edges.iterator(); e4.hasNext(); )
              for (var n2 = e4.next(), i2 = n2.getLabel().getLocation(t3), r2 = n2.eiList.iterator(); r2.hasNext(); ) {
                var o2 = r2.next();
                this.addSelfIntersectionNode(t3, o2.coord, i2);
              }
          }, e3.prototype.add = function() {
            if (1 !== arguments.length)
              return t2.prototype.add.apply(this, arguments);
            var e4 = arguments[0];
            if (e4.isEmpty())
              return null;
            if (e4 instanceof ne && (this._useBoundaryDeterminationRule = false), e4 instanceof $t)
              this.addPolygon(e4);
            else if (e4 instanceof Kt)
              this.addLineString(e4);
            else if (e4 instanceof Qt)
              this.addPoint(e4);
            else if (e4 instanceof te)
              this.addCollection(e4);
            else if (e4 instanceof Xt)
              this.addCollection(e4);
            else if (e4 instanceof ne)
              this.addCollection(e4);
            else {
              if (!(e4 instanceof zt))
                throw new Error(e4.getClass().getName());
              this.addCollection(e4);
            }
          }, e3.prototype.addCollection = function(t3) {
            for (var e4 = 0; e4 < t3.getNumGeometries(); e4++) {
              var n2 = t3.getGeometryN(e4);
              this.add(n2);
            }
          }, e3.prototype.locate = function(t3) {
            return T(this._parentGeom, Zt) && this._parentGeom.getNumGeometries() > 50 ? (null === this._areaPtLocator && (this._areaPtLocator = new vr(this._parentGeom)), this._areaPtLocator.locate(t3)) : this._ptLocator.locate(t3, this._parentGeom);
          }, e3.prototype.findEdge = function() {
            if (1 === arguments.length) {
              var e4 = arguments[0];
              return this._lineEdgeMap.get(e4);
            }
            return t2.prototype.findEdge.apply(this, arguments);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3.determineBoundary = function(t3, e4) {
            return t3.isInBoundary(e4) ? w.BOUNDARY : w.INTERIOR;
          }, e3;
        }(Ye), Cr = function() {
          if (this._li = new rt(), this._resultPrecisionModel = null, this._arg = null, 1 === arguments.length) {
            var t2 = arguments[0];
            this.setComputationPrecision(t2.getPrecisionModel()), this._arg = new Array(1).fill(null), this._arg[0] = new Nr(0, t2);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1], i2 = gt.OGC_SFS_BOUNDARY_RULE;
            e3.getPrecisionModel().compareTo(n2.getPrecisionModel()) >= 0 ? this.setComputationPrecision(e3.getPrecisionModel()) : this.setComputationPrecision(n2.getPrecisionModel()), this._arg = new Array(2).fill(null), this._arg[0] = new Nr(0, e3, i2), this._arg[1] = new Nr(1, n2, i2);
          } else if (3 === arguments.length) {
            var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2];
            r2.getPrecisionModel().compareTo(o2.getPrecisionModel()) >= 0 ? this.setComputationPrecision(r2.getPrecisionModel()) : this.setComputationPrecision(o2.getPrecisionModel()), this._arg = new Array(2).fill(null), this._arg[0] = new Nr(0, r2, s2), this._arg[1] = new Nr(1, o2, s2);
          }
        };
        Cr.prototype.getArgGeometry = function(t2) {
          return this._arg[t2].getGeometry();
        }, Cr.prototype.setComputationPrecision = function(t2) {
          this._resultPrecisionModel = t2, this._li.setPrecisionModel(this._resultPrecisionModel);
        }, Cr.prototype.interfaces_ = function() {
          return [];
        }, Cr.prototype.getClass = function() {
          return Cr;
        };
        var Sr = function() {
        };
        Sr.prototype.interfaces_ = function() {
          return [];
        }, Sr.prototype.getClass = function() {
          return Sr;
        }, Sr.map = function() {
          if (arguments[0] instanceof ct && T(arguments[1], Sr.MapOp)) {
            for (var t2 = arguments[0], e3 = arguments[1], n2 = new Nt(), i2 = 0; i2 < t2.getNumGeometries(); i2++) {
              var r2 = e3.map(t2.getGeometryN(i2));
              null !== r2 && n2.add(r2);
            }
            return t2.getFactory().buildGeometry(n2);
          }
          if (T(arguments[0], It) && T(arguments[1], Sr.MapOp)) {
            for (var o2 = arguments[0], s2 = arguments[1], a2 = new Nt(), u2 = o2.iterator(); u2.hasNext(); ) {
              var l2 = u2.next(), c2 = s2.map(l2);
              null !== c2 && a2.add(c2);
            }
            return a2;
          }
        }, Sr.MapOp = function() {
        };
        var Lr = function(t2) {
          function e3() {
            var e4 = arguments[0], n2 = arguments[1];
            t2.call(this, e4, n2), this._ptLocator = new Si(), this._geomFact = null, this._resultGeom = null, this._graph = null, this._edgeList = new Hn(), this._resultPolyList = new Nt(), this._resultLineList = new Nt(), this._resultPointList = new Nt(), this._graph = new Ye(new kn()), this._geomFact = e4.getFactory();
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.insertUniqueEdge = function(t3) {
            var e4 = this._edgeList.findEqualEdge(t3);
            if (null !== e4) {
              var n2 = e4.getLabel(), i2 = t3.getLabel();
              e4.isPointwiseEqual(t3) || (i2 = new Pe(t3.getLabel())).flip();
              var r2 = e4.getDepth();
              r2.isNull() && r2.add(n2), r2.add(i2), n2.merge(i2);
            } else
              this._edgeList.add(t3);
          }, e3.prototype.getGraph = function() {
            return this._graph;
          }, e3.prototype.cancelDuplicateResultEdges = function() {
            for (var t3 = this._graph.getEdgeEnds().iterator(); t3.hasNext(); ) {
              var e4 = t3.next(), n2 = e4.getSym();
              e4.isInResult() && n2.isInResult() && (e4.setInResult(false), n2.setInResult(false));
            }
          }, e3.prototype.isCoveredByLA = function(t3) {
            return !!this.isCovered(t3, this._resultLineList) || !!this.isCovered(t3, this._resultPolyList);
          }, e3.prototype.computeGeometry = function(t3, n2, i2, r2) {
            var o2 = new Nt();
            return o2.addAll(t3), o2.addAll(n2), o2.addAll(i2), o2.isEmpty() ? e3.createEmptyResult(r2, this._arg[0].getGeometry(), this._arg[1].getGeometry(), this._geomFact) : this._geomFact.buildGeometry(o2);
          }, e3.prototype.mergeSymLabels = function() {
            for (var t3 = this._graph.getNodes().iterator(); t3.hasNext(); ) {
              t3.next().getEdges().mergeSymLabels();
            }
          }, e3.prototype.isCovered = function(t3, e4) {
            for (var n2 = e4.iterator(); n2.hasNext(); ) {
              var i2 = n2.next();
              if (this._ptLocator.locate(t3, i2) !== w.EXTERIOR)
                return true;
            }
            return false;
          }, e3.prototype.replaceCollapsedEdges = function() {
            for (var t3 = new Nt(), e4 = this._edgeList.iterator(); e4.hasNext(); ) {
              var n2 = e4.next();
              n2.isCollapsed() && (e4.remove(), t3.add(n2.getCollapsedEdge()));
            }
            this._edgeList.addAll(t3);
          }, e3.prototype.updateNodeLabelling = function() {
            for (var t3 = this._graph.getNodes().iterator(); t3.hasNext(); ) {
              var e4 = t3.next(), n2 = e4.getEdges().getLabel();
              e4.getLabel().merge(n2);
            }
          }, e3.prototype.getResultGeometry = function(t3) {
            return this.computeOverlay(t3), this._resultGeom;
          }, e3.prototype.insertUniqueEdges = function(t3) {
            for (var e4 = t3.iterator(); e4.hasNext(); ) {
              var n2 = e4.next();
              this.insertUniqueEdge(n2);
            }
          }, e3.prototype.computeOverlay = function(t3) {
            this.copyPoints(0), this.copyPoints(1), this._arg[0].computeSelfNodes(this._li, false), this._arg[1].computeSelfNodes(this._li, false), this._arg[0].computeEdgeIntersections(this._arg[1], this._li, true);
            var e4 = new Nt();
            this._arg[0].computeSplitEdges(e4), this._arg[1].computeSplitEdges(e4), this.insertUniqueEdges(e4), this.computeLabelsFromDepths(), this.replaceCollapsedEdges(), Yi.checkValid(this._edgeList.getEdges()), this._graph.addEdges(this._edgeList.getEdges()), this.computeLabelling(), this.labelIncompleteNodes(), this.findResultAreaEdges(t3), this.cancelDuplicateResultEdges();
            var n2 = new ke(this._geomFact);
            n2.add(this._graph), this._resultPolyList = n2.getPolygons();
            var i2 = new ji(this, this._geomFact, this._ptLocator);
            this._resultLineList = i2.build(t3);
            var r2 = new Hi(this, this._geomFact, this._ptLocator);
            this._resultPointList = r2.build(t3), this._resultGeom = this.computeGeometry(this._resultPointList, this._resultLineList, this._resultPolyList, t3);
          }, e3.prototype.labelIncompleteNode = function(t3, e4) {
            var n2 = this._ptLocator.locate(t3.getCoordinate(), this._arg[e4].getGeometry());
            t3.getLabel().setLocation(e4, n2);
          }, e3.prototype.copyPoints = function(t3) {
            for (var e4 = this._arg[t3].getNodeIterator(); e4.hasNext(); ) {
              var n2 = e4.next();
              this._graph.addNode(n2.getCoordinate()).setLabel(t3, n2.getLabel().getLocation(t3));
            }
          }, e3.prototype.findResultAreaEdges = function(t3) {
            for (var n2 = this._graph.getEdgeEnds().iterator(); n2.hasNext(); ) {
              var i2 = n2.next(), r2 = i2.getLabel();
              r2.isArea() && !i2.isInteriorAreaEdge() && e3.isResultOfOp(r2.getLocation(0, Se.RIGHT), r2.getLocation(1, Se.RIGHT), t3) && i2.setInResult(true);
            }
          }, e3.prototype.computeLabelsFromDepths = function() {
            for (var t3 = this._edgeList.iterator(); t3.hasNext(); ) {
              var e4 = t3.next(), n2 = e4.getLabel(), i2 = e4.getDepth();
              if (!i2.isNull()) {
                i2.normalize();
                for (var r2 = 0; r2 < 2; r2++)
                  n2.isNull(r2) || !n2.isArea() || i2.isNull(r2) || (0 === i2.getDelta(r2) ? n2.toLine(r2) : (et.isTrue(!i2.isNull(r2, Se.LEFT), "depth of LEFT side has not been initialized"), n2.setLocation(r2, Se.LEFT, i2.getLocation(r2, Se.LEFT)), et.isTrue(!i2.isNull(r2, Se.RIGHT), "depth of RIGHT side has not been initialized"), n2.setLocation(r2, Se.RIGHT, i2.getLocation(r2, Se.RIGHT))));
              }
            }
          }, e3.prototype.computeLabelling = function() {
            for (var t3 = this._graph.getNodes().iterator(); t3.hasNext(); ) {
              t3.next().getEdges().computeLabelling(this._arg);
            }
            this.mergeSymLabels(), this.updateNodeLabelling();
          }, e3.prototype.labelIncompleteNodes = function() {
            for (var t3 = this._graph.getNodes().iterator(); t3.hasNext(); ) {
              var e4 = t3.next(), n2 = e4.getLabel();
              e4.isIsolated() && (n2.isNull(0) ? this.labelIncompleteNode(e4, 0) : this.labelIncompleteNode(e4, 1)), e4.getEdges().updateLabelling(n2);
            }
          }, e3.prototype.isCoveredByA = function(t3) {
            return !!this.isCovered(t3, this._resultPolyList);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(Cr);
        Lr.overlayOp = function(t2, e3, n2) {
          return new Lr(t2, e3).getResultGeometry(n2);
        }, Lr.intersection = function(t2, e3) {
          if (t2.isEmpty() || e3.isEmpty())
            return Lr.createEmptyResult(Lr.INTERSECTION, t2, e3, t2.getFactory());
          if (t2.isGeometryCollection()) {
            var n2 = e3;
            return ki.map(t2, { interfaces_: function() {
              return [Sr.MapOp];
            }, map: function(t3) {
              return t3.intersection(n2);
            } });
          }
          return t2.checkNotGeometryCollection(t2), t2.checkNotGeometryCollection(e3), or.overlayOp(t2, e3, Lr.INTERSECTION);
        }, Lr.symDifference = function(t2, e3) {
          if (t2.isEmpty() || e3.isEmpty()) {
            if (t2.isEmpty() && e3.isEmpty())
              return Lr.createEmptyResult(Lr.SYMDIFFERENCE, t2, e3, t2.getFactory());
            if (t2.isEmpty())
              return e3.copy();
            if (e3.isEmpty())
              return t2.copy();
          }
          return t2.checkNotGeometryCollection(t2), t2.checkNotGeometryCollection(e3), or.overlayOp(t2, e3, Lr.SYMDIFFERENCE);
        }, Lr.resultDimension = function(t2, e3, n2) {
          var i2 = e3.getDimension(), r2 = n2.getDimension(), o2 = -1;
          switch (t2) {
            case Lr.INTERSECTION:
              o2 = Math.min(i2, r2);
              break;
            case Lr.UNION:
              o2 = Math.max(i2, r2);
              break;
            case Lr.DIFFERENCE:
              o2 = i2;
              break;
            case Lr.SYMDIFFERENCE:
              o2 = Math.max(i2, r2);
          }
          return o2;
        }, Lr.createEmptyResult = function(t2, e3, n2, i2) {
          var r2 = null;
          switch (Lr.resultDimension(t2, e3, n2)) {
            case -1:
              r2 = i2.createGeometryCollection(new Array(0).fill(null));
              break;
            case 0:
              r2 = i2.createPoint();
              break;
            case 1:
              r2 = i2.createLineString();
              break;
            case 2:
              r2 = i2.createPolygon();
          }
          return r2;
        }, Lr.difference = function(t2, e3) {
          return t2.isEmpty() ? Lr.createEmptyResult(Lr.DIFFERENCE, t2, e3, t2.getFactory()) : e3.isEmpty() ? t2.copy() : (t2.checkNotGeometryCollection(t2), t2.checkNotGeometryCollection(e3), or.overlayOp(t2, e3, Lr.DIFFERENCE));
        }, Lr.isResultOfOp = function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1], n2 = t2.getLocation(0), i2 = t2.getLocation(1);
            return Lr.isResultOfOp(n2, i2, e3);
          }
          if (3 === arguments.length) {
            var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2];
            switch (r2 === w.BOUNDARY && (r2 = w.INTERIOR), o2 === w.BOUNDARY && (o2 = w.INTERIOR), s2) {
              case Lr.INTERSECTION:
                return r2 === w.INTERIOR && o2 === w.INTERIOR;
              case Lr.UNION:
                return r2 === w.INTERIOR || o2 === w.INTERIOR;
              case Lr.DIFFERENCE:
                return r2 === w.INTERIOR && o2 !== w.INTERIOR;
              case Lr.SYMDIFFERENCE:
                return r2 === w.INTERIOR && o2 !== w.INTERIOR || r2 !== w.INTERIOR && o2 === w.INTERIOR;
            }
            return false;
          }
        }, Lr.INTERSECTION = 1, Lr.UNION = 2, Lr.DIFFERENCE = 3, Lr.SYMDIFFERENCE = 4;
        var br = function() {
          this._g = null, this._boundaryDistanceTolerance = null, this._linework = null, this._ptLocator = new Si(), this._seg = new dn();
          var t2 = arguments[0], e3 = arguments[1];
          this._g = t2, this._boundaryDistanceTolerance = e3, this._linework = this.extractLinework(t2);
        };
        br.prototype.isWithinToleranceOfBoundary = function(t2) {
          for (var e3 = 0; e3 < this._linework.getNumGeometries(); e3++)
            for (var n2 = this._linework.getGeometryN(e3).getCoordinateSequence(), i2 = 0; i2 < n2.size() - 1; i2++) {
              n2.getCoordinate(i2, this._seg.p0), n2.getCoordinate(i2 + 1, this._seg.p1);
              if (this._seg.distance(t2) <= this._boundaryDistanceTolerance)
                return true;
            }
          return false;
        }, br.prototype.getLocation = function(t2) {
          return this.isWithinToleranceOfBoundary(t2) ? w.BOUNDARY : this._ptLocator.locate(t2, this._g);
        }, br.prototype.extractLinework = function(t2) {
          var e3 = new wr();
          t2.apply(e3);
          var n2 = e3.getLinework(), i2 = _e.toLineStringArray(n2);
          return t2.getFactory().createMultiLineString(i2);
        }, br.prototype.interfaces_ = function() {
          return [];
        }, br.prototype.getClass = function() {
          return br;
        };
        var wr = function() {
          this._linework = null, this._linework = new Nt();
        };
        wr.prototype.getLinework = function() {
          return this._linework;
        }, wr.prototype.filter = function(t2) {
          if (t2 instanceof $t) {
            var e3 = t2;
            this._linework.add(e3.getExteriorRing());
            for (var n2 = 0; n2 < e3.getNumInteriorRing(); n2++)
              this._linework.add(e3.getInteriorRingN(n2));
          }
        }, wr.prototype.interfaces_ = function() {
          return [Vt];
        }, wr.prototype.getClass = function() {
          return wr;
        };
        var Or = function() {
          this._g = null, this._doLeft = true, this._doRight = true;
          var t2 = arguments[0];
          this._g = t2;
        };
        Or.prototype.extractPoints = function(t2, e3, n2) {
          for (var i2 = t2.getCoordinates(), r2 = 0; r2 < i2.length - 1; r2++)
            this.computeOffsetPoints(i2[r2], i2[r2 + 1], e3, n2);
        }, Or.prototype.setSidesToGenerate = function(t2, e3) {
          this._doLeft = t2, this._doRight = e3;
        }, Or.prototype.getPoints = function(t2) {
          for (var e3 = new Nt(), n2 = Ci.getLines(this._g).iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            this.extractPoints(i2, t2, e3);
          }
          return e3;
        }, Or.prototype.computeOffsetPoints = function(t2, e3, n2, i2) {
          var r2 = e3.x - t2.x, o2 = e3.y - t2.y, s2 = Math.sqrt(r2 * r2 + o2 * o2), a2 = n2 * r2 / s2, u2 = n2 * o2 / s2, l2 = (e3.x + t2.x) / 2, c2 = (e3.y + t2.y) / 2;
          if (this._doLeft) {
            var p2 = new C(l2 - u2, c2 + a2);
            i2.add(p2);
          }
          if (this._doRight) {
            var h2 = new C(l2 + u2, c2 - a2);
            i2.add(h2);
          }
        }, Or.prototype.interfaces_ = function() {
          return [];
        }, Or.prototype.getClass = function() {
          return Or;
        };
        var Tr = function t2() {
          this._geom = null, this._locFinder = null, this._location = new Array(3).fill(null), this._invalidLocation = null, this._boundaryDistanceTolerance = t2.TOLERANCE, this._testCoords = new Nt();
          var e3 = arguments[0], n2 = arguments[1], i2 = arguments[2];
          this._boundaryDistanceTolerance = t2.computeBoundaryDistanceTolerance(e3, n2), this._geom = [e3, n2, i2], this._locFinder = [new br(this._geom[0], this._boundaryDistanceTolerance), new br(this._geom[1], this._boundaryDistanceTolerance), new br(this._geom[2], this._boundaryDistanceTolerance)];
        }, Rr = { TOLERANCE: { configurable: true } };
        Tr.prototype.reportResult = function(t2, e3, n2) {
          Y.out.println("Overlay result invalid - A:" + w.toLocationSymbol(e3[0]) + " B:" + w.toLocationSymbol(e3[1]) + " expected:" + (n2 ? "i" : "e") + " actual:" + w.toLocationSymbol(e3[2]));
        }, Tr.prototype.isValid = function(t2) {
          this.addTestPts(this._geom[0]), this.addTestPts(this._geom[1]);
          var e3 = this.checkValid(t2);
          return e3;
        }, Tr.prototype.checkValid = function() {
          if (1 === arguments.length) {
            for (var t2 = arguments[0], e3 = 0; e3 < this._testCoords.size(); e3++) {
              var n2 = this._testCoords.get(e3);
              if (!this.checkValid(t2, n2))
                return this._invalidLocation = n2, false;
            }
            return true;
          }
          if (2 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1];
            return this._location[0] = this._locFinder[0].getLocation(r2), this._location[1] = this._locFinder[1].getLocation(r2), this._location[2] = this._locFinder[2].getLocation(r2), !!Tr.hasLocation(this._location, w.BOUNDARY) || this.isValidResult(i2, this._location);
          }
        }, Tr.prototype.addTestPts = function(t2) {
          var e3 = new Or(t2);
          this._testCoords.addAll(e3.getPoints(5 * this._boundaryDistanceTolerance));
        }, Tr.prototype.isValidResult = function(t2, e3) {
          var n2 = Lr.isResultOfOp(e3[0], e3[1], t2), i2 = !(n2 ^ e3[2] === w.INTERIOR);
          return i2 || this.reportResult(t2, e3, n2), i2;
        }, Tr.prototype.getInvalidLocation = function() {
          return this._invalidLocation;
        }, Tr.prototype.interfaces_ = function() {
          return [];
        }, Tr.prototype.getClass = function() {
          return Tr;
        }, Tr.hasLocation = function(t2, e3) {
          for (var n2 = 0; n2 < 3; n2++)
            if (t2[n2] === e3)
              return true;
          return false;
        }, Tr.computeBoundaryDistanceTolerance = function(t2, e3) {
          return Math.min(Ji.computeSizeBasedSnapTolerance(t2), Ji.computeSizeBasedSnapTolerance(e3));
        }, Tr.isValid = function(t2, e3, n2, i2) {
          return new Tr(t2, e3, i2).isValid(n2);
        }, Rr.TOLERANCE.get = function() {
          return 1e-6;
        }, Object.defineProperties(Tr, Rr);
        var Pr = function t2(e3) {
          this._geomFactory = null, this._skipEmpty = false, this._inputGeoms = null, this._geomFactory = t2.extractFactory(e3), this._inputGeoms = e3;
        };
        Pr.prototype.extractElements = function(t2, e3) {
          if (null === t2)
            return null;
          for (var n2 = 0; n2 < t2.getNumGeometries(); n2++) {
            var i2 = t2.getGeometryN(n2);
            this._skipEmpty && i2.isEmpty() || e3.add(i2);
          }
        }, Pr.prototype.combine = function() {
          for (var t2 = new Nt(), e3 = this._inputGeoms.iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            this.extractElements(n2, t2);
          }
          return 0 === t2.size() ? null !== this._geomFactory ? this._geomFactory.createGeometryCollection(null) : null : this._geomFactory.buildGeometry(t2);
        }, Pr.prototype.interfaces_ = function() {
          return [];
        }, Pr.prototype.getClass = function() {
          return Pr;
        }, Pr.combine = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return new Pr(t2).combine();
          }
          if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            return new Pr(Pr.createList(e3, n2)).combine();
          }
          if (3 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2];
            return new Pr(Pr.createList(i2, r2, o2)).combine();
          }
        }, Pr.extractFactory = function(t2) {
          return t2.isEmpty() ? null : t2.iterator().next().getFactory();
        }, Pr.createList = function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1], n2 = new Nt();
            return n2.add(t2), n2.add(e3), n2;
          }
          if (3 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2], s2 = new Nt();
            return s2.add(i2), s2.add(r2), s2.add(o2), s2;
          }
        };
        var Dr = function() {
          this._inputPolys = null, this._geomFactory = null;
          var t2 = arguments[0];
          this._inputPolys = t2, null === this._inputPolys && (this._inputPolys = new Nt());
        }, Mr = { STRTREE_NODE_CAPACITY: { configurable: true } };
        Dr.prototype.reduceToGeometries = function(t2) {
          for (var e3 = new Nt(), n2 = t2.iterator(); n2.hasNext(); ) {
            var i2 = n2.next(), r2 = null;
            T(i2, xt) ? r2 = this.unionTree(i2) : i2 instanceof ct && (r2 = i2), e3.add(r2);
          }
          return e3;
        }, Dr.prototype.extractByEnvelope = function(t2, e3, n2) {
          for (var i2 = new Nt(), r2 = 0; r2 < e3.getNumGeometries(); r2++) {
            var o2 = e3.getGeometryN(r2);
            o2.getEnvelopeInternal().intersects(t2) ? i2.add(o2) : n2.add(o2);
          }
          return this._geomFactory.buildGeometry(i2);
        }, Dr.prototype.unionOptimized = function(t2, e3) {
          var n2 = t2.getEnvelopeInternal(), i2 = e3.getEnvelopeInternal();
          if (!n2.intersects(i2)) {
            return Pr.combine(t2, e3);
          }
          if (t2.getNumGeometries() <= 1 && e3.getNumGeometries() <= 1)
            return this.unionActual(t2, e3);
          var r2 = n2.intersection(i2);
          return this.unionUsingEnvelopeIntersection(t2, e3, r2);
        }, Dr.prototype.union = function() {
          if (null === this._inputPolys)
            throw new Error("union() method cannot be called twice");
          if (this._inputPolys.isEmpty())
            return null;
          this._geomFactory = this._inputPolys.iterator().next().getFactory();
          for (var t2 = new sn(Dr.STRTREE_NODE_CAPACITY), e3 = this._inputPolys.iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            t2.insert(n2.getEnvelopeInternal(), n2);
          }
          this._inputPolys = null;
          var i2 = t2.itemsTree();
          return this.unionTree(i2);
        }, Dr.prototype.binaryUnion = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return this.binaryUnion(t2, 0, t2.size());
          }
          if (3 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1], i2 = arguments[2];
            if (i2 - n2 <= 1) {
              var r2 = Dr.getGeometry(e3, n2);
              return this.unionSafe(r2, null);
            }
            if (i2 - n2 == 2)
              return this.unionSafe(Dr.getGeometry(e3, n2), Dr.getGeometry(e3, n2 + 1));
            var o2 = Math.trunc((i2 + n2) / 2), s2 = this.binaryUnion(e3, n2, o2), a2 = this.binaryUnion(e3, o2, i2);
            return this.unionSafe(s2, a2);
          }
        }, Dr.prototype.repeatedUnion = function(t2) {
          for (var e3 = null, n2 = t2.iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            e3 = null === e3 ? i2.copy() : e3.union(i2);
          }
          return e3;
        }, Dr.prototype.unionSafe = function(t2, e3) {
          return null === t2 && null === e3 ? null : null === t2 ? e3.copy() : null === e3 ? t2.copy() : this.unionOptimized(t2, e3);
        }, Dr.prototype.unionActual = function(t2, e3) {
          return Dr.restrictToPolygons(t2.union(e3));
        }, Dr.prototype.unionTree = function(t2) {
          var e3 = this.reduceToGeometries(t2);
          return this.binaryUnion(e3);
        }, Dr.prototype.unionUsingEnvelopeIntersection = function(t2, e3, n2) {
          var i2 = new Nt(), r2 = this.extractByEnvelope(n2, t2, i2), o2 = this.extractByEnvelope(n2, e3, i2), s2 = this.unionActual(r2, o2);
          i2.add(s2);
          return Pr.combine(i2);
        }, Dr.prototype.bufferUnion = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return t2.get(0).getFactory().buildGeometry(t2).buffer(0);
          }
          if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            return e3.getFactory().createGeometryCollection([e3, n2]).buffer(0);
          }
        }, Dr.prototype.interfaces_ = function() {
          return [];
        }, Dr.prototype.getClass = function() {
          return Dr;
        }, Dr.restrictToPolygons = function(t2) {
          if (T(t2, Zt))
            return t2;
          var e3 = Ni.getPolygons(t2);
          return 1 === e3.size() ? e3.get(0) : t2.getFactory().createMultiPolygon(_e.toPolygonArray(e3));
        }, Dr.getGeometry = function(t2, e3) {
          return e3 >= t2.size() ? null : t2.get(e3);
        }, Dr.union = function(t2) {
          return new Dr(t2).union();
        }, Mr.STRTREE_NODE_CAPACITY.get = function() {
          return 4;
        }, Object.defineProperties(Dr, Mr);
        var Ar = function() {
        };
        Ar.prototype.interfaces_ = function() {
          return [];
        }, Ar.prototype.getClass = function() {
          return Ar;
        }, Ar.union = function(t2, e3) {
          if (t2.isEmpty() || e3.isEmpty()) {
            if (t2.isEmpty() && e3.isEmpty())
              return Lr.createEmptyResult(Lr.UNION, t2, e3, t2.getFactory());
            if (t2.isEmpty())
              return e3.copy();
            if (e3.isEmpty())
              return t2.copy();
          }
          return t2.checkNotGeometryCollection(t2), t2.checkNotGeometryCollection(e3), or.overlayOp(t2, e3, Lr.UNION);
        }, t.GeoJSONReader = Ne, t.GeoJSONWriter = Ce, t.OverlayOp = Lr, t.UnionOp = Ar, t.BufferOp = di, Object.defineProperty(t, "__esModule", { value: true });
      });
    }
  });

  // node_modules/wgs84/index.js
  var require_wgs84 = __commonJS({
    "node_modules/wgs84/index.js"(exports, module) {
      module.exports.RADIUS = 6378137;
      module.exports.FLATTENING = 1 / 298.257223563;
      module.exports.POLAR_RADIUS = 63567523142e-4;
    }
  });

  // node_modules/@mapbox/geojson-area/index.js
  var require_geojson_area = __commonJS({
    "node_modules/@mapbox/geojson-area/index.js"(exports, module) {
      var wgs84 = require_wgs84();
      module.exports.geometry = geometry;
      module.exports.ring = ringArea;
      function geometry(_) {
        var area2 = 0, i;
        switch (_.type) {
          case "Polygon":
            return polygonArea(_.coordinates);
          case "MultiPolygon":
            for (i = 0; i < _.coordinates.length; i++) {
              area2 += polygonArea(_.coordinates[i]);
            }
            return area2;
          case "Point":
          case "MultiPoint":
          case "LineString":
          case "MultiLineString":
            return 0;
          case "GeometryCollection":
            for (i = 0; i < _.geometries.length; i++) {
              area2 += geometry(_.geometries[i]);
            }
            return area2;
        }
      }
      function polygonArea(coords) {
        var area2 = 0;
        if (coords && coords.length > 0) {
          area2 += Math.abs(ringArea(coords[0]));
          for (var i = 1; i < coords.length; i++) {
            area2 -= Math.abs(ringArea(coords[i]));
          }
        }
        return area2;
      }
      function ringArea(coords) {
        var p1, p2, p3, lowerIndex, middleIndex, upperIndex, i, area2 = 0, coordsLength = coords.length;
        if (coordsLength > 2) {
          for (i = 0; i < coordsLength; i++) {
            if (i === coordsLength - 2) {
              lowerIndex = coordsLength - 2;
              middleIndex = coordsLength - 1;
              upperIndex = 0;
            } else if (i === coordsLength - 1) {
              lowerIndex = coordsLength - 1;
              middleIndex = 0;
              upperIndex = 1;
            } else {
              lowerIndex = i;
              middleIndex = i + 1;
              upperIndex = i + 2;
            }
            p1 = coords[lowerIndex];
            p2 = coords[middleIndex];
            p3 = coords[upperIndex];
            area2 += (rad(p3[0]) - rad(p1[0])) * Math.sin(rad(p2[1]));
          }
          area2 = area2 * wgs84.RADIUS * wgs84.RADIUS / 2;
        }
        return area2;
      }
      function rad(_) {
        return _ * Math.PI / 180;
      }
    }
  });

  // node_modules/geojson-rewind/index.js
  var require_geojson_rewind = __commonJS({
    "node_modules/geojson-rewind/index.js"(exports, module) {
      var geojsonArea = require_geojson_area();
      module.exports = rewind2;
      function rewind2(gj, outer) {
        switch (gj && gj.type || null) {
          case "FeatureCollection":
            gj.features = gj.features.map(curryOuter(rewind2, outer));
            return gj;
          case "Feature":
            gj.geometry = rewind2(gj.geometry, outer);
            return gj;
          case "Polygon":
          case "MultiPolygon":
            return correct(gj, outer);
          default:
            return gj;
        }
      }
      function curryOuter(a, b) {
        return function(_) {
          return a(_, b);
        };
      }
      function correct(_, outer) {
        if (_.type === "Polygon") {
          _.coordinates = correctRings(_.coordinates, outer);
        } else if (_.type === "MultiPolygon") {
          _.coordinates = _.coordinates.map(curryOuter(correctRings, outer));
        }
        return _;
      }
      function correctRings(_, outer) {
        outer = !!outer;
        _[0] = wind(_[0], outer);
        for (var i = 1; i < _.length; i++) {
          _[i] = wind(_[i], !outer);
        }
        return _;
      }
      function wind(_, dir) {
        return cw(_) === dir ? _ : _.reverse();
      }
      function cw(_) {
        return geojsonArea.ring(_) >= 0;
      }
    }
  });

  // node_modules/lodash/lodash.min.js
  var require_lodash_min = __commonJS({
    "node_modules/lodash/lodash.min.js"(exports, module) {
      (function() {
        function n(n2, t2, r2) {
          switch (r2.length) {
            case 0:
              return n2.call(t2);
            case 1:
              return n2.call(t2, r2[0]);
            case 2:
              return n2.call(t2, r2[0], r2[1]);
            case 3:
              return n2.call(t2, r2[0], r2[1], r2[2]);
          }
          return n2.apply(t2, r2);
        }
        function t(n2, t2, r2, e3) {
          for (var u2 = -1, i2 = null == n2 ? 0 : n2.length; ++u2 < i2; ) {
            var o2 = n2[u2];
            t2(e3, o2, r2(o2), n2);
          }
          return e3;
        }
        function r(n2, t2) {
          for (var r2 = -1, e3 = null == n2 ? 0 : n2.length; ++r2 < e3 && t2(n2[r2], r2, n2) !== false; )
            ;
          return n2;
        }
        function e(n2, t2) {
          for (var r2 = null == n2 ? 0 : n2.length; r2-- && t2(n2[r2], r2, n2) !== false; )
            ;
          return n2;
        }
        function u(n2, t2) {
          for (var r2 = -1, e3 = null == n2 ? 0 : n2.length; ++r2 < e3; )
            if (!t2(n2[r2], r2, n2))
              return false;
          return true;
        }
        function i(n2, t2) {
          for (var r2 = -1, e3 = null == n2 ? 0 : n2.length, u2 = 0, i2 = []; ++r2 < e3; ) {
            var o2 = n2[r2];
            t2(o2, r2, n2) && (i2[u2++] = o2);
          }
          return i2;
        }
        function o(n2, t2) {
          return !!(null == n2 ? 0 : n2.length) && y2(n2, t2, 0) > -1;
        }
        function f(n2, t2, r2) {
          for (var e3 = -1, u2 = null == n2 ? 0 : n2.length; ++e3 < u2; )
            if (r2(t2, n2[e3]))
              return true;
          return false;
        }
        function c(n2, t2) {
          for (var r2 = -1, e3 = null == n2 ? 0 : n2.length, u2 = Array(e3); ++r2 < e3; )
            u2[r2] = t2(n2[r2], r2, n2);
          return u2;
        }
        function a(n2, t2) {
          for (var r2 = -1, e3 = t2.length, u2 = n2.length; ++r2 < e3; )
            n2[u2 + r2] = t2[r2];
          return n2;
        }
        function l(n2, t2, r2, e3) {
          var u2 = -1, i2 = null == n2 ? 0 : n2.length;
          for (e3 && i2 && (r2 = n2[++u2]); ++u2 < i2; )
            r2 = t2(r2, n2[u2], u2, n2);
          return r2;
        }
        function s(n2, t2, r2, e3) {
          var u2 = null == n2 ? 0 : n2.length;
          for (e3 && u2 && (r2 = n2[--u2]); u2--; )
            r2 = t2(r2, n2[u2], u2, n2);
          return r2;
        }
        function h(n2, t2) {
          for (var r2 = -1, e3 = null == n2 ? 0 : n2.length; ++r2 < e3; )
            if (t2(n2[r2], r2, n2))
              return true;
          return false;
        }
        function p(n2) {
          return n2.split("");
        }
        function _(n2) {
          return n2.match($t) || [];
        }
        function v(n2, t2, r2) {
          var e3;
          return r2(n2, function(n3, r3, u2) {
            if (t2(n3, r3, u2))
              return e3 = r3, false;
          }), e3;
        }
        function g(n2, t2, r2, e3) {
          for (var u2 = n2.length, i2 = r2 + (e3 ? 1 : -1); e3 ? i2-- : ++i2 < u2; )
            if (t2(n2[i2], i2, n2))
              return i2;
          return -1;
        }
        function y2(n2, t2, r2) {
          return t2 === t2 ? Z(n2, t2, r2) : g(n2, b, r2);
        }
        function d(n2, t2, r2, e3) {
          for (var u2 = r2 - 1, i2 = n2.length; ++u2 < i2; )
            if (e3(n2[u2], t2))
              return u2;
          return -1;
        }
        function b(n2) {
          return n2 !== n2;
        }
        function w(n2, t2) {
          var r2 = null == n2 ? 0 : n2.length;
          return r2 ? k(n2, t2) / r2 : Cn;
        }
        function m(n2) {
          return function(t2) {
            return null == t2 ? X : t2[n2];
          };
        }
        function x2(n2) {
          return function(t2) {
            return null == n2 ? X : n2[t2];
          };
        }
        function j(n2, t2, r2, e3, u2) {
          return u2(n2, function(n3, u3, i2) {
            r2 = e3 ? (e3 = false, n3) : t2(r2, n3, u3, i2);
          }), r2;
        }
        function A(n2, t2) {
          var r2 = n2.length;
          for (n2.sort(t2); r2--; )
            n2[r2] = n2[r2].value;
          return n2;
        }
        function k(n2, t2) {
          for (var r2, e3 = -1, u2 = n2.length; ++e3 < u2; ) {
            var i2 = t2(n2[e3]);
            i2 !== X && (r2 = r2 === X ? i2 : r2 + i2);
          }
          return r2;
        }
        function O2(n2, t2) {
          for (var r2 = -1, e3 = Array(n2); ++r2 < n2; )
            e3[r2] = t2(r2);
          return e3;
        }
        function I(n2, t2) {
          return c(t2, function(t3) {
            return [t3, n2[t3]];
          });
        }
        function R(n2) {
          return n2 ? n2.slice(0, H(n2) + 1).replace(Lt, "") : n2;
        }
        function z(n2) {
          return function(t2) {
            return n2(t2);
          };
        }
        function E(n2, t2) {
          return c(t2, function(t3) {
            return n2[t3];
          });
        }
        function S(n2, t2) {
          return n2.has(t2);
        }
        function W(n2, t2) {
          for (var r2 = -1, e3 = n2.length; ++r2 < e3 && y2(t2, n2[r2], 0) > -1; )
            ;
          return r2;
        }
        function L(n2, t2) {
          for (var r2 = n2.length; r2-- && y2(t2, n2[r2], 0) > -1; )
            ;
          return r2;
        }
        function C(n2, t2) {
          for (var r2 = n2.length, e3 = 0; r2--; )
            n2[r2] === t2 && ++e3;
          return e3;
        }
        function U(n2) {
          return "\\" + Yr[n2];
        }
        function B2(n2, t2) {
          return null == n2 ? X : n2[t2];
        }
        function T(n2) {
          return Nr.test(n2);
        }
        function $(n2) {
          return Pr.test(n2);
        }
        function D(n2) {
          for (var t2, r2 = []; !(t2 = n2.next()).done; )
            r2.push(t2.value);
          return r2;
        }
        function M(n2) {
          var t2 = -1, r2 = Array(n2.size);
          return n2.forEach(function(n3, e3) {
            r2[++t2] = [e3, n3];
          }), r2;
        }
        function F(n2, t2) {
          return function(r2) {
            return n2(t2(r2));
          };
        }
        function N(n2, t2) {
          for (var r2 = -1, e3 = n2.length, u2 = 0, i2 = []; ++r2 < e3; ) {
            var o2 = n2[r2];
            o2 !== t2 && o2 !== cn || (n2[r2] = cn, i2[u2++] = r2);
          }
          return i2;
        }
        function P(n2) {
          var t2 = -1, r2 = Array(n2.size);
          return n2.forEach(function(n3) {
            r2[++t2] = n3;
          }), r2;
        }
        function q(n2) {
          var t2 = -1, r2 = Array(n2.size);
          return n2.forEach(function(n3) {
            r2[++t2] = [n3, n3];
          }), r2;
        }
        function Z(n2, t2, r2) {
          for (var e3 = r2 - 1, u2 = n2.length; ++e3 < u2; )
            if (n2[e3] === t2)
              return e3;
          return -1;
        }
        function K(n2, t2, r2) {
          for (var e3 = r2 + 1; e3--; )
            if (n2[e3] === t2)
              return e3;
          return e3;
        }
        function V(n2) {
          return T(n2) ? J(n2) : _e(n2);
        }
        function G(n2) {
          return T(n2) ? Y(n2) : p(n2);
        }
        function H(n2) {
          for (var t2 = n2.length; t2-- && Ct.test(n2.charAt(t2)); )
            ;
          return t2;
        }
        function J(n2) {
          for (var t2 = Mr.lastIndex = 0; Mr.test(n2); )
            ++t2;
          return t2;
        }
        function Y(n2) {
          return n2.match(Mr) || [];
        }
        function Q(n2) {
          return n2.match(Fr) || [];
        }
        var X, nn = "4.17.21", tn = 200, rn = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", en = "Expected a function", un = "Invalid `variable` option passed into `_.template`", on = "__lodash_hash_undefined__", fn = 500, cn = "__lodash_placeholder__", an = 1, ln = 2, sn = 4, hn = 1, pn = 2, _n = 1, vn = 2, gn = 4, yn = 8, dn = 16, bn = 32, wn = 64, mn = 128, xn = 256, jn = 512, An = 30, kn = "...", On = 800, In = 16, Rn = 1, zn = 2, En = 3, Sn = 1 / 0, Wn = 9007199254740991, Ln = 17976931348623157e292, Cn = NaN, Un = 4294967295, Bn = Un - 1, Tn = Un >>> 1, $n = [["ary", mn], ["bind", _n], ["bindKey", vn], ["curry", yn], ["curryRight", dn], ["flip", jn], ["partial", bn], ["partialRight", wn], ["rearg", xn]], Dn = "[object Arguments]", Mn = "[object Array]", Fn = "[object AsyncFunction]", Nn = "[object Boolean]", Pn = "[object Date]", qn = "[object DOMException]", Zn = "[object Error]", Kn = "[object Function]", Vn = "[object GeneratorFunction]", Gn = "[object Map]", Hn = "[object Number]", Jn = "[object Null]", Yn = "[object Object]", Qn = "[object Promise]", Xn = "[object Proxy]", nt = "[object RegExp]", tt = "[object Set]", rt = "[object String]", et = "[object Symbol]", ut = "[object Undefined]", it = "[object WeakMap]", ot = "[object WeakSet]", ft = "[object ArrayBuffer]", ct = "[object DataView]", at = "[object Float32Array]", lt = "[object Float64Array]", st = "[object Int8Array]", ht = "[object Int16Array]", pt = "[object Int32Array]", _t = "[object Uint8Array]", vt = "[object Uint8ClampedArray]", gt = "[object Uint16Array]", yt = "[object Uint32Array]", dt = /\b__p \+= '';/g, bt = /\b(__p \+=) '' \+/g, wt = /(__e\(.*?\)|\b__t\)) \+\n'';/g, mt = /&(?:amp|lt|gt|quot|#39);/g, xt = /[&<>"']/g, jt = RegExp(mt.source), At = RegExp(xt.source), kt = /<%-([\s\S]+?)%>/g, Ot = /<%([\s\S]+?)%>/g, It = /<%=([\s\S]+?)%>/g, Rt = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, zt = /^\w*$/, Et = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, St = /[\\^$.*+?()[\]{}|]/g, Wt = RegExp(St.source), Lt = /^\s+/, Ct = /\s/, Ut = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, Bt = /\{\n\/\* \[wrapped with (.+)\] \*/, Tt = /,? & /, $t = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, Dt = /[()=,{}\[\]\/\s]/, Mt = /\\(\\)?/g, Ft = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Nt = /\w*$/, Pt = /^[-+]0x[0-9a-f]+$/i, qt = /^0b[01]+$/i, Zt = /^\[object .+?Constructor\]$/, Kt = /^0o[0-7]+$/i, Vt = /^(?:0|[1-9]\d*)$/, Gt = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Ht = /($^)/, Jt = /['\n\r\u2028\u2029\\]/g, Yt = "\\ud800-\\udfff", Qt = "\\u0300-\\u036f", Xt = "\\ufe20-\\ufe2f", nr = "\\u20d0-\\u20ff", tr = Qt + Xt + nr, rr = "\\u2700-\\u27bf", er = "a-z\\xdf-\\xf6\\xf8-\\xff", ur = "\\xac\\xb1\\xd7\\xf7", ir = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", or = "\\u2000-\\u206f", fr = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", cr = "A-Z\\xc0-\\xd6\\xd8-\\xde", ar = "\\ufe0e\\ufe0f", lr = ur + ir + or + fr, sr = "['\u2019]", hr = "[" + Yt + "]", pr = "[" + lr + "]", _r = "[" + tr + "]", vr = "\\d+", gr = "[" + rr + "]", yr = "[" + er + "]", dr = "[^" + Yt + lr + vr + rr + er + cr + "]", br = "\\ud83c[\\udffb-\\udfff]", wr = "(?:" + _r + "|" + br + ")", mr = "[^" + Yt + "]", xr = "(?:\\ud83c[\\udde6-\\uddff]){2}", jr = "[\\ud800-\\udbff][\\udc00-\\udfff]", Ar = "[" + cr + "]", kr = "\\u200d", Or = "(?:" + yr + "|" + dr + ")", Ir = "(?:" + Ar + "|" + dr + ")", Rr = "(?:" + sr + "(?:d|ll|m|re|s|t|ve))?", zr = "(?:" + sr + "(?:D|LL|M|RE|S|T|VE))?", Er = wr + "?", Sr = "[" + ar + "]?", Wr = "(?:" + kr + "(?:" + [mr, xr, jr].join("|") + ")" + Sr + Er + ")*", Lr = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", Cr = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", Ur = Sr + Er + Wr, Br = "(?:" + [gr, xr, jr].join("|") + ")" + Ur, Tr = "(?:" + [mr + _r + "?", _r, xr, jr, hr].join("|") + ")", $r = RegExp(sr, "g"), Dr = RegExp(_r, "g"), Mr = RegExp(br + "(?=" + br + ")|" + Tr + Ur, "g"), Fr = RegExp([Ar + "?" + yr + "+" + Rr + "(?=" + [pr, Ar, "$"].join("|") + ")", Ir + "+" + zr + "(?=" + [pr, Ar + Or, "$"].join("|") + ")", Ar + "?" + Or + "+" + Rr, Ar + "+" + zr, Cr, Lr, vr, Br].join("|"), "g"), Nr = RegExp("[" + kr + Yt + tr + ar + "]"), Pr = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, qr = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"], Zr = -1, Kr = {};
        Kr[at] = Kr[lt] = Kr[st] = Kr[ht] = Kr[pt] = Kr[_t] = Kr[vt] = Kr[gt] = Kr[yt] = true, Kr[Dn] = Kr[Mn] = Kr[ft] = Kr[Nn] = Kr[ct] = Kr[Pn] = Kr[Zn] = Kr[Kn] = Kr[Gn] = Kr[Hn] = Kr[Yn] = Kr[nt] = Kr[tt] = Kr[rt] = Kr[it] = false;
        var Vr = {};
        Vr[Dn] = Vr[Mn] = Vr[ft] = Vr[ct] = Vr[Nn] = Vr[Pn] = Vr[at] = Vr[lt] = Vr[st] = Vr[ht] = Vr[pt] = Vr[Gn] = Vr[Hn] = Vr[Yn] = Vr[nt] = Vr[tt] = Vr[rt] = Vr[et] = Vr[_t] = Vr[vt] = Vr[gt] = Vr[yt] = true, Vr[Zn] = Vr[Kn] = Vr[it] = false;
        var Gr = {
          "\xC0": "A",
          "\xC1": "A",
          "\xC2": "A",
          "\xC3": "A",
          "\xC4": "A",
          "\xC5": "A",
          "\xE0": "a",
          "\xE1": "a",
          "\xE2": "a",
          "\xE3": "a",
          "\xE4": "a",
          "\xE5": "a",
          "\xC7": "C",
          "\xE7": "c",
          "\xD0": "D",
          "\xF0": "d",
          "\xC8": "E",
          "\xC9": "E",
          "\xCA": "E",
          "\xCB": "E",
          "\xE8": "e",
          "\xE9": "e",
          "\xEA": "e",
          "\xEB": "e",
          "\xCC": "I",
          "\xCD": "I",
          "\xCE": "I",
          "\xCF": "I",
          "\xEC": "i",
          "\xED": "i",
          "\xEE": "i",
          "\xEF": "i",
          "\xD1": "N",
          "\xF1": "n",
          "\xD2": "O",
          "\xD3": "O",
          "\xD4": "O",
          "\xD5": "O",
          "\xD6": "O",
          "\xD8": "O",
          "\xF2": "o",
          "\xF3": "o",
          "\xF4": "o",
          "\xF5": "o",
          "\xF6": "o",
          "\xF8": "o",
          "\xD9": "U",
          "\xDA": "U",
          "\xDB": "U",
          "\xDC": "U",
          "\xF9": "u",
          "\xFA": "u",
          "\xFB": "u",
          "\xFC": "u",
          "\xDD": "Y",
          "\xFD": "y",
          "\xFF": "y",
          "\xC6": "Ae",
          "\xE6": "ae",
          "\xDE": "Th",
          "\xFE": "th",
          "\xDF": "ss",
          "\u0100": "A",
          "\u0102": "A",
          "\u0104": "A",
          "\u0101": "a",
          "\u0103": "a",
          "\u0105": "a",
          "\u0106": "C",
          "\u0108": "C",
          "\u010A": "C",
          "\u010C": "C",
          "\u0107": "c",
          "\u0109": "c",
          "\u010B": "c",
          "\u010D": "c",
          "\u010E": "D",
          "\u0110": "D",
          "\u010F": "d",
          "\u0111": "d",
          "\u0112": "E",
          "\u0114": "E",
          "\u0116": "E",
          "\u0118": "E",
          "\u011A": "E",
          "\u0113": "e",
          "\u0115": "e",
          "\u0117": "e",
          "\u0119": "e",
          "\u011B": "e",
          "\u011C": "G",
          "\u011E": "G",
          "\u0120": "G",
          "\u0122": "G",
          "\u011D": "g",
          "\u011F": "g",
          "\u0121": "g",
          "\u0123": "g",
          "\u0124": "H",
          "\u0126": "H",
          "\u0125": "h",
          "\u0127": "h",
          "\u0128": "I",
          "\u012A": "I",
          "\u012C": "I",
          "\u012E": "I",
          "\u0130": "I",
          "\u0129": "i",
          "\u012B": "i",
          "\u012D": "i",
          "\u012F": "i",
          "\u0131": "i",
          "\u0134": "J",
          "\u0135": "j",
          "\u0136": "K",
          "\u0137": "k",
          "\u0138": "k",
          "\u0139": "L",
          "\u013B": "L",
          "\u013D": "L",
          "\u013F": "L",
          "\u0141": "L",
          "\u013A": "l",
          "\u013C": "l",
          "\u013E": "l",
          "\u0140": "l",
          "\u0142": "l",
          "\u0143": "N",
          "\u0145": "N",
          "\u0147": "N",
          "\u014A": "N",
          "\u0144": "n",
          "\u0146": "n",
          "\u0148": "n",
          "\u014B": "n",
          "\u014C": "O",
          "\u014E": "O",
          "\u0150": "O",
          "\u014D": "o",
          "\u014F": "o",
          "\u0151": "o",
          "\u0154": "R",
          "\u0156": "R",
          "\u0158": "R",
          "\u0155": "r",
          "\u0157": "r",
          "\u0159": "r",
          "\u015A": "S",
          "\u015C": "S",
          "\u015E": "S",
          "\u0160": "S",
          "\u015B": "s",
          "\u015D": "s",
          "\u015F": "s",
          "\u0161": "s",
          "\u0162": "T",
          "\u0164": "T",
          "\u0166": "T",
          "\u0163": "t",
          "\u0165": "t",
          "\u0167": "t",
          "\u0168": "U",
          "\u016A": "U",
          "\u016C": "U",
          "\u016E": "U",
          "\u0170": "U",
          "\u0172": "U",
          "\u0169": "u",
          "\u016B": "u",
          "\u016D": "u",
          "\u016F": "u",
          "\u0171": "u",
          "\u0173": "u",
          "\u0174": "W",
          "\u0175": "w",
          "\u0176": "Y",
          "\u0177": "y",
          "\u0178": "Y",
          "\u0179": "Z",
          "\u017B": "Z",
          "\u017D": "Z",
          "\u017A": "z",
          "\u017C": "z",
          "\u017E": "z",
          "\u0132": "IJ",
          "\u0133": "ij",
          "\u0152": "Oe",
          "\u0153": "oe",
          "\u0149": "'n",
          "\u017F": "s"
        }, Hr = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, Jr = { "&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": '"', "&#39;": "'" }, Yr = { "\\": "\\", "'": "'", "\n": "n", "\r": "r", "\u2028": "u2028", "\u2029": "u2029" }, Qr = parseFloat, Xr = parseInt, ne = "object" == typeof global && global && global.Object === Object && global, te = "object" == typeof self && self && self.Object === Object && self, re = ne || te || Function("return this")(), ee = "object" == typeof exports && exports && !exports.nodeType && exports, ue = ee && "object" == typeof module && module && !module.nodeType && module, ie = ue && ue.exports === ee, oe = ie && ne.process, fe = function() {
          try {
            var n2 = ue && ue.require && ue.require("util").types;
            return n2 ? n2 : oe && oe.binding && oe.binding("util");
          } catch (n3) {
          }
        }(), ce = fe && fe.isArrayBuffer, ae = fe && fe.isDate, le = fe && fe.isMap, se = fe && fe.isRegExp, he = fe && fe.isSet, pe = fe && fe.isTypedArray, _e = m("length"), ve = x2(Gr), ge = x2(Hr), ye = x2(Jr), de = function p2(x3) {
          function Z2(n2) {
            if (cc(n2) && !bh(n2) && !(n2 instanceof Ct2)) {
              if (n2 instanceof Y2)
                return n2;
              if (bl.call(n2, "__wrapped__"))
                return eo(n2);
            }
            return new Y2(n2);
          }
          function J2() {
          }
          function Y2(n2, t2) {
            this.__wrapped__ = n2, this.__actions__ = [], this.__chain__ = !!t2, this.__index__ = 0, this.__values__ = X;
          }
          function Ct2(n2) {
            this.__wrapped__ = n2, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = false, this.__iteratees__ = [], this.__takeCount__ = Un, this.__views__ = [];
          }
          function $t2() {
            var n2 = new Ct2(this.__wrapped__);
            return n2.__actions__ = Tu(this.__actions__), n2.__dir__ = this.__dir__, n2.__filtered__ = this.__filtered__, n2.__iteratees__ = Tu(this.__iteratees__), n2.__takeCount__ = this.__takeCount__, n2.__views__ = Tu(this.__views__), n2;
          }
          function Yt2() {
            if (this.__filtered__) {
              var n2 = new Ct2(this);
              n2.__dir__ = -1, n2.__filtered__ = true;
            } else
              n2 = this.clone(), n2.__dir__ *= -1;
            return n2;
          }
          function Qt2() {
            var n2 = this.__wrapped__.value(), t2 = this.__dir__, r2 = bh(n2), e3 = t2 < 0, u2 = r2 ? n2.length : 0, i2 = Oi(0, u2, this.__views__), o2 = i2.start, f2 = i2.end, c2 = f2 - o2, a2 = e3 ? f2 : o2 - 1, l2 = this.__iteratees__, s2 = l2.length, h2 = 0, p3 = Hl(c2, this.__takeCount__);
            if (!r2 || !e3 && u2 == c2 && p3 == c2)
              return wu(n2, this.__actions__);
            var _2 = [];
            n:
              for (; c2-- && h2 < p3; ) {
                a2 += t2;
                for (var v2 = -1, g2 = n2[a2]; ++v2 < s2; ) {
                  var y3 = l2[v2], d2 = y3.iteratee, b2 = y3.type, w2 = d2(g2);
                  if (b2 == zn)
                    g2 = w2;
                  else if (!w2) {
                    if (b2 == Rn)
                      continue n;
                    break n;
                  }
                }
                _2[h2++] = g2;
              }
            return _2;
          }
          function Xt2(n2) {
            var t2 = -1, r2 = null == n2 ? 0 : n2.length;
            for (this.clear(); ++t2 < r2; ) {
              var e3 = n2[t2];
              this.set(e3[0], e3[1]);
            }
          }
          function nr2() {
            this.__data__ = is ? is(null) : {}, this.size = 0;
          }
          function tr2(n2) {
            var t2 = this.has(n2) && delete this.__data__[n2];
            return this.size -= t2 ? 1 : 0, t2;
          }
          function rr2(n2) {
            var t2 = this.__data__;
            if (is) {
              var r2 = t2[n2];
              return r2 === on ? X : r2;
            }
            return bl.call(t2, n2) ? t2[n2] : X;
          }
          function er2(n2) {
            var t2 = this.__data__;
            return is ? t2[n2] !== X : bl.call(t2, n2);
          }
          function ur2(n2, t2) {
            var r2 = this.__data__;
            return this.size += this.has(n2) ? 0 : 1, r2[n2] = is && t2 === X ? on : t2, this;
          }
          function ir2(n2) {
            var t2 = -1, r2 = null == n2 ? 0 : n2.length;
            for (this.clear(); ++t2 < r2; ) {
              var e3 = n2[t2];
              this.set(e3[0], e3[1]);
            }
          }
          function or2() {
            this.__data__ = [], this.size = 0;
          }
          function fr2(n2) {
            var t2 = this.__data__, r2 = Wr2(t2, n2);
            return !(r2 < 0) && (r2 == t2.length - 1 ? t2.pop() : Ll.call(t2, r2, 1), --this.size, true);
          }
          function cr2(n2) {
            var t2 = this.__data__, r2 = Wr2(t2, n2);
            return r2 < 0 ? X : t2[r2][1];
          }
          function ar2(n2) {
            return Wr2(this.__data__, n2) > -1;
          }
          function lr2(n2, t2) {
            var r2 = this.__data__, e3 = Wr2(r2, n2);
            return e3 < 0 ? (++this.size, r2.push([n2, t2])) : r2[e3][1] = t2, this;
          }
          function sr2(n2) {
            var t2 = -1, r2 = null == n2 ? 0 : n2.length;
            for (this.clear(); ++t2 < r2; ) {
              var e3 = n2[t2];
              this.set(e3[0], e3[1]);
            }
          }
          function hr2() {
            this.size = 0, this.__data__ = { hash: new Xt2(), map: new (ts || ir2)(), string: new Xt2() };
          }
          function pr2(n2) {
            var t2 = xi(this, n2).delete(n2);
            return this.size -= t2 ? 1 : 0, t2;
          }
          function _r2(n2) {
            return xi(this, n2).get(n2);
          }
          function vr2(n2) {
            return xi(this, n2).has(n2);
          }
          function gr2(n2, t2) {
            var r2 = xi(this, n2), e3 = r2.size;
            return r2.set(n2, t2), this.size += r2.size == e3 ? 0 : 1, this;
          }
          function yr2(n2) {
            var t2 = -1, r2 = null == n2 ? 0 : n2.length;
            for (this.__data__ = new sr2(); ++t2 < r2; )
              this.add(n2[t2]);
          }
          function dr2(n2) {
            return this.__data__.set(n2, on), this;
          }
          function br2(n2) {
            return this.__data__.has(n2);
          }
          function wr2(n2) {
            this.size = (this.__data__ = new ir2(n2)).size;
          }
          function mr2() {
            this.__data__ = new ir2(), this.size = 0;
          }
          function xr2(n2) {
            var t2 = this.__data__, r2 = t2.delete(n2);
            return this.size = t2.size, r2;
          }
          function jr2(n2) {
            return this.__data__.get(n2);
          }
          function Ar2(n2) {
            return this.__data__.has(n2);
          }
          function kr2(n2, t2) {
            var r2 = this.__data__;
            if (r2 instanceof ir2) {
              var e3 = r2.__data__;
              if (!ts || e3.length < tn - 1)
                return e3.push([n2, t2]), this.size = ++r2.size, this;
              r2 = this.__data__ = new sr2(e3);
            }
            return r2.set(n2, t2), this.size = r2.size, this;
          }
          function Or2(n2, t2) {
            var r2 = bh(n2), e3 = !r2 && dh(n2), u2 = !r2 && !e3 && mh(n2), i2 = !r2 && !e3 && !u2 && Oh(n2), o2 = r2 || e3 || u2 || i2, f2 = o2 ? O2(n2.length, hl) : [], c2 = f2.length;
            for (var a2 in n2)
              !t2 && !bl.call(n2, a2) || o2 && ("length" == a2 || u2 && ("offset" == a2 || "parent" == a2) || i2 && ("buffer" == a2 || "byteLength" == a2 || "byteOffset" == a2) || Ci(a2, c2)) || f2.push(a2);
            return f2;
          }
          function Ir2(n2) {
            var t2 = n2.length;
            return t2 ? n2[tu(0, t2 - 1)] : X;
          }
          function Rr2(n2, t2) {
            return Xi(Tu(n2), Mr2(t2, 0, n2.length));
          }
          function zr2(n2) {
            return Xi(Tu(n2));
          }
          function Er2(n2, t2, r2) {
            (r2 === X || Gf(n2[t2], r2)) && (r2 !== X || t2 in n2) || Br2(n2, t2, r2);
          }
          function Sr2(n2, t2, r2) {
            var e3 = n2[t2];
            bl.call(n2, t2) && Gf(e3, r2) && (r2 !== X || t2 in n2) || Br2(n2, t2, r2);
          }
          function Wr2(n2, t2) {
            for (var r2 = n2.length; r2--; )
              if (Gf(n2[r2][0], t2))
                return r2;
            return -1;
          }
          function Lr2(n2, t2, r2, e3) {
            return ys(n2, function(n3, u2, i2) {
              t2(e3, n3, r2(n3), i2);
            }), e3;
          }
          function Cr2(n2, t2) {
            return n2 && $u(t2, Pc(t2), n2);
          }
          function Ur2(n2, t2) {
            return n2 && $u(t2, qc(t2), n2);
          }
          function Br2(n2, t2, r2) {
            "__proto__" == t2 && Tl ? Tl(n2, t2, { configurable: true, enumerable: true, value: r2, writable: true }) : n2[t2] = r2;
          }
          function Tr2(n2, t2) {
            for (var r2 = -1, e3 = t2.length, u2 = il(e3), i2 = null == n2; ++r2 < e3; )
              u2[r2] = i2 ? X : Mc(n2, t2[r2]);
            return u2;
          }
          function Mr2(n2, t2, r2) {
            return n2 === n2 && (r2 !== X && (n2 = n2 <= r2 ? n2 : r2), t2 !== X && (n2 = n2 >= t2 ? n2 : t2)), n2;
          }
          function Fr2(n2, t2, e3, u2, i2, o2) {
            var f2, c2 = t2 & an, a2 = t2 & ln, l2 = t2 & sn;
            if (e3 && (f2 = i2 ? e3(n2, u2, i2, o2) : e3(n2)), f2 !== X)
              return f2;
            if (!fc(n2))
              return n2;
            var s2 = bh(n2);
            if (s2) {
              if (f2 = zi(n2), !c2)
                return Tu(n2, f2);
            } else {
              var h2 = zs(n2), p3 = h2 == Kn || h2 == Vn;
              if (mh(n2))
                return Iu(n2, c2);
              if (h2 == Yn || h2 == Dn || p3 && !i2) {
                if (f2 = a2 || p3 ? {} : Ei(n2), !c2)
                  return a2 ? Mu(n2, Ur2(f2, n2)) : Du(n2, Cr2(f2, n2));
              } else {
                if (!Vr[h2])
                  return i2 ? n2 : {};
                f2 = Si(n2, h2, c2);
              }
            }
            o2 || (o2 = new wr2());
            var _2 = o2.get(n2);
            if (_2)
              return _2;
            o2.set(n2, f2), kh(n2) ? n2.forEach(function(r2) {
              f2.add(Fr2(r2, t2, e3, r2, n2, o2));
            }) : jh(n2) && n2.forEach(function(r2, u3) {
              f2.set(u3, Fr2(r2, t2, e3, u3, n2, o2));
            });
            var v2 = l2 ? a2 ? di : yi : a2 ? qc : Pc, g2 = s2 ? X : v2(n2);
            return r(g2 || n2, function(r2, u3) {
              g2 && (u3 = r2, r2 = n2[u3]), Sr2(f2, u3, Fr2(r2, t2, e3, u3, n2, o2));
            }), f2;
          }
          function Nr2(n2) {
            var t2 = Pc(n2);
            return function(r2) {
              return Pr2(r2, n2, t2);
            };
          }
          function Pr2(n2, t2, r2) {
            var e3 = r2.length;
            if (null == n2)
              return !e3;
            for (n2 = ll(n2); e3--; ) {
              var u2 = r2[e3], i2 = t2[u2], o2 = n2[u2];
              if (o2 === X && !(u2 in n2) || !i2(o2))
                return false;
            }
            return true;
          }
          function Gr2(n2, t2, r2) {
            if ("function" != typeof n2)
              throw new pl(en);
            return Ws(function() {
              n2.apply(X, r2);
            }, t2);
          }
          function Hr2(n2, t2, r2, e3) {
            var u2 = -1, i2 = o, a2 = true, l2 = n2.length, s2 = [], h2 = t2.length;
            if (!l2)
              return s2;
            r2 && (t2 = c(t2, z(r2))), e3 ? (i2 = f, a2 = false) : t2.length >= tn && (i2 = S, a2 = false, t2 = new yr2(t2));
            n:
              for (; ++u2 < l2; ) {
                var p3 = n2[u2], _2 = null == r2 ? p3 : r2(p3);
                if (p3 = e3 || 0 !== p3 ? p3 : 0, a2 && _2 === _2) {
                  for (var v2 = h2; v2--; )
                    if (t2[v2] === _2)
                      continue n;
                  s2.push(p3);
                } else
                  i2(t2, _2, e3) || s2.push(p3);
              }
            return s2;
          }
          function Jr2(n2, t2) {
            var r2 = true;
            return ys(n2, function(n3, e3, u2) {
              return r2 = !!t2(n3, e3, u2);
            }), r2;
          }
          function Yr2(n2, t2, r2) {
            for (var e3 = -1, u2 = n2.length; ++e3 < u2; ) {
              var i2 = n2[e3], o2 = t2(i2);
              if (null != o2 && (f2 === X ? o2 === o2 && !bc(o2) : r2(o2, f2)))
                var f2 = o2, c2 = i2;
            }
            return c2;
          }
          function ne2(n2, t2, r2, e3) {
            var u2 = n2.length;
            for (r2 = kc(r2), r2 < 0 && (r2 = -r2 > u2 ? 0 : u2 + r2), e3 = e3 === X || e3 > u2 ? u2 : kc(e3), e3 < 0 && (e3 += u2), e3 = r2 > e3 ? 0 : Oc(e3); r2 < e3; )
              n2[r2++] = t2;
            return n2;
          }
          function te2(n2, t2) {
            var r2 = [];
            return ys(n2, function(n3, e3, u2) {
              t2(n3, e3, u2) && r2.push(n3);
            }), r2;
          }
          function ee2(n2, t2, r2, e3, u2) {
            var i2 = -1, o2 = n2.length;
            for (r2 || (r2 = Li), u2 || (u2 = []); ++i2 < o2; ) {
              var f2 = n2[i2];
              t2 > 0 && r2(f2) ? t2 > 1 ? ee2(f2, t2 - 1, r2, e3, u2) : a(u2, f2) : e3 || (u2[u2.length] = f2);
            }
            return u2;
          }
          function ue2(n2, t2) {
            return n2 && bs(n2, t2, Pc);
          }
          function oe2(n2, t2) {
            return n2 && ws(n2, t2, Pc);
          }
          function fe2(n2, t2) {
            return i(t2, function(t3) {
              return uc(n2[t3]);
            });
          }
          function _e2(n2, t2) {
            t2 = ku(t2, n2);
            for (var r2 = 0, e3 = t2.length; null != n2 && r2 < e3; )
              n2 = n2[no(t2[r2++])];
            return r2 && r2 == e3 ? n2 : X;
          }
          function de2(n2, t2, r2) {
            var e3 = t2(n2);
            return bh(n2) ? e3 : a(e3, r2(n2));
          }
          function we(n2) {
            return null == n2 ? n2 === X ? ut : Jn : Bl && Bl in ll(n2) ? ki(n2) : Ki(n2);
          }
          function me(n2, t2) {
            return n2 > t2;
          }
          function xe(n2, t2) {
            return null != n2 && bl.call(n2, t2);
          }
          function je(n2, t2) {
            return null != n2 && t2 in ll(n2);
          }
          function Ae(n2, t2, r2) {
            return n2 >= Hl(t2, r2) && n2 < Gl(t2, r2);
          }
          function ke(n2, t2, r2) {
            for (var e3 = r2 ? f : o, u2 = n2[0].length, i2 = n2.length, a2 = i2, l2 = il(i2), s2 = 1 / 0, h2 = []; a2--; ) {
              var p3 = n2[a2];
              a2 && t2 && (p3 = c(p3, z(t2))), s2 = Hl(p3.length, s2), l2[a2] = !r2 && (t2 || u2 >= 120 && p3.length >= 120) ? new yr2(a2 && p3) : X;
            }
            p3 = n2[0];
            var _2 = -1, v2 = l2[0];
            n:
              for (; ++_2 < u2 && h2.length < s2; ) {
                var g2 = p3[_2], y3 = t2 ? t2(g2) : g2;
                if (g2 = r2 || 0 !== g2 ? g2 : 0, !(v2 ? S(v2, y3) : e3(h2, y3, r2))) {
                  for (a2 = i2; --a2; ) {
                    var d2 = l2[a2];
                    if (!(d2 ? S(d2, y3) : e3(n2[a2], y3, r2)))
                      continue n;
                  }
                  v2 && v2.push(y3), h2.push(g2);
                }
              }
            return h2;
          }
          function Oe(n2, t2, r2, e3) {
            return ue2(n2, function(n3, u2, i2) {
              t2(e3, r2(n3), u2, i2);
            }), e3;
          }
          function Ie(t2, r2, e3) {
            r2 = ku(r2, t2), t2 = Gi(t2, r2);
            var u2 = null == t2 ? t2 : t2[no(jo(r2))];
            return null == u2 ? X : n(u2, t2, e3);
          }
          function Re(n2) {
            return cc(n2) && we(n2) == Dn;
          }
          function ze(n2) {
            return cc(n2) && we(n2) == ft;
          }
          function Ee(n2) {
            return cc(n2) && we(n2) == Pn;
          }
          function Se(n2, t2, r2, e3, u2) {
            return n2 === t2 || (null == n2 || null == t2 || !cc(n2) && !cc(t2) ? n2 !== n2 && t2 !== t2 : We(n2, t2, r2, e3, Se, u2));
          }
          function We(n2, t2, r2, e3, u2, i2) {
            var o2 = bh(n2), f2 = bh(t2), c2 = o2 ? Mn : zs(n2), a2 = f2 ? Mn : zs(t2);
            c2 = c2 == Dn ? Yn : c2, a2 = a2 == Dn ? Yn : a2;
            var l2 = c2 == Yn, s2 = a2 == Yn, h2 = c2 == a2;
            if (h2 && mh(n2)) {
              if (!mh(t2))
                return false;
              o2 = true, l2 = false;
            }
            if (h2 && !l2)
              return i2 || (i2 = new wr2()), o2 || Oh(n2) ? pi3(n2, t2, r2, e3, u2, i2) : _i(n2, t2, c2, r2, e3, u2, i2);
            if (!(r2 & hn)) {
              var p3 = l2 && bl.call(n2, "__wrapped__"), _2 = s2 && bl.call(t2, "__wrapped__");
              if (p3 || _2) {
                var v2 = p3 ? n2.value() : n2, g2 = _2 ? t2.value() : t2;
                return i2 || (i2 = new wr2()), u2(v2, g2, r2, e3, i2);
              }
            }
            return !!h2 && (i2 || (i2 = new wr2()), vi(n2, t2, r2, e3, u2, i2));
          }
          function Le(n2) {
            return cc(n2) && zs(n2) == Gn;
          }
          function Ce(n2, t2, r2, e3) {
            var u2 = r2.length, i2 = u2, o2 = !e3;
            if (null == n2)
              return !i2;
            for (n2 = ll(n2); u2--; ) {
              var f2 = r2[u2];
              if (o2 && f2[2] ? f2[1] !== n2[f2[0]] : !(f2[0] in n2))
                return false;
            }
            for (; ++u2 < i2; ) {
              f2 = r2[u2];
              var c2 = f2[0], a2 = n2[c2], l2 = f2[1];
              if (o2 && f2[2]) {
                if (a2 === X && !(c2 in n2))
                  return false;
              } else {
                var s2 = new wr2();
                if (e3)
                  var h2 = e3(a2, l2, c2, n2, t2, s2);
                if (!(h2 === X ? Se(l2, a2, hn | pn, e3, s2) : h2))
                  return false;
              }
            }
            return true;
          }
          function Ue(n2) {
            return !(!fc(n2) || Di(n2)) && (uc(n2) ? kl : Zt).test(to(n2));
          }
          function Be(n2) {
            return cc(n2) && we(n2) == nt;
          }
          function Te(n2) {
            return cc(n2) && zs(n2) == tt;
          }
          function $e(n2) {
            return cc(n2) && oc(n2.length) && !!Kr[we(n2)];
          }
          function De(n2) {
            return "function" == typeof n2 ? n2 : null == n2 ? La : "object" == typeof n2 ? bh(n2) ? Ze(n2[0], n2[1]) : qe(n2) : Fa(n2);
          }
          function Me(n2) {
            if (!Mi(n2))
              return Vl(n2);
            var t2 = [];
            for (var r2 in ll(n2))
              bl.call(n2, r2) && "constructor" != r2 && t2.push(r2);
            return t2;
          }
          function Fe(n2) {
            if (!fc(n2))
              return Zi(n2);
            var t2 = Mi(n2), r2 = [];
            for (var e3 in n2)
              ("constructor" != e3 || !t2 && bl.call(n2, e3)) && r2.push(e3);
            return r2;
          }
          function Ne(n2, t2) {
            return n2 < t2;
          }
          function Pe(n2, t2) {
            var r2 = -1, e3 = Hf(n2) ? il(n2.length) : [];
            return ys(n2, function(n3, u2, i2) {
              e3[++r2] = t2(n3, u2, i2);
            }), e3;
          }
          function qe(n2) {
            var t2 = ji(n2);
            return 1 == t2.length && t2[0][2] ? Ni(t2[0][0], t2[0][1]) : function(r2) {
              return r2 === n2 || Ce(r2, n2, t2);
            };
          }
          function Ze(n2, t2) {
            return Bi(n2) && Fi(t2) ? Ni(no(n2), t2) : function(r2) {
              var e3 = Mc(r2, n2);
              return e3 === X && e3 === t2 ? Nc(r2, n2) : Se(t2, e3, hn | pn);
            };
          }
          function Ke(n2, t2, r2, e3, u2) {
            n2 !== t2 && bs(t2, function(i2, o2) {
              if (u2 || (u2 = new wr2()), fc(i2))
                Ve(n2, t2, o2, r2, Ke, e3, u2);
              else {
                var f2 = e3 ? e3(Ji(n2, o2), i2, o2 + "", n2, t2, u2) : X;
                f2 === X && (f2 = i2), Er2(n2, o2, f2);
              }
            }, qc);
          }
          function Ve(n2, t2, r2, e3, u2, i2, o2) {
            var f2 = Ji(n2, r2), c2 = Ji(t2, r2), a2 = o2.get(c2);
            if (a2)
              return Er2(n2, r2, a2), X;
            var l2 = i2 ? i2(f2, c2, r2 + "", n2, t2, o2) : X, s2 = l2 === X;
            if (s2) {
              var h2 = bh(c2), p3 = !h2 && mh(c2), _2 = !h2 && !p3 && Oh(c2);
              l2 = c2, h2 || p3 || _2 ? bh(f2) ? l2 = f2 : Jf(f2) ? l2 = Tu(f2) : p3 ? (s2 = false, l2 = Iu(c2, true)) : _2 ? (s2 = false, l2 = Wu(c2, true)) : l2 = [] : gc(c2) || dh(c2) ? (l2 = f2, dh(f2) ? l2 = Rc(f2) : fc(f2) && !uc(f2) || (l2 = Ei(c2))) : s2 = false;
            }
            s2 && (o2.set(c2, l2), u2(l2, c2, e3, i2, o2), o2.delete(c2)), Er2(n2, r2, l2);
          }
          function Ge(n2, t2) {
            var r2 = n2.length;
            if (r2)
              return t2 += t2 < 0 ? r2 : 0, Ci(t2, r2) ? n2[t2] : X;
          }
          function He(n2, t2, r2) {
            t2 = t2.length ? c(t2, function(n3) {
              return bh(n3) ? function(t3) {
                return _e2(t3, 1 === n3.length ? n3[0] : n3);
              } : n3;
            }) : [La];
            var e3 = -1;
            return t2 = c(t2, z(mi())), A(Pe(n2, function(n3, r3, u2) {
              return { criteria: c(t2, function(t3) {
                return t3(n3);
              }), index: ++e3, value: n3 };
            }), function(n3, t3) {
              return Cu(n3, t3, r2);
            });
          }
          function Je(n2, t2) {
            return Ye(n2, t2, function(t3, r2) {
              return Nc(n2, r2);
            });
          }
          function Ye(n2, t2, r2) {
            for (var e3 = -1, u2 = t2.length, i2 = {}; ++e3 < u2; ) {
              var o2 = t2[e3], f2 = _e2(n2, o2);
              r2(f2, o2) && fu(i2, ku(o2, n2), f2);
            }
            return i2;
          }
          function Qe(n2) {
            return function(t2) {
              return _e2(t2, n2);
            };
          }
          function Xe(n2, t2, r2, e3) {
            var u2 = e3 ? d : y2, i2 = -1, o2 = t2.length, f2 = n2;
            for (n2 === t2 && (t2 = Tu(t2)), r2 && (f2 = c(n2, z(r2))); ++i2 < o2; )
              for (var a2 = 0, l2 = t2[i2], s2 = r2 ? r2(l2) : l2; (a2 = u2(f2, s2, a2, e3)) > -1; )
                f2 !== n2 && Ll.call(f2, a2, 1), Ll.call(n2, a2, 1);
            return n2;
          }
          function nu(n2, t2) {
            for (var r2 = n2 ? t2.length : 0, e3 = r2 - 1; r2--; ) {
              var u2 = t2[r2];
              if (r2 == e3 || u2 !== i2) {
                var i2 = u2;
                Ci(u2) ? Ll.call(n2, u2, 1) : yu(n2, u2);
              }
            }
            return n2;
          }
          function tu(n2, t2) {
            return n2 + Nl(Ql() * (t2 - n2 + 1));
          }
          function ru(n2, t2, r2, e3) {
            for (var u2 = -1, i2 = Gl(Fl((t2 - n2) / (r2 || 1)), 0), o2 = il(i2); i2--; )
              o2[e3 ? i2 : ++u2] = n2, n2 += r2;
            return o2;
          }
          function eu(n2, t2) {
            var r2 = "";
            if (!n2 || t2 < 1 || t2 > Wn)
              return r2;
            do
              t2 % 2 && (r2 += n2), t2 = Nl(t2 / 2), t2 && (n2 += n2);
            while (t2);
            return r2;
          }
          function uu(n2, t2) {
            return Ls(Vi(n2, t2, La), n2 + "");
          }
          function iu(n2) {
            return Ir2(ra(n2));
          }
          function ou(n2, t2) {
            var r2 = ra(n2);
            return Xi(r2, Mr2(t2, 0, r2.length));
          }
          function fu(n2, t2, r2, e3) {
            if (!fc(n2))
              return n2;
            t2 = ku(t2, n2);
            for (var u2 = -1, i2 = t2.length, o2 = i2 - 1, f2 = n2; null != f2 && ++u2 < i2; ) {
              var c2 = no(t2[u2]), a2 = r2;
              if ("__proto__" === c2 || "constructor" === c2 || "prototype" === c2)
                return n2;
              if (u2 != o2) {
                var l2 = f2[c2];
                a2 = e3 ? e3(l2, c2, f2) : X, a2 === X && (a2 = fc(l2) ? l2 : Ci(t2[u2 + 1]) ? [] : {});
              }
              Sr2(f2, c2, a2), f2 = f2[c2];
            }
            return n2;
          }
          function cu(n2) {
            return Xi(ra(n2));
          }
          function au(n2, t2, r2) {
            var e3 = -1, u2 = n2.length;
            t2 < 0 && (t2 = -t2 > u2 ? 0 : u2 + t2), r2 = r2 > u2 ? u2 : r2, r2 < 0 && (r2 += u2), u2 = t2 > r2 ? 0 : r2 - t2 >>> 0, t2 >>>= 0;
            for (var i2 = il(u2); ++e3 < u2; )
              i2[e3] = n2[e3 + t2];
            return i2;
          }
          function lu(n2, t2) {
            var r2;
            return ys(n2, function(n3, e3, u2) {
              return r2 = t2(n3, e3, u2), !r2;
            }), !!r2;
          }
          function su(n2, t2, r2) {
            var e3 = 0, u2 = null == n2 ? e3 : n2.length;
            if ("number" == typeof t2 && t2 === t2 && u2 <= Tn) {
              for (; e3 < u2; ) {
                var i2 = e3 + u2 >>> 1, o2 = n2[i2];
                null !== o2 && !bc(o2) && (r2 ? o2 <= t2 : o2 < t2) ? e3 = i2 + 1 : u2 = i2;
              }
              return u2;
            }
            return hu(n2, t2, La, r2);
          }
          function hu(n2, t2, r2, e3) {
            var u2 = 0, i2 = null == n2 ? 0 : n2.length;
            if (0 === i2)
              return 0;
            t2 = r2(t2);
            for (var o2 = t2 !== t2, f2 = null === t2, c2 = bc(t2), a2 = t2 === X; u2 < i2; ) {
              var l2 = Nl((u2 + i2) / 2), s2 = r2(n2[l2]), h2 = s2 !== X, p3 = null === s2, _2 = s2 === s2, v2 = bc(s2);
              if (o2)
                var g2 = e3 || _2;
              else
                g2 = a2 ? _2 && (e3 || h2) : f2 ? _2 && h2 && (e3 || !p3) : c2 ? _2 && h2 && !p3 && (e3 || !v2) : !p3 && !v2 && (e3 ? s2 <= t2 : s2 < t2);
              g2 ? u2 = l2 + 1 : i2 = l2;
            }
            return Hl(i2, Bn);
          }
          function pu(n2, t2) {
            for (var r2 = -1, e3 = n2.length, u2 = 0, i2 = []; ++r2 < e3; ) {
              var o2 = n2[r2], f2 = t2 ? t2(o2) : o2;
              if (!r2 || !Gf(f2, c2)) {
                var c2 = f2;
                i2[u2++] = 0 === o2 ? 0 : o2;
              }
            }
            return i2;
          }
          function _u(n2) {
            return "number" == typeof n2 ? n2 : bc(n2) ? Cn : +n2;
          }
          function vu(n2) {
            if ("string" == typeof n2)
              return n2;
            if (bh(n2))
              return c(n2, vu) + "";
            if (bc(n2))
              return vs ? vs.call(n2) : "";
            var t2 = n2 + "";
            return "0" == t2 && 1 / n2 == -Sn ? "-0" : t2;
          }
          function gu(n2, t2, r2) {
            var e3 = -1, u2 = o, i2 = n2.length, c2 = true, a2 = [], l2 = a2;
            if (r2)
              c2 = false, u2 = f;
            else if (i2 >= tn) {
              var s2 = t2 ? null : ks(n2);
              if (s2)
                return P(s2);
              c2 = false, u2 = S, l2 = new yr2();
            } else
              l2 = t2 ? [] : a2;
            n:
              for (; ++e3 < i2; ) {
                var h2 = n2[e3], p3 = t2 ? t2(h2) : h2;
                if (h2 = r2 || 0 !== h2 ? h2 : 0, c2 && p3 === p3) {
                  for (var _2 = l2.length; _2--; )
                    if (l2[_2] === p3)
                      continue n;
                  t2 && l2.push(p3), a2.push(h2);
                } else
                  u2(l2, p3, r2) || (l2 !== a2 && l2.push(p3), a2.push(h2));
              }
            return a2;
          }
          function yu(n2, t2) {
            return t2 = ku(t2, n2), n2 = Gi(n2, t2), null == n2 || delete n2[no(jo(t2))];
          }
          function du(n2, t2, r2, e3) {
            return fu(n2, t2, r2(_e2(n2, t2)), e3);
          }
          function bu(n2, t2, r2, e3) {
            for (var u2 = n2.length, i2 = e3 ? u2 : -1; (e3 ? i2-- : ++i2 < u2) && t2(n2[i2], i2, n2); )
              ;
            return r2 ? au(n2, e3 ? 0 : i2, e3 ? i2 + 1 : u2) : au(n2, e3 ? i2 + 1 : 0, e3 ? u2 : i2);
          }
          function wu(n2, t2) {
            var r2 = n2;
            return r2 instanceof Ct2 && (r2 = r2.value()), l(t2, function(n3, t3) {
              return t3.func.apply(t3.thisArg, a([n3], t3.args));
            }, r2);
          }
          function mu(n2, t2, r2) {
            var e3 = n2.length;
            if (e3 < 2)
              return e3 ? gu(n2[0]) : [];
            for (var u2 = -1, i2 = il(e3); ++u2 < e3; )
              for (var o2 = n2[u2], f2 = -1; ++f2 < e3; )
                f2 != u2 && (i2[u2] = Hr2(i2[u2] || o2, n2[f2], t2, r2));
            return gu(ee2(i2, 1), t2, r2);
          }
          function xu(n2, t2, r2) {
            for (var e3 = -1, u2 = n2.length, i2 = t2.length, o2 = {}; ++e3 < u2; ) {
              r2(o2, n2[e3], e3 < i2 ? t2[e3] : X);
            }
            return o2;
          }
          function ju(n2) {
            return Jf(n2) ? n2 : [];
          }
          function Au(n2) {
            return "function" == typeof n2 ? n2 : La;
          }
          function ku(n2, t2) {
            return bh(n2) ? n2 : Bi(n2, t2) ? [n2] : Cs(Ec(n2));
          }
          function Ou(n2, t2, r2) {
            var e3 = n2.length;
            return r2 = r2 === X ? e3 : r2, !t2 && r2 >= e3 ? n2 : au(n2, t2, r2);
          }
          function Iu(n2, t2) {
            if (t2)
              return n2.slice();
            var r2 = n2.length, e3 = zl ? zl(r2) : new n2.constructor(r2);
            return n2.copy(e3), e3;
          }
          function Ru(n2) {
            var t2 = new n2.constructor(n2.byteLength);
            return new Rl(t2).set(new Rl(n2)), t2;
          }
          function zu(n2, t2) {
            return new n2.constructor(t2 ? Ru(n2.buffer) : n2.buffer, n2.byteOffset, n2.byteLength);
          }
          function Eu(n2) {
            var t2 = new n2.constructor(n2.source, Nt.exec(n2));
            return t2.lastIndex = n2.lastIndex, t2;
          }
          function Su(n2) {
            return _s ? ll(_s.call(n2)) : {};
          }
          function Wu(n2, t2) {
            return new n2.constructor(t2 ? Ru(n2.buffer) : n2.buffer, n2.byteOffset, n2.length);
          }
          function Lu(n2, t2) {
            if (n2 !== t2) {
              var r2 = n2 !== X, e3 = null === n2, u2 = n2 === n2, i2 = bc(n2), o2 = t2 !== X, f2 = null === t2, c2 = t2 === t2, a2 = bc(t2);
              if (!f2 && !a2 && !i2 && n2 > t2 || i2 && o2 && c2 && !f2 && !a2 || e3 && o2 && c2 || !r2 && c2 || !u2)
                return 1;
              if (!e3 && !i2 && !a2 && n2 < t2 || a2 && r2 && u2 && !e3 && !i2 || f2 && r2 && u2 || !o2 && u2 || !c2)
                return -1;
            }
            return 0;
          }
          function Cu(n2, t2, r2) {
            for (var e3 = -1, u2 = n2.criteria, i2 = t2.criteria, o2 = u2.length, f2 = r2.length; ++e3 < o2; ) {
              var c2 = Lu(u2[e3], i2[e3]);
              if (c2) {
                if (e3 >= f2)
                  return c2;
                return c2 * ("desc" == r2[e3] ? -1 : 1);
              }
            }
            return n2.index - t2.index;
          }
          function Uu(n2, t2, r2, e3) {
            for (var u2 = -1, i2 = n2.length, o2 = r2.length, f2 = -1, c2 = t2.length, a2 = Gl(i2 - o2, 0), l2 = il(c2 + a2), s2 = !e3; ++f2 < c2; )
              l2[f2] = t2[f2];
            for (; ++u2 < o2; )
              (s2 || u2 < i2) && (l2[r2[u2]] = n2[u2]);
            for (; a2--; )
              l2[f2++] = n2[u2++];
            return l2;
          }
          function Bu(n2, t2, r2, e3) {
            for (var u2 = -1, i2 = n2.length, o2 = -1, f2 = r2.length, c2 = -1, a2 = t2.length, l2 = Gl(i2 - f2, 0), s2 = il(l2 + a2), h2 = !e3; ++u2 < l2; )
              s2[u2] = n2[u2];
            for (var p3 = u2; ++c2 < a2; )
              s2[p3 + c2] = t2[c2];
            for (; ++o2 < f2; )
              (h2 || u2 < i2) && (s2[p3 + r2[o2]] = n2[u2++]);
            return s2;
          }
          function Tu(n2, t2) {
            var r2 = -1, e3 = n2.length;
            for (t2 || (t2 = il(e3)); ++r2 < e3; )
              t2[r2] = n2[r2];
            return t2;
          }
          function $u(n2, t2, r2, e3) {
            var u2 = !r2;
            r2 || (r2 = {});
            for (var i2 = -1, o2 = t2.length; ++i2 < o2; ) {
              var f2 = t2[i2], c2 = e3 ? e3(r2[f2], n2[f2], f2, r2, n2) : X;
              c2 === X && (c2 = n2[f2]), u2 ? Br2(r2, f2, c2) : Sr2(r2, f2, c2);
            }
            return r2;
          }
          function Du(n2, t2) {
            return $u(n2, Is(n2), t2);
          }
          function Mu(n2, t2) {
            return $u(n2, Rs(n2), t2);
          }
          function Fu(n2, r2) {
            return function(e3, u2) {
              var i2 = bh(e3) ? t : Lr2, o2 = r2 ? r2() : {};
              return i2(e3, n2, mi(u2, 2), o2);
            };
          }
          function Nu(n2) {
            return uu(function(t2, r2) {
              var e3 = -1, u2 = r2.length, i2 = u2 > 1 ? r2[u2 - 1] : X, o2 = u2 > 2 ? r2[2] : X;
              for (i2 = n2.length > 3 && "function" == typeof i2 ? (u2--, i2) : X, o2 && Ui(r2[0], r2[1], o2) && (i2 = u2 < 3 ? X : i2, u2 = 1), t2 = ll(t2); ++e3 < u2; ) {
                var f2 = r2[e3];
                f2 && n2(t2, f2, e3, i2);
              }
              return t2;
            });
          }
          function Pu(n2, t2) {
            return function(r2, e3) {
              if (null == r2)
                return r2;
              if (!Hf(r2))
                return n2(r2, e3);
              for (var u2 = r2.length, i2 = t2 ? u2 : -1, o2 = ll(r2); (t2 ? i2-- : ++i2 < u2) && e3(o2[i2], i2, o2) !== false; )
                ;
              return r2;
            };
          }
          function qu(n2) {
            return function(t2, r2, e3) {
              for (var u2 = -1, i2 = ll(t2), o2 = e3(t2), f2 = o2.length; f2--; ) {
                var c2 = o2[n2 ? f2 : ++u2];
                if (r2(i2[c2], c2, i2) === false)
                  break;
              }
              return t2;
            };
          }
          function Zu(n2, t2, r2) {
            function e3() {
              return (this && this !== re && this instanceof e3 ? i2 : n2).apply(u2 ? r2 : this, arguments);
            }
            var u2 = t2 & _n, i2 = Gu(n2);
            return e3;
          }
          function Ku(n2) {
            return function(t2) {
              t2 = Ec(t2);
              var r2 = T(t2) ? G(t2) : X, e3 = r2 ? r2[0] : t2.charAt(0), u2 = r2 ? Ou(r2, 1).join("") : t2.slice(1);
              return e3[n2]() + u2;
            };
          }
          function Vu(n2) {
            return function(t2) {
              return l(Ra(ca(t2).replace($r, "")), n2, "");
            };
          }
          function Gu(n2) {
            return function() {
              var t2 = arguments;
              switch (t2.length) {
                case 0:
                  return new n2();
                case 1:
                  return new n2(t2[0]);
                case 2:
                  return new n2(t2[0], t2[1]);
                case 3:
                  return new n2(t2[0], t2[1], t2[2]);
                case 4:
                  return new n2(t2[0], t2[1], t2[2], t2[3]);
                case 5:
                  return new n2(t2[0], t2[1], t2[2], t2[3], t2[4]);
                case 6:
                  return new n2(t2[0], t2[1], t2[2], t2[3], t2[4], t2[5]);
                case 7:
                  return new n2(t2[0], t2[1], t2[2], t2[3], t2[4], t2[5], t2[6]);
              }
              var r2 = gs(n2.prototype), e3 = n2.apply(r2, t2);
              return fc(e3) ? e3 : r2;
            };
          }
          function Hu(t2, r2, e3) {
            function u2() {
              for (var o2 = arguments.length, f2 = il(o2), c2 = o2, a2 = wi(u2); c2--; )
                f2[c2] = arguments[c2];
              var l2 = o2 < 3 && f2[0] !== a2 && f2[o2 - 1] !== a2 ? [] : N(f2, a2);
              return o2 -= l2.length, o2 < e3 ? oi(t2, r2, Qu, u2.placeholder, X, f2, l2, X, X, e3 - o2) : n(this && this !== re && this instanceof u2 ? i2 : t2, this, f2);
            }
            var i2 = Gu(t2);
            return u2;
          }
          function Ju(n2) {
            return function(t2, r2, e3) {
              var u2 = ll(t2);
              if (!Hf(t2)) {
                var i2 = mi(r2, 3);
                t2 = Pc(t2), r2 = function(n3) {
                  return i2(u2[n3], n3, u2);
                };
              }
              var o2 = n2(t2, r2, e3);
              return o2 > -1 ? u2[i2 ? t2[o2] : o2] : X;
            };
          }
          function Yu(n2) {
            return gi(function(t2) {
              var r2 = t2.length, e3 = r2, u2 = Y2.prototype.thru;
              for (n2 && t2.reverse(); e3--; ) {
                var i2 = t2[e3];
                if ("function" != typeof i2)
                  throw new pl(en);
                if (u2 && !o2 && "wrapper" == bi(i2))
                  var o2 = new Y2([], true);
              }
              for (e3 = o2 ? e3 : r2; ++e3 < r2; ) {
                i2 = t2[e3];
                var f2 = bi(i2), c2 = "wrapper" == f2 ? Os(i2) : X;
                o2 = c2 && $i(c2[0]) && c2[1] == (mn | yn | bn | xn) && !c2[4].length && 1 == c2[9] ? o2[bi(c2[0])].apply(o2, c2[3]) : 1 == i2.length && $i(i2) ? o2[f2]() : o2.thru(i2);
              }
              return function() {
                var n3 = arguments, e4 = n3[0];
                if (o2 && 1 == n3.length && bh(e4))
                  return o2.plant(e4).value();
                for (var u3 = 0, i3 = r2 ? t2[u3].apply(this, n3) : e4; ++u3 < r2; )
                  i3 = t2[u3].call(this, i3);
                return i3;
              };
            });
          }
          function Qu(n2, t2, r2, e3, u2, i2, o2, f2, c2, a2) {
            function l2() {
              for (var y3 = arguments.length, d2 = il(y3), b2 = y3; b2--; )
                d2[b2] = arguments[b2];
              if (_2)
                var w2 = wi(l2), m2 = C(d2, w2);
              if (e3 && (d2 = Uu(d2, e3, u2, _2)), i2 && (d2 = Bu(d2, i2, o2, _2)), y3 -= m2, _2 && y3 < a2) {
                return oi(n2, t2, Qu, l2.placeholder, r2, d2, N(d2, w2), f2, c2, a2 - y3);
              }
              var x4 = h2 ? r2 : this, j2 = p3 ? x4[n2] : n2;
              return y3 = d2.length, f2 ? d2 = Hi(d2, f2) : v2 && y3 > 1 && d2.reverse(), s2 && c2 < y3 && (d2.length = c2), this && this !== re && this instanceof l2 && (j2 = g2 || Gu(j2)), j2.apply(x4, d2);
            }
            var s2 = t2 & mn, h2 = t2 & _n, p3 = t2 & vn, _2 = t2 & (yn | dn), v2 = t2 & jn, g2 = p3 ? X : Gu(n2);
            return l2;
          }
          function Xu(n2, t2) {
            return function(r2, e3) {
              return Oe(r2, n2, t2(e3), {});
            };
          }
          function ni(n2, t2) {
            return function(r2, e3) {
              var u2;
              if (r2 === X && e3 === X)
                return t2;
              if (r2 !== X && (u2 = r2), e3 !== X) {
                if (u2 === X)
                  return e3;
                "string" == typeof r2 || "string" == typeof e3 ? (r2 = vu(r2), e3 = vu(e3)) : (r2 = _u(r2), e3 = _u(e3)), u2 = n2(r2, e3);
              }
              return u2;
            };
          }
          function ti(t2) {
            return gi(function(r2) {
              return r2 = c(r2, z(mi())), uu(function(e3) {
                var u2 = this;
                return t2(r2, function(t3) {
                  return n(t3, u2, e3);
                });
              });
            });
          }
          function ri(n2, t2) {
            t2 = t2 === X ? " " : vu(t2);
            var r2 = t2.length;
            if (r2 < 2)
              return r2 ? eu(t2, n2) : t2;
            var e3 = eu(t2, Fl(n2 / V(t2)));
            return T(t2) ? Ou(G(e3), 0, n2).join("") : e3.slice(0, n2);
          }
          function ei(t2, r2, e3, u2) {
            function i2() {
              for (var r3 = -1, c2 = arguments.length, a2 = -1, l2 = u2.length, s2 = il(l2 + c2), h2 = this && this !== re && this instanceof i2 ? f2 : t2; ++a2 < l2; )
                s2[a2] = u2[a2];
              for (; c2--; )
                s2[a2++] = arguments[++r3];
              return n(h2, o2 ? e3 : this, s2);
            }
            var o2 = r2 & _n, f2 = Gu(t2);
            return i2;
          }
          function ui(n2) {
            return function(t2, r2, e3) {
              return e3 && "number" != typeof e3 && Ui(t2, r2, e3) && (r2 = e3 = X), t2 = Ac(t2), r2 === X ? (r2 = t2, t2 = 0) : r2 = Ac(r2), e3 = e3 === X ? t2 < r2 ? 1 : -1 : Ac(e3), ru(t2, r2, e3, n2);
            };
          }
          function ii(n2) {
            return function(t2, r2) {
              return "string" == typeof t2 && "string" == typeof r2 || (t2 = Ic(t2), r2 = Ic(r2)), n2(t2, r2);
            };
          }
          function oi(n2, t2, r2, e3, u2, i2, o2, f2, c2, a2) {
            var l2 = t2 & yn, s2 = l2 ? o2 : X, h2 = l2 ? X : o2, p3 = l2 ? i2 : X, _2 = l2 ? X : i2;
            t2 |= l2 ? bn : wn, t2 &= ~(l2 ? wn : bn), t2 & gn || (t2 &= ~(_n | vn));
            var v2 = [n2, t2, u2, p3, s2, _2, h2, f2, c2, a2], g2 = r2.apply(X, v2);
            return $i(n2) && Ss(g2, v2), g2.placeholder = e3, Yi(g2, n2, t2);
          }
          function fi(n2) {
            var t2 = al[n2];
            return function(n3, r2) {
              if (n3 = Ic(n3), r2 = null == r2 ? 0 : Hl(kc(r2), 292), r2 && Zl(n3)) {
                var e3 = (Ec(n3) + "e").split("e");
                return e3 = (Ec(t2(e3[0] + "e" + (+e3[1] + r2))) + "e").split("e"), +(e3[0] + "e" + (+e3[1] - r2));
              }
              return t2(n3);
            };
          }
          function ci(n2) {
            return function(t2) {
              var r2 = zs(t2);
              return r2 == Gn ? M(t2) : r2 == tt ? q(t2) : I(t2, n2(t2));
            };
          }
          function ai(n2, t2, r2, e3, u2, i2, o2, f2) {
            var c2 = t2 & vn;
            if (!c2 && "function" != typeof n2)
              throw new pl(en);
            var a2 = e3 ? e3.length : 0;
            if (a2 || (t2 &= ~(bn | wn), e3 = u2 = X), o2 = o2 === X ? o2 : Gl(kc(o2), 0), f2 = f2 === X ? f2 : kc(f2), a2 -= u2 ? u2.length : 0, t2 & wn) {
              var l2 = e3, s2 = u2;
              e3 = u2 = X;
            }
            var h2 = c2 ? X : Os(n2), p3 = [n2, t2, r2, e3, u2, l2, s2, i2, o2, f2];
            if (h2 && qi(p3, h2), n2 = p3[0], t2 = p3[1], r2 = p3[2], e3 = p3[3], u2 = p3[4], f2 = p3[9] = p3[9] === X ? c2 ? 0 : n2.length : Gl(p3[9] - a2, 0), !f2 && t2 & (yn | dn) && (t2 &= ~(yn | dn)), t2 && t2 != _n)
              _2 = t2 == yn || t2 == dn ? Hu(n2, t2, f2) : t2 != bn && t2 != (_n | bn) || u2.length ? Qu.apply(X, p3) : ei(n2, t2, r2, e3);
            else
              var _2 = Zu(n2, t2, r2);
            return Yi((h2 ? ms : Ss)(_2, p3), n2, t2);
          }
          function li(n2, t2, r2, e3) {
            return n2 === X || Gf(n2, gl[r2]) && !bl.call(e3, r2) ? t2 : n2;
          }
          function si(n2, t2, r2, e3, u2, i2) {
            return fc(n2) && fc(t2) && (i2.set(t2, n2), Ke(n2, t2, X, si, i2), i2.delete(t2)), n2;
          }
          function hi(n2) {
            return gc(n2) ? X : n2;
          }
          function pi3(n2, t2, r2, e3, u2, i2) {
            var o2 = r2 & hn, f2 = n2.length, c2 = t2.length;
            if (f2 != c2 && !(o2 && c2 > f2))
              return false;
            var a2 = i2.get(n2), l2 = i2.get(t2);
            if (a2 && l2)
              return a2 == t2 && l2 == n2;
            var s2 = -1, p3 = true, _2 = r2 & pn ? new yr2() : X;
            for (i2.set(n2, t2), i2.set(t2, n2); ++s2 < f2; ) {
              var v2 = n2[s2], g2 = t2[s2];
              if (e3)
                var y3 = o2 ? e3(g2, v2, s2, t2, n2, i2) : e3(v2, g2, s2, n2, t2, i2);
              if (y3 !== X) {
                if (y3)
                  continue;
                p3 = false;
                break;
              }
              if (_2) {
                if (!h(t2, function(n3, t3) {
                  if (!S(_2, t3) && (v2 === n3 || u2(v2, n3, r2, e3, i2)))
                    return _2.push(t3);
                })) {
                  p3 = false;
                  break;
                }
              } else if (v2 !== g2 && !u2(v2, g2, r2, e3, i2)) {
                p3 = false;
                break;
              }
            }
            return i2.delete(n2), i2.delete(t2), p3;
          }
          function _i(n2, t2, r2, e3, u2, i2, o2) {
            switch (r2) {
              case ct:
                if (n2.byteLength != t2.byteLength || n2.byteOffset != t2.byteOffset)
                  return false;
                n2 = n2.buffer, t2 = t2.buffer;
              case ft:
                return !(n2.byteLength != t2.byteLength || !i2(new Rl(n2), new Rl(t2)));
              case Nn:
              case Pn:
              case Hn:
                return Gf(+n2, +t2);
              case Zn:
                return n2.name == t2.name && n2.message == t2.message;
              case nt:
              case rt:
                return n2 == t2 + "";
              case Gn:
                var f2 = M;
              case tt:
                var c2 = e3 & hn;
                if (f2 || (f2 = P), n2.size != t2.size && !c2)
                  return false;
                var a2 = o2.get(n2);
                if (a2)
                  return a2 == t2;
                e3 |= pn, o2.set(n2, t2);
                var l2 = pi3(f2(n2), f2(t2), e3, u2, i2, o2);
                return o2.delete(n2), l2;
              case et:
                if (_s)
                  return _s.call(n2) == _s.call(t2);
            }
            return false;
          }
          function vi(n2, t2, r2, e3, u2, i2) {
            var o2 = r2 & hn, f2 = yi(n2), c2 = f2.length;
            if (c2 != yi(t2).length && !o2)
              return false;
            for (var a2 = c2; a2--; ) {
              var l2 = f2[a2];
              if (!(o2 ? l2 in t2 : bl.call(t2, l2)))
                return false;
            }
            var s2 = i2.get(n2), h2 = i2.get(t2);
            if (s2 && h2)
              return s2 == t2 && h2 == n2;
            var p3 = true;
            i2.set(n2, t2), i2.set(t2, n2);
            for (var _2 = o2; ++a2 < c2; ) {
              l2 = f2[a2];
              var v2 = n2[l2], g2 = t2[l2];
              if (e3)
                var y3 = o2 ? e3(g2, v2, l2, t2, n2, i2) : e3(v2, g2, l2, n2, t2, i2);
              if (!(y3 === X ? v2 === g2 || u2(v2, g2, r2, e3, i2) : y3)) {
                p3 = false;
                break;
              }
              _2 || (_2 = "constructor" == l2);
            }
            if (p3 && !_2) {
              var d2 = n2.constructor, b2 = t2.constructor;
              d2 != b2 && "constructor" in n2 && "constructor" in t2 && !("function" == typeof d2 && d2 instanceof d2 && "function" == typeof b2 && b2 instanceof b2) && (p3 = false);
            }
            return i2.delete(n2), i2.delete(t2), p3;
          }
          function gi(n2) {
            return Ls(Vi(n2, X, _o), n2 + "");
          }
          function yi(n2) {
            return de2(n2, Pc, Is);
          }
          function di(n2) {
            return de2(n2, qc, Rs);
          }
          function bi(n2) {
            for (var t2 = n2.name + "", r2 = fs[t2], e3 = bl.call(fs, t2) ? r2.length : 0; e3--; ) {
              var u2 = r2[e3], i2 = u2.func;
              if (null == i2 || i2 == n2)
                return u2.name;
            }
            return t2;
          }
          function wi(n2) {
            return (bl.call(Z2, "placeholder") ? Z2 : n2).placeholder;
          }
          function mi() {
            var n2 = Z2.iteratee || Ca;
            return n2 = n2 === Ca ? De : n2, arguments.length ? n2(arguments[0], arguments[1]) : n2;
          }
          function xi(n2, t2) {
            var r2 = n2.__data__;
            return Ti(t2) ? r2["string" == typeof t2 ? "string" : "hash"] : r2.map;
          }
          function ji(n2) {
            for (var t2 = Pc(n2), r2 = t2.length; r2--; ) {
              var e3 = t2[r2], u2 = n2[e3];
              t2[r2] = [e3, u2, Fi(u2)];
            }
            return t2;
          }
          function Ai(n2, t2) {
            var r2 = B2(n2, t2);
            return Ue(r2) ? r2 : X;
          }
          function ki(n2) {
            var t2 = bl.call(n2, Bl), r2 = n2[Bl];
            try {
              n2[Bl] = X;
              var e3 = true;
            } catch (n3) {
            }
            var u2 = xl.call(n2);
            return e3 && (t2 ? n2[Bl] = r2 : delete n2[Bl]), u2;
          }
          function Oi(n2, t2, r2) {
            for (var e3 = -1, u2 = r2.length; ++e3 < u2; ) {
              var i2 = r2[e3], o2 = i2.size;
              switch (i2.type) {
                case "drop":
                  n2 += o2;
                  break;
                case "dropRight":
                  t2 -= o2;
                  break;
                case "take":
                  t2 = Hl(t2, n2 + o2);
                  break;
                case "takeRight":
                  n2 = Gl(n2, t2 - o2);
              }
            }
            return { start: n2, end: t2 };
          }
          function Ii(n2) {
            var t2 = n2.match(Bt);
            return t2 ? t2[1].split(Tt) : [];
          }
          function Ri(n2, t2, r2) {
            t2 = ku(t2, n2);
            for (var e3 = -1, u2 = t2.length, i2 = false; ++e3 < u2; ) {
              var o2 = no(t2[e3]);
              if (!(i2 = null != n2 && r2(n2, o2)))
                break;
              n2 = n2[o2];
            }
            return i2 || ++e3 != u2 ? i2 : (u2 = null == n2 ? 0 : n2.length, !!u2 && oc(u2) && Ci(o2, u2) && (bh(n2) || dh(n2)));
          }
          function zi(n2) {
            var t2 = n2.length, r2 = new n2.constructor(t2);
            return t2 && "string" == typeof n2[0] && bl.call(n2, "index") && (r2.index = n2.index, r2.input = n2.input), r2;
          }
          function Ei(n2) {
            return "function" != typeof n2.constructor || Mi(n2) ? {} : gs(El(n2));
          }
          function Si(n2, t2, r2) {
            var e3 = n2.constructor;
            switch (t2) {
              case ft:
                return Ru(n2);
              case Nn:
              case Pn:
                return new e3(+n2);
              case ct:
                return zu(n2, r2);
              case at:
              case lt:
              case st:
              case ht:
              case pt:
              case _t:
              case vt:
              case gt:
              case yt:
                return Wu(n2, r2);
              case Gn:
                return new e3();
              case Hn:
              case rt:
                return new e3(n2);
              case nt:
                return Eu(n2);
              case tt:
                return new e3();
              case et:
                return Su(n2);
            }
          }
          function Wi(n2, t2) {
            var r2 = t2.length;
            if (!r2)
              return n2;
            var e3 = r2 - 1;
            return t2[e3] = (r2 > 1 ? "& " : "") + t2[e3], t2 = t2.join(r2 > 2 ? ", " : " "), n2.replace(Ut, "{\n/* [wrapped with " + t2 + "] */\n");
          }
          function Li(n2) {
            return bh(n2) || dh(n2) || !!(Cl && n2 && n2[Cl]);
          }
          function Ci(n2, t2) {
            var r2 = typeof n2;
            return t2 = null == t2 ? Wn : t2, !!t2 && ("number" == r2 || "symbol" != r2 && Vt.test(n2)) && n2 > -1 && n2 % 1 == 0 && n2 < t2;
          }
          function Ui(n2, t2, r2) {
            if (!fc(r2))
              return false;
            var e3 = typeof t2;
            return !!("number" == e3 ? Hf(r2) && Ci(t2, r2.length) : "string" == e3 && t2 in r2) && Gf(r2[t2], n2);
          }
          function Bi(n2, t2) {
            if (bh(n2))
              return false;
            var r2 = typeof n2;
            return !("number" != r2 && "symbol" != r2 && "boolean" != r2 && null != n2 && !bc(n2)) || (zt.test(n2) || !Rt.test(n2) || null != t2 && n2 in ll(t2));
          }
          function Ti(n2) {
            var t2 = typeof n2;
            return "string" == t2 || "number" == t2 || "symbol" == t2 || "boolean" == t2 ? "__proto__" !== n2 : null === n2;
          }
          function $i(n2) {
            var t2 = bi(n2), r2 = Z2[t2];
            if ("function" != typeof r2 || !(t2 in Ct2.prototype))
              return false;
            if (n2 === r2)
              return true;
            var e3 = Os(r2);
            return !!e3 && n2 === e3[0];
          }
          function Di(n2) {
            return !!ml && ml in n2;
          }
          function Mi(n2) {
            var t2 = n2 && n2.constructor;
            return n2 === ("function" == typeof t2 && t2.prototype || gl);
          }
          function Fi(n2) {
            return n2 === n2 && !fc(n2);
          }
          function Ni(n2, t2) {
            return function(r2) {
              return null != r2 && (r2[n2] === t2 && (t2 !== X || n2 in ll(r2)));
            };
          }
          function Pi(n2) {
            var t2 = Cf(n2, function(n3) {
              return r2.size === fn && r2.clear(), n3;
            }), r2 = t2.cache;
            return t2;
          }
          function qi(n2, t2) {
            var r2 = n2[1], e3 = t2[1], u2 = r2 | e3, i2 = u2 < (_n | vn | mn), o2 = e3 == mn && r2 == yn || e3 == mn && r2 == xn && n2[7].length <= t2[8] || e3 == (mn | xn) && t2[7].length <= t2[8] && r2 == yn;
            if (!i2 && !o2)
              return n2;
            e3 & _n && (n2[2] = t2[2], u2 |= r2 & _n ? 0 : gn);
            var f2 = t2[3];
            if (f2) {
              var c2 = n2[3];
              n2[3] = c2 ? Uu(c2, f2, t2[4]) : f2, n2[4] = c2 ? N(n2[3], cn) : t2[4];
            }
            return f2 = t2[5], f2 && (c2 = n2[5], n2[5] = c2 ? Bu(c2, f2, t2[6]) : f2, n2[6] = c2 ? N(n2[5], cn) : t2[6]), f2 = t2[7], f2 && (n2[7] = f2), e3 & mn && (n2[8] = null == n2[8] ? t2[8] : Hl(n2[8], t2[8])), null == n2[9] && (n2[9] = t2[9]), n2[0] = t2[0], n2[1] = u2, n2;
          }
          function Zi(n2) {
            var t2 = [];
            if (null != n2)
              for (var r2 in ll(n2))
                t2.push(r2);
            return t2;
          }
          function Ki(n2) {
            return xl.call(n2);
          }
          function Vi(t2, r2, e3) {
            return r2 = Gl(r2 === X ? t2.length - 1 : r2, 0), function() {
              for (var u2 = arguments, i2 = -1, o2 = Gl(u2.length - r2, 0), f2 = il(o2); ++i2 < o2; )
                f2[i2] = u2[r2 + i2];
              i2 = -1;
              for (var c2 = il(r2 + 1); ++i2 < r2; )
                c2[i2] = u2[i2];
              return c2[r2] = e3(f2), n(t2, this, c2);
            };
          }
          function Gi(n2, t2) {
            return t2.length < 2 ? n2 : _e2(n2, au(t2, 0, -1));
          }
          function Hi(n2, t2) {
            for (var r2 = n2.length, e3 = Hl(t2.length, r2), u2 = Tu(n2); e3--; ) {
              var i2 = t2[e3];
              n2[e3] = Ci(i2, r2) ? u2[i2] : X;
            }
            return n2;
          }
          function Ji(n2, t2) {
            if (("constructor" !== t2 || "function" != typeof n2[t2]) && "__proto__" != t2)
              return n2[t2];
          }
          function Yi(n2, t2, r2) {
            var e3 = t2 + "";
            return Ls(n2, Wi(e3, ro(Ii(e3), r2)));
          }
          function Qi(n2) {
            var t2 = 0, r2 = 0;
            return function() {
              var e3 = Jl(), u2 = In - (e3 - r2);
              if (r2 = e3, u2 > 0) {
                if (++t2 >= On)
                  return arguments[0];
              } else
                t2 = 0;
              return n2.apply(X, arguments);
            };
          }
          function Xi(n2, t2) {
            var r2 = -1, e3 = n2.length, u2 = e3 - 1;
            for (t2 = t2 === X ? e3 : t2; ++r2 < t2; ) {
              var i2 = tu(r2, u2), o2 = n2[i2];
              n2[i2] = n2[r2], n2[r2] = o2;
            }
            return n2.length = t2, n2;
          }
          function no(n2) {
            if ("string" == typeof n2 || bc(n2))
              return n2;
            var t2 = n2 + "";
            return "0" == t2 && 1 / n2 == -Sn ? "-0" : t2;
          }
          function to(n2) {
            if (null != n2) {
              try {
                return dl.call(n2);
              } catch (n3) {
              }
              try {
                return n2 + "";
              } catch (n3) {
              }
            }
            return "";
          }
          function ro(n2, t2) {
            return r($n, function(r2) {
              var e3 = "_." + r2[0];
              t2 & r2[1] && !o(n2, e3) && n2.push(e3);
            }), n2.sort();
          }
          function eo(n2) {
            if (n2 instanceof Ct2)
              return n2.clone();
            var t2 = new Y2(n2.__wrapped__, n2.__chain__);
            return t2.__actions__ = Tu(n2.__actions__), t2.__index__ = n2.__index__, t2.__values__ = n2.__values__, t2;
          }
          function uo(n2, t2, r2) {
            t2 = (r2 ? Ui(n2, t2, r2) : t2 === X) ? 1 : Gl(kc(t2), 0);
            var e3 = null == n2 ? 0 : n2.length;
            if (!e3 || t2 < 1)
              return [];
            for (var u2 = 0, i2 = 0, o2 = il(Fl(e3 / t2)); u2 < e3; )
              o2[i2++] = au(n2, u2, u2 += t2);
            return o2;
          }
          function io(n2) {
            for (var t2 = -1, r2 = null == n2 ? 0 : n2.length, e3 = 0, u2 = []; ++t2 < r2; ) {
              var i2 = n2[t2];
              i2 && (u2[e3++] = i2);
            }
            return u2;
          }
          function oo() {
            var n2 = arguments.length;
            if (!n2)
              return [];
            for (var t2 = il(n2 - 1), r2 = arguments[0], e3 = n2; e3--; )
              t2[e3 - 1] = arguments[e3];
            return a(bh(r2) ? Tu(r2) : [r2], ee2(t2, 1));
          }
          function fo(n2, t2, r2) {
            var e3 = null == n2 ? 0 : n2.length;
            return e3 ? (t2 = r2 || t2 === X ? 1 : kc(t2), au(n2, t2 < 0 ? 0 : t2, e3)) : [];
          }
          function co(n2, t2, r2) {
            var e3 = null == n2 ? 0 : n2.length;
            return e3 ? (t2 = r2 || t2 === X ? 1 : kc(t2), t2 = e3 - t2, au(n2, 0, t2 < 0 ? 0 : t2)) : [];
          }
          function ao(n2, t2) {
            return n2 && n2.length ? bu(n2, mi(t2, 3), true, true) : [];
          }
          function lo(n2, t2) {
            return n2 && n2.length ? bu(n2, mi(t2, 3), true) : [];
          }
          function so(n2, t2, r2, e3) {
            var u2 = null == n2 ? 0 : n2.length;
            return u2 ? (r2 && "number" != typeof r2 && Ui(n2, t2, r2) && (r2 = 0, e3 = u2), ne2(n2, t2, r2, e3)) : [];
          }
          function ho(n2, t2, r2) {
            var e3 = null == n2 ? 0 : n2.length;
            if (!e3)
              return -1;
            var u2 = null == r2 ? 0 : kc(r2);
            return u2 < 0 && (u2 = Gl(e3 + u2, 0)), g(n2, mi(t2, 3), u2);
          }
          function po(n2, t2, r2) {
            var e3 = null == n2 ? 0 : n2.length;
            if (!e3)
              return -1;
            var u2 = e3 - 1;
            return r2 !== X && (u2 = kc(r2), u2 = r2 < 0 ? Gl(e3 + u2, 0) : Hl(u2, e3 - 1)), g(n2, mi(t2, 3), u2, true);
          }
          function _o(n2) {
            return (null == n2 ? 0 : n2.length) ? ee2(n2, 1) : [];
          }
          function vo(n2) {
            return (null == n2 ? 0 : n2.length) ? ee2(n2, Sn) : [];
          }
          function go(n2, t2) {
            return (null == n2 ? 0 : n2.length) ? (t2 = t2 === X ? 1 : kc(t2), ee2(n2, t2)) : [];
          }
          function yo(n2) {
            for (var t2 = -1, r2 = null == n2 ? 0 : n2.length, e3 = {}; ++t2 < r2; ) {
              var u2 = n2[t2];
              e3[u2[0]] = u2[1];
            }
            return e3;
          }
          function bo(n2) {
            return n2 && n2.length ? n2[0] : X;
          }
          function wo(n2, t2, r2) {
            var e3 = null == n2 ? 0 : n2.length;
            if (!e3)
              return -1;
            var u2 = null == r2 ? 0 : kc(r2);
            return u2 < 0 && (u2 = Gl(e3 + u2, 0)), y2(n2, t2, u2);
          }
          function mo(n2) {
            return (null == n2 ? 0 : n2.length) ? au(n2, 0, -1) : [];
          }
          function xo(n2, t2) {
            return null == n2 ? "" : Kl.call(n2, t2);
          }
          function jo(n2) {
            var t2 = null == n2 ? 0 : n2.length;
            return t2 ? n2[t2 - 1] : X;
          }
          function Ao(n2, t2, r2) {
            var e3 = null == n2 ? 0 : n2.length;
            if (!e3)
              return -1;
            var u2 = e3;
            return r2 !== X && (u2 = kc(r2), u2 = u2 < 0 ? Gl(e3 + u2, 0) : Hl(u2, e3 - 1)), t2 === t2 ? K(n2, t2, u2) : g(n2, b, u2, true);
          }
          function ko(n2, t2) {
            return n2 && n2.length ? Ge(n2, kc(t2)) : X;
          }
          function Oo(n2, t2) {
            return n2 && n2.length && t2 && t2.length ? Xe(n2, t2) : n2;
          }
          function Io(n2, t2, r2) {
            return n2 && n2.length && t2 && t2.length ? Xe(n2, t2, mi(r2, 2)) : n2;
          }
          function Ro(n2, t2, r2) {
            return n2 && n2.length && t2 && t2.length ? Xe(n2, t2, X, r2) : n2;
          }
          function zo(n2, t2) {
            var r2 = [];
            if (!n2 || !n2.length)
              return r2;
            var e3 = -1, u2 = [], i2 = n2.length;
            for (t2 = mi(t2, 3); ++e3 < i2; ) {
              var o2 = n2[e3];
              t2(o2, e3, n2) && (r2.push(o2), u2.push(e3));
            }
            return nu(n2, u2), r2;
          }
          function Eo(n2) {
            return null == n2 ? n2 : Xl.call(n2);
          }
          function So(n2, t2, r2) {
            var e3 = null == n2 ? 0 : n2.length;
            return e3 ? (r2 && "number" != typeof r2 && Ui(n2, t2, r2) ? (t2 = 0, r2 = e3) : (t2 = null == t2 ? 0 : kc(t2), r2 = r2 === X ? e3 : kc(r2)), au(n2, t2, r2)) : [];
          }
          function Wo(n2, t2) {
            return su(n2, t2);
          }
          function Lo(n2, t2, r2) {
            return hu(n2, t2, mi(r2, 2));
          }
          function Co(n2, t2) {
            var r2 = null == n2 ? 0 : n2.length;
            if (r2) {
              var e3 = su(n2, t2);
              if (e3 < r2 && Gf(n2[e3], t2))
                return e3;
            }
            return -1;
          }
          function Uo(n2, t2) {
            return su(n2, t2, true);
          }
          function Bo(n2, t2, r2) {
            return hu(n2, t2, mi(r2, 2), true);
          }
          function To(n2, t2) {
            if (null == n2 ? 0 : n2.length) {
              var r2 = su(n2, t2, true) - 1;
              if (Gf(n2[r2], t2))
                return r2;
            }
            return -1;
          }
          function $o(n2) {
            return n2 && n2.length ? pu(n2) : [];
          }
          function Do(n2, t2) {
            return n2 && n2.length ? pu(n2, mi(t2, 2)) : [];
          }
          function Mo(n2) {
            var t2 = null == n2 ? 0 : n2.length;
            return t2 ? au(n2, 1, t2) : [];
          }
          function Fo(n2, t2, r2) {
            return n2 && n2.length ? (t2 = r2 || t2 === X ? 1 : kc(t2), au(n2, 0, t2 < 0 ? 0 : t2)) : [];
          }
          function No(n2, t2, r2) {
            var e3 = null == n2 ? 0 : n2.length;
            return e3 ? (t2 = r2 || t2 === X ? 1 : kc(t2), t2 = e3 - t2, au(n2, t2 < 0 ? 0 : t2, e3)) : [];
          }
          function Po(n2, t2) {
            return n2 && n2.length ? bu(n2, mi(t2, 3), false, true) : [];
          }
          function qo(n2, t2) {
            return n2 && n2.length ? bu(n2, mi(t2, 3)) : [];
          }
          function Zo(n2) {
            return n2 && n2.length ? gu(n2) : [];
          }
          function Ko(n2, t2) {
            return n2 && n2.length ? gu(n2, mi(t2, 2)) : [];
          }
          function Vo(n2, t2) {
            return t2 = "function" == typeof t2 ? t2 : X, n2 && n2.length ? gu(n2, X, t2) : [];
          }
          function Go(n2) {
            if (!n2 || !n2.length)
              return [];
            var t2 = 0;
            return n2 = i(n2, function(n3) {
              if (Jf(n3))
                return t2 = Gl(n3.length, t2), true;
            }), O2(t2, function(t3) {
              return c(n2, m(t3));
            });
          }
          function Ho(t2, r2) {
            if (!t2 || !t2.length)
              return [];
            var e3 = Go(t2);
            return null == r2 ? e3 : c(e3, function(t3) {
              return n(r2, X, t3);
            });
          }
          function Jo(n2, t2) {
            return xu(n2 || [], t2 || [], Sr2);
          }
          function Yo(n2, t2) {
            return xu(n2 || [], t2 || [], fu);
          }
          function Qo(n2) {
            var t2 = Z2(n2);
            return t2.__chain__ = true, t2;
          }
          function Xo(n2, t2) {
            return t2(n2), n2;
          }
          function nf(n2, t2) {
            return t2(n2);
          }
          function tf() {
            return Qo(this);
          }
          function rf() {
            return new Y2(this.value(), this.__chain__);
          }
          function ef() {
            this.__values__ === X && (this.__values__ = jc(this.value()));
            var n2 = this.__index__ >= this.__values__.length;
            return { done: n2, value: n2 ? X : this.__values__[this.__index__++] };
          }
          function uf() {
            return this;
          }
          function of(n2) {
            for (var t2, r2 = this; r2 instanceof J2; ) {
              var e3 = eo(r2);
              e3.__index__ = 0, e3.__values__ = X, t2 ? u2.__wrapped__ = e3 : t2 = e3;
              var u2 = e3;
              r2 = r2.__wrapped__;
            }
            return u2.__wrapped__ = n2, t2;
          }
          function ff() {
            var n2 = this.__wrapped__;
            if (n2 instanceof Ct2) {
              var t2 = n2;
              return this.__actions__.length && (t2 = new Ct2(this)), t2 = t2.reverse(), t2.__actions__.push({ func: nf, args: [Eo], thisArg: X }), new Y2(t2, this.__chain__);
            }
            return this.thru(Eo);
          }
          function cf() {
            return wu(this.__wrapped__, this.__actions__);
          }
          function af(n2, t2, r2) {
            var e3 = bh(n2) ? u : Jr2;
            return r2 && Ui(n2, t2, r2) && (t2 = X), e3(n2, mi(t2, 3));
          }
          function lf(n2, t2) {
            return (bh(n2) ? i : te2)(n2, mi(t2, 3));
          }
          function sf(n2, t2) {
            return ee2(yf(n2, t2), 1);
          }
          function hf(n2, t2) {
            return ee2(yf(n2, t2), Sn);
          }
          function pf(n2, t2, r2) {
            return r2 = r2 === X ? 1 : kc(r2), ee2(yf(n2, t2), r2);
          }
          function _f(n2, t2) {
            return (bh(n2) ? r : ys)(n2, mi(t2, 3));
          }
          function vf(n2, t2) {
            return (bh(n2) ? e : ds)(n2, mi(t2, 3));
          }
          function gf(n2, t2, r2, e3) {
            n2 = Hf(n2) ? n2 : ra(n2), r2 = r2 && !e3 ? kc(r2) : 0;
            var u2 = n2.length;
            return r2 < 0 && (r2 = Gl(u2 + r2, 0)), dc(n2) ? r2 <= u2 && n2.indexOf(t2, r2) > -1 : !!u2 && y2(n2, t2, r2) > -1;
          }
          function yf(n2, t2) {
            return (bh(n2) ? c : Pe)(n2, mi(t2, 3));
          }
          function df(n2, t2, r2, e3) {
            return null == n2 ? [] : (bh(t2) || (t2 = null == t2 ? [] : [t2]), r2 = e3 ? X : r2, bh(r2) || (r2 = null == r2 ? [] : [r2]), He(n2, t2, r2));
          }
          function bf(n2, t2, r2) {
            var e3 = bh(n2) ? l : j, u2 = arguments.length < 3;
            return e3(n2, mi(t2, 4), r2, u2, ys);
          }
          function wf(n2, t2, r2) {
            var e3 = bh(n2) ? s : j, u2 = arguments.length < 3;
            return e3(n2, mi(t2, 4), r2, u2, ds);
          }
          function mf(n2, t2) {
            return (bh(n2) ? i : te2)(n2, Uf(mi(t2, 3)));
          }
          function xf(n2) {
            return (bh(n2) ? Ir2 : iu)(n2);
          }
          function jf(n2, t2, r2) {
            return t2 = (r2 ? Ui(n2, t2, r2) : t2 === X) ? 1 : kc(t2), (bh(n2) ? Rr2 : ou)(n2, t2);
          }
          function Af(n2) {
            return (bh(n2) ? zr2 : cu)(n2);
          }
          function kf(n2) {
            if (null == n2)
              return 0;
            if (Hf(n2))
              return dc(n2) ? V(n2) : n2.length;
            var t2 = zs(n2);
            return t2 == Gn || t2 == tt ? n2.size : Me(n2).length;
          }
          function Of(n2, t2, r2) {
            var e3 = bh(n2) ? h : lu;
            return r2 && Ui(n2, t2, r2) && (t2 = X), e3(n2, mi(t2, 3));
          }
          function If(n2, t2) {
            if ("function" != typeof t2)
              throw new pl(en);
            return n2 = kc(n2), function() {
              if (--n2 < 1)
                return t2.apply(this, arguments);
            };
          }
          function Rf(n2, t2, r2) {
            return t2 = r2 ? X : t2, t2 = n2 && null == t2 ? n2.length : t2, ai(n2, mn, X, X, X, X, t2);
          }
          function zf(n2, t2) {
            var r2;
            if ("function" != typeof t2)
              throw new pl(en);
            return n2 = kc(n2), function() {
              return --n2 > 0 && (r2 = t2.apply(this, arguments)), n2 <= 1 && (t2 = X), r2;
            };
          }
          function Ef(n2, t2, r2) {
            t2 = r2 ? X : t2;
            var e3 = ai(n2, yn, X, X, X, X, X, t2);
            return e3.placeholder = Ef.placeholder, e3;
          }
          function Sf(n2, t2, r2) {
            t2 = r2 ? X : t2;
            var e3 = ai(n2, dn, X, X, X, X, X, t2);
            return e3.placeholder = Sf.placeholder, e3;
          }
          function Wf(n2, t2, r2) {
            function e3(t3) {
              var r3 = h2, e4 = p3;
              return h2 = p3 = X, d2 = t3, v2 = n2.apply(e4, r3);
            }
            function u2(n3) {
              return d2 = n3, g2 = Ws(f2, t2), b2 ? e3(n3) : v2;
            }
            function i2(n3) {
              var r3 = n3 - y3, e4 = n3 - d2, u3 = t2 - r3;
              return w2 ? Hl(u3, _2 - e4) : u3;
            }
            function o2(n3) {
              var r3 = n3 - y3, e4 = n3 - d2;
              return y3 === X || r3 >= t2 || r3 < 0 || w2 && e4 >= _2;
            }
            function f2() {
              var n3 = fh();
              return o2(n3) ? c2(n3) : (g2 = Ws(f2, i2(n3)), X);
            }
            function c2(n3) {
              return g2 = X, m2 && h2 ? e3(n3) : (h2 = p3 = X, v2);
            }
            function a2() {
              g2 !== X && As(g2), d2 = 0, h2 = y3 = p3 = g2 = X;
            }
            function l2() {
              return g2 === X ? v2 : c2(fh());
            }
            function s2() {
              var n3 = fh(), r3 = o2(n3);
              if (h2 = arguments, p3 = this, y3 = n3, r3) {
                if (g2 === X)
                  return u2(y3);
                if (w2)
                  return As(g2), g2 = Ws(f2, t2), e3(y3);
              }
              return g2 === X && (g2 = Ws(f2, t2)), v2;
            }
            var h2, p3, _2, v2, g2, y3, d2 = 0, b2 = false, w2 = false, m2 = true;
            if ("function" != typeof n2)
              throw new pl(en);
            return t2 = Ic(t2) || 0, fc(r2) && (b2 = !!r2.leading, w2 = "maxWait" in r2, _2 = w2 ? Gl(Ic(r2.maxWait) || 0, t2) : _2, m2 = "trailing" in r2 ? !!r2.trailing : m2), s2.cancel = a2, s2.flush = l2, s2;
          }
          function Lf(n2) {
            return ai(n2, jn);
          }
          function Cf(n2, t2) {
            if ("function" != typeof n2 || null != t2 && "function" != typeof t2)
              throw new pl(en);
            var r2 = function() {
              var e3 = arguments, u2 = t2 ? t2.apply(this, e3) : e3[0], i2 = r2.cache;
              if (i2.has(u2))
                return i2.get(u2);
              var o2 = n2.apply(this, e3);
              return r2.cache = i2.set(u2, o2) || i2, o2;
            };
            return r2.cache = new (Cf.Cache || sr2)(), r2;
          }
          function Uf(n2) {
            if ("function" != typeof n2)
              throw new pl(en);
            return function() {
              var t2 = arguments;
              switch (t2.length) {
                case 0:
                  return !n2.call(this);
                case 1:
                  return !n2.call(this, t2[0]);
                case 2:
                  return !n2.call(this, t2[0], t2[1]);
                case 3:
                  return !n2.call(this, t2[0], t2[1], t2[2]);
              }
              return !n2.apply(this, t2);
            };
          }
          function Bf(n2) {
            return zf(2, n2);
          }
          function Tf(n2, t2) {
            if ("function" != typeof n2)
              throw new pl(en);
            return t2 = t2 === X ? t2 : kc(t2), uu(n2, t2);
          }
          function $f(t2, r2) {
            if ("function" != typeof t2)
              throw new pl(en);
            return r2 = null == r2 ? 0 : Gl(kc(r2), 0), uu(function(e3) {
              var u2 = e3[r2], i2 = Ou(e3, 0, r2);
              return u2 && a(i2, u2), n(t2, this, i2);
            });
          }
          function Df(n2, t2, r2) {
            var e3 = true, u2 = true;
            if ("function" != typeof n2)
              throw new pl(en);
            return fc(r2) && (e3 = "leading" in r2 ? !!r2.leading : e3, u2 = "trailing" in r2 ? !!r2.trailing : u2), Wf(n2, t2, { leading: e3, maxWait: t2, trailing: u2 });
          }
          function Mf(n2) {
            return Rf(n2, 1);
          }
          function Ff(n2, t2) {
            return ph(Au(t2), n2);
          }
          function Nf() {
            if (!arguments.length)
              return [];
            var n2 = arguments[0];
            return bh(n2) ? n2 : [n2];
          }
          function Pf(n2) {
            return Fr2(n2, sn);
          }
          function qf(n2, t2) {
            return t2 = "function" == typeof t2 ? t2 : X, Fr2(n2, sn, t2);
          }
          function Zf(n2) {
            return Fr2(n2, an | sn);
          }
          function Kf(n2, t2) {
            return t2 = "function" == typeof t2 ? t2 : X, Fr2(n2, an | sn, t2);
          }
          function Vf(n2, t2) {
            return null == t2 || Pr2(n2, t2, Pc(t2));
          }
          function Gf(n2, t2) {
            return n2 === t2 || n2 !== n2 && t2 !== t2;
          }
          function Hf(n2) {
            return null != n2 && oc(n2.length) && !uc(n2);
          }
          function Jf(n2) {
            return cc(n2) && Hf(n2);
          }
          function Yf(n2) {
            return n2 === true || n2 === false || cc(n2) && we(n2) == Nn;
          }
          function Qf(n2) {
            return cc(n2) && 1 === n2.nodeType && !gc(n2);
          }
          function Xf(n2) {
            if (null == n2)
              return true;
            if (Hf(n2) && (bh(n2) || "string" == typeof n2 || "function" == typeof n2.splice || mh(n2) || Oh(n2) || dh(n2)))
              return !n2.length;
            var t2 = zs(n2);
            if (t2 == Gn || t2 == tt)
              return !n2.size;
            if (Mi(n2))
              return !Me(n2).length;
            for (var r2 in n2)
              if (bl.call(n2, r2))
                return false;
            return true;
          }
          function nc(n2, t2) {
            return Se(n2, t2);
          }
          function tc(n2, t2, r2) {
            r2 = "function" == typeof r2 ? r2 : X;
            var e3 = r2 ? r2(n2, t2) : X;
            return e3 === X ? Se(n2, t2, X, r2) : !!e3;
          }
          function rc(n2) {
            if (!cc(n2))
              return false;
            var t2 = we(n2);
            return t2 == Zn || t2 == qn || "string" == typeof n2.message && "string" == typeof n2.name && !gc(n2);
          }
          function ec(n2) {
            return "number" == typeof n2 && Zl(n2);
          }
          function uc(n2) {
            if (!fc(n2))
              return false;
            var t2 = we(n2);
            return t2 == Kn || t2 == Vn || t2 == Fn || t2 == Xn;
          }
          function ic(n2) {
            return "number" == typeof n2 && n2 == kc(n2);
          }
          function oc(n2) {
            return "number" == typeof n2 && n2 > -1 && n2 % 1 == 0 && n2 <= Wn;
          }
          function fc(n2) {
            var t2 = typeof n2;
            return null != n2 && ("object" == t2 || "function" == t2);
          }
          function cc(n2) {
            return null != n2 && "object" == typeof n2;
          }
          function ac(n2, t2) {
            return n2 === t2 || Ce(n2, t2, ji(t2));
          }
          function lc(n2, t2, r2) {
            return r2 = "function" == typeof r2 ? r2 : X, Ce(n2, t2, ji(t2), r2);
          }
          function sc(n2) {
            return vc(n2) && n2 != +n2;
          }
          function hc(n2) {
            if (Es(n2))
              throw new fl(rn);
            return Ue(n2);
          }
          function pc(n2) {
            return null === n2;
          }
          function _c(n2) {
            return null == n2;
          }
          function vc(n2) {
            return "number" == typeof n2 || cc(n2) && we(n2) == Hn;
          }
          function gc(n2) {
            if (!cc(n2) || we(n2) != Yn)
              return false;
            var t2 = El(n2);
            if (null === t2)
              return true;
            var r2 = bl.call(t2, "constructor") && t2.constructor;
            return "function" == typeof r2 && r2 instanceof r2 && dl.call(r2) == jl;
          }
          function yc(n2) {
            return ic(n2) && n2 >= -Wn && n2 <= Wn;
          }
          function dc(n2) {
            return "string" == typeof n2 || !bh(n2) && cc(n2) && we(n2) == rt;
          }
          function bc(n2) {
            return "symbol" == typeof n2 || cc(n2) && we(n2) == et;
          }
          function wc(n2) {
            return n2 === X;
          }
          function mc(n2) {
            return cc(n2) && zs(n2) == it;
          }
          function xc(n2) {
            return cc(n2) && we(n2) == ot;
          }
          function jc(n2) {
            if (!n2)
              return [];
            if (Hf(n2))
              return dc(n2) ? G(n2) : Tu(n2);
            if (Ul && n2[Ul])
              return D(n2[Ul]());
            var t2 = zs(n2);
            return (t2 == Gn ? M : t2 == tt ? P : ra)(n2);
          }
          function Ac(n2) {
            if (!n2)
              return 0 === n2 ? n2 : 0;
            if (n2 = Ic(n2), n2 === Sn || n2 === -Sn) {
              return (n2 < 0 ? -1 : 1) * Ln;
            }
            return n2 === n2 ? n2 : 0;
          }
          function kc(n2) {
            var t2 = Ac(n2), r2 = t2 % 1;
            return t2 === t2 ? r2 ? t2 - r2 : t2 : 0;
          }
          function Oc(n2) {
            return n2 ? Mr2(kc(n2), 0, Un) : 0;
          }
          function Ic(n2) {
            if ("number" == typeof n2)
              return n2;
            if (bc(n2))
              return Cn;
            if (fc(n2)) {
              var t2 = "function" == typeof n2.valueOf ? n2.valueOf() : n2;
              n2 = fc(t2) ? t2 + "" : t2;
            }
            if ("string" != typeof n2)
              return 0 === n2 ? n2 : +n2;
            n2 = R(n2);
            var r2 = qt.test(n2);
            return r2 || Kt.test(n2) ? Xr(n2.slice(2), r2 ? 2 : 8) : Pt.test(n2) ? Cn : +n2;
          }
          function Rc(n2) {
            return $u(n2, qc(n2));
          }
          function zc(n2) {
            return n2 ? Mr2(kc(n2), -Wn, Wn) : 0 === n2 ? n2 : 0;
          }
          function Ec(n2) {
            return null == n2 ? "" : vu(n2);
          }
          function Sc(n2, t2) {
            var r2 = gs(n2);
            return null == t2 ? r2 : Cr2(r2, t2);
          }
          function Wc(n2, t2) {
            return v(n2, mi(t2, 3), ue2);
          }
          function Lc(n2, t2) {
            return v(n2, mi(t2, 3), oe2);
          }
          function Cc(n2, t2) {
            return null == n2 ? n2 : bs(n2, mi(t2, 3), qc);
          }
          function Uc(n2, t2) {
            return null == n2 ? n2 : ws(n2, mi(t2, 3), qc);
          }
          function Bc(n2, t2) {
            return n2 && ue2(n2, mi(t2, 3));
          }
          function Tc(n2, t2) {
            return n2 && oe2(n2, mi(t2, 3));
          }
          function $c(n2) {
            return null == n2 ? [] : fe2(n2, Pc(n2));
          }
          function Dc(n2) {
            return null == n2 ? [] : fe2(n2, qc(n2));
          }
          function Mc(n2, t2, r2) {
            var e3 = null == n2 ? X : _e2(n2, t2);
            return e3 === X ? r2 : e3;
          }
          function Fc(n2, t2) {
            return null != n2 && Ri(n2, t2, xe);
          }
          function Nc(n2, t2) {
            return null != n2 && Ri(n2, t2, je);
          }
          function Pc(n2) {
            return Hf(n2) ? Or2(n2) : Me(n2);
          }
          function qc(n2) {
            return Hf(n2) ? Or2(n2, true) : Fe(n2);
          }
          function Zc(n2, t2) {
            var r2 = {};
            return t2 = mi(t2, 3), ue2(n2, function(n3, e3, u2) {
              Br2(r2, t2(n3, e3, u2), n3);
            }), r2;
          }
          function Kc(n2, t2) {
            var r2 = {};
            return t2 = mi(t2, 3), ue2(n2, function(n3, e3, u2) {
              Br2(r2, e3, t2(n3, e3, u2));
            }), r2;
          }
          function Vc(n2, t2) {
            return Gc(n2, Uf(mi(t2)));
          }
          function Gc(n2, t2) {
            if (null == n2)
              return {};
            var r2 = c(di(n2), function(n3) {
              return [n3];
            });
            return t2 = mi(t2), Ye(n2, r2, function(n3, r3) {
              return t2(n3, r3[0]);
            });
          }
          function Hc(n2, t2, r2) {
            t2 = ku(t2, n2);
            var e3 = -1, u2 = t2.length;
            for (u2 || (u2 = 1, n2 = X); ++e3 < u2; ) {
              var i2 = null == n2 ? X : n2[no(t2[e3])];
              i2 === X && (e3 = u2, i2 = r2), n2 = uc(i2) ? i2.call(n2) : i2;
            }
            return n2;
          }
          function Jc(n2, t2, r2) {
            return null == n2 ? n2 : fu(n2, t2, r2);
          }
          function Yc(n2, t2, r2, e3) {
            return e3 = "function" == typeof e3 ? e3 : X, null == n2 ? n2 : fu(n2, t2, r2, e3);
          }
          function Qc(n2, t2, e3) {
            var u2 = bh(n2), i2 = u2 || mh(n2) || Oh(n2);
            if (t2 = mi(t2, 4), null == e3) {
              var o2 = n2 && n2.constructor;
              e3 = i2 ? u2 ? new o2() : [] : fc(n2) && uc(o2) ? gs(El(n2)) : {};
            }
            return (i2 ? r : ue2)(n2, function(n3, r2, u3) {
              return t2(e3, n3, r2, u3);
            }), e3;
          }
          function Xc(n2, t2) {
            return null == n2 || yu(n2, t2);
          }
          function na(n2, t2, r2) {
            return null == n2 ? n2 : du(n2, t2, Au(r2));
          }
          function ta(n2, t2, r2, e3) {
            return e3 = "function" == typeof e3 ? e3 : X, null == n2 ? n2 : du(n2, t2, Au(r2), e3);
          }
          function ra(n2) {
            return null == n2 ? [] : E(n2, Pc(n2));
          }
          function ea(n2) {
            return null == n2 ? [] : E(n2, qc(n2));
          }
          function ua(n2, t2, r2) {
            return r2 === X && (r2 = t2, t2 = X), r2 !== X && (r2 = Ic(r2), r2 = r2 === r2 ? r2 : 0), t2 !== X && (t2 = Ic(t2), t2 = t2 === t2 ? t2 : 0), Mr2(Ic(n2), t2, r2);
          }
          function ia(n2, t2, r2) {
            return t2 = Ac(t2), r2 === X ? (r2 = t2, t2 = 0) : r2 = Ac(r2), n2 = Ic(n2), Ae(n2, t2, r2);
          }
          function oa(n2, t2, r2) {
            if (r2 && "boolean" != typeof r2 && Ui(n2, t2, r2) && (t2 = r2 = X), r2 === X && ("boolean" == typeof t2 ? (r2 = t2, t2 = X) : "boolean" == typeof n2 && (r2 = n2, n2 = X)), n2 === X && t2 === X ? (n2 = 0, t2 = 1) : (n2 = Ac(n2), t2 === X ? (t2 = n2, n2 = 0) : t2 = Ac(t2)), n2 > t2) {
              var e3 = n2;
              n2 = t2, t2 = e3;
            }
            if (r2 || n2 % 1 || t2 % 1) {
              var u2 = Ql();
              return Hl(n2 + u2 * (t2 - n2 + Qr("1e-" + ((u2 + "").length - 1))), t2);
            }
            return tu(n2, t2);
          }
          function fa(n2) {
            return Qh(Ec(n2).toLowerCase());
          }
          function ca(n2) {
            return n2 = Ec(n2), n2 && n2.replace(Gt, ve).replace(Dr, "");
          }
          function aa(n2, t2, r2) {
            n2 = Ec(n2), t2 = vu(t2);
            var e3 = n2.length;
            r2 = r2 === X ? e3 : Mr2(kc(r2), 0, e3);
            var u2 = r2;
            return r2 -= t2.length, r2 >= 0 && n2.slice(r2, u2) == t2;
          }
          function la(n2) {
            return n2 = Ec(n2), n2 && At.test(n2) ? n2.replace(xt, ge) : n2;
          }
          function sa(n2) {
            return n2 = Ec(n2), n2 && Wt.test(n2) ? n2.replace(St, "\\$&") : n2;
          }
          function ha(n2, t2, r2) {
            n2 = Ec(n2), t2 = kc(t2);
            var e3 = t2 ? V(n2) : 0;
            if (!t2 || e3 >= t2)
              return n2;
            var u2 = (t2 - e3) / 2;
            return ri(Nl(u2), r2) + n2 + ri(Fl(u2), r2);
          }
          function pa(n2, t2, r2) {
            n2 = Ec(n2), t2 = kc(t2);
            var e3 = t2 ? V(n2) : 0;
            return t2 && e3 < t2 ? n2 + ri(t2 - e3, r2) : n2;
          }
          function _a(n2, t2, r2) {
            n2 = Ec(n2), t2 = kc(t2);
            var e3 = t2 ? V(n2) : 0;
            return t2 && e3 < t2 ? ri(t2 - e3, r2) + n2 : n2;
          }
          function va(n2, t2, r2) {
            return r2 || null == t2 ? t2 = 0 : t2 && (t2 = +t2), Yl(Ec(n2).replace(Lt, ""), t2 || 0);
          }
          function ga(n2, t2, r2) {
            return t2 = (r2 ? Ui(n2, t2, r2) : t2 === X) ? 1 : kc(t2), eu(Ec(n2), t2);
          }
          function ya() {
            var n2 = arguments, t2 = Ec(n2[0]);
            return n2.length < 3 ? t2 : t2.replace(n2[1], n2[2]);
          }
          function da(n2, t2, r2) {
            return r2 && "number" != typeof r2 && Ui(n2, t2, r2) && (t2 = r2 = X), (r2 = r2 === X ? Un : r2 >>> 0) ? (n2 = Ec(n2), n2 && ("string" == typeof t2 || null != t2 && !Ah(t2)) && (t2 = vu(t2), !t2 && T(n2)) ? Ou(G(n2), 0, r2) : n2.split(t2, r2)) : [];
          }
          function ba(n2, t2, r2) {
            return n2 = Ec(n2), r2 = null == r2 ? 0 : Mr2(kc(r2), 0, n2.length), t2 = vu(t2), n2.slice(r2, r2 + t2.length) == t2;
          }
          function wa(n2, t2, r2) {
            var e3 = Z2.templateSettings;
            r2 && Ui(n2, t2, r2) && (t2 = X), n2 = Ec(n2), t2 = Sh({}, t2, e3, li);
            var u2, i2, o2 = Sh({}, t2.imports, e3.imports, li), f2 = Pc(o2), c2 = E(o2, f2), a2 = 0, l2 = t2.interpolate || Ht, s2 = "__p += '", h2 = sl((t2.escape || Ht).source + "|" + l2.source + "|" + (l2 === It ? Ft : Ht).source + "|" + (t2.evaluate || Ht).source + "|$", "g"), p3 = "//# sourceURL=" + (bl.call(t2, "sourceURL") ? (t2.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++Zr + "]") + "\n";
            n2.replace(h2, function(t3, r3, e4, o3, f3, c3) {
              return e4 || (e4 = o3), s2 += n2.slice(a2, c3).replace(Jt, U), r3 && (u2 = true, s2 += "' +\n__e(" + r3 + ") +\n'"), f3 && (i2 = true, s2 += "';\n" + f3 + ";\n__p += '"), e4 && (s2 += "' +\n((__t = (" + e4 + ")) == null ? '' : __t) +\n'"), a2 = c3 + t3.length, t3;
            }), s2 += "';\n";
            var _2 = bl.call(t2, "variable") && t2.variable;
            if (_2) {
              if (Dt.test(_2))
                throw new fl(un);
            } else
              s2 = "with (obj) {\n" + s2 + "\n}\n";
            s2 = (i2 ? s2.replace(dt, "") : s2).replace(bt, "$1").replace(wt, "$1;"), s2 = "function(" + (_2 || "obj") + ") {\n" + (_2 ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (u2 ? ", __e = _.escape" : "") + (i2 ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + s2 + "return __p\n}";
            var v2 = Xh(function() {
              return cl(f2, p3 + "return " + s2).apply(X, c2);
            });
            if (v2.source = s2, rc(v2))
              throw v2;
            return v2;
          }
          function ma(n2) {
            return Ec(n2).toLowerCase();
          }
          function xa(n2) {
            return Ec(n2).toUpperCase();
          }
          function ja(n2, t2, r2) {
            if (n2 = Ec(n2), n2 && (r2 || t2 === X))
              return R(n2);
            if (!n2 || !(t2 = vu(t2)))
              return n2;
            var e3 = G(n2), u2 = G(t2);
            return Ou(e3, W(e3, u2), L(e3, u2) + 1).join("");
          }
          function Aa(n2, t2, r2) {
            if (n2 = Ec(n2), n2 && (r2 || t2 === X))
              return n2.slice(0, H(n2) + 1);
            if (!n2 || !(t2 = vu(t2)))
              return n2;
            var e3 = G(n2);
            return Ou(e3, 0, L(e3, G(t2)) + 1).join("");
          }
          function ka(n2, t2, r2) {
            if (n2 = Ec(n2), n2 && (r2 || t2 === X))
              return n2.replace(Lt, "");
            if (!n2 || !(t2 = vu(t2)))
              return n2;
            var e3 = G(n2);
            return Ou(e3, W(e3, G(t2))).join("");
          }
          function Oa(n2, t2) {
            var r2 = An, e3 = kn;
            if (fc(t2)) {
              var u2 = "separator" in t2 ? t2.separator : u2;
              r2 = "length" in t2 ? kc(t2.length) : r2, e3 = "omission" in t2 ? vu(t2.omission) : e3;
            }
            n2 = Ec(n2);
            var i2 = n2.length;
            if (T(n2)) {
              var o2 = G(n2);
              i2 = o2.length;
            }
            if (r2 >= i2)
              return n2;
            var f2 = r2 - V(e3);
            if (f2 < 1)
              return e3;
            var c2 = o2 ? Ou(o2, 0, f2).join("") : n2.slice(0, f2);
            if (u2 === X)
              return c2 + e3;
            if (o2 && (f2 += c2.length - f2), Ah(u2)) {
              if (n2.slice(f2).search(u2)) {
                var a2, l2 = c2;
                for (u2.global || (u2 = sl(u2.source, Ec(Nt.exec(u2)) + "g")), u2.lastIndex = 0; a2 = u2.exec(l2); )
                  var s2 = a2.index;
                c2 = c2.slice(0, s2 === X ? f2 : s2);
              }
            } else if (n2.indexOf(vu(u2), f2) != f2) {
              var h2 = c2.lastIndexOf(u2);
              h2 > -1 && (c2 = c2.slice(0, h2));
            }
            return c2 + e3;
          }
          function Ia(n2) {
            return n2 = Ec(n2), n2 && jt.test(n2) ? n2.replace(mt, ye) : n2;
          }
          function Ra(n2, t2, r2) {
            return n2 = Ec(n2), t2 = r2 ? X : t2, t2 === X ? $(n2) ? Q(n2) : _(n2) : n2.match(t2) || [];
          }
          function za(t2) {
            var r2 = null == t2 ? 0 : t2.length, e3 = mi();
            return t2 = r2 ? c(t2, function(n2) {
              if ("function" != typeof n2[1])
                throw new pl(en);
              return [e3(n2[0]), n2[1]];
            }) : [], uu(function(e4) {
              for (var u2 = -1; ++u2 < r2; ) {
                var i2 = t2[u2];
                if (n(i2[0], this, e4))
                  return n(i2[1], this, e4);
              }
            });
          }
          function Ea(n2) {
            return Nr2(Fr2(n2, an));
          }
          function Sa(n2) {
            return function() {
              return n2;
            };
          }
          function Wa(n2, t2) {
            return null == n2 || n2 !== n2 ? t2 : n2;
          }
          function La(n2) {
            return n2;
          }
          function Ca(n2) {
            return De("function" == typeof n2 ? n2 : Fr2(n2, an));
          }
          function Ua(n2) {
            return qe(Fr2(n2, an));
          }
          function Ba(n2, t2) {
            return Ze(n2, Fr2(t2, an));
          }
          function Ta(n2, t2, e3) {
            var u2 = Pc(t2), i2 = fe2(t2, u2);
            null != e3 || fc(t2) && (i2.length || !u2.length) || (e3 = t2, t2 = n2, n2 = this, i2 = fe2(t2, Pc(t2)));
            var o2 = !(fc(e3) && "chain" in e3 && !e3.chain), f2 = uc(n2);
            return r(i2, function(r2) {
              var e4 = t2[r2];
              n2[r2] = e4, f2 && (n2.prototype[r2] = function() {
                var t3 = this.__chain__;
                if (o2 || t3) {
                  var r3 = n2(this.__wrapped__);
                  return (r3.__actions__ = Tu(this.__actions__)).push({ func: e4, args: arguments, thisArg: n2 }), r3.__chain__ = t3, r3;
                }
                return e4.apply(n2, a([this.value()], arguments));
              });
            }), n2;
          }
          function $a() {
            return re._ === this && (re._ = Al), this;
          }
          function Da() {
          }
          function Ma(n2) {
            return n2 = kc(n2), uu(function(t2) {
              return Ge(t2, n2);
            });
          }
          function Fa(n2) {
            return Bi(n2) ? m(no(n2)) : Qe(n2);
          }
          function Na(n2) {
            return function(t2) {
              return null == n2 ? X : _e2(n2, t2);
            };
          }
          function Pa() {
            return [];
          }
          function qa() {
            return false;
          }
          function Za() {
            return {};
          }
          function Ka() {
            return "";
          }
          function Va() {
            return true;
          }
          function Ga(n2, t2) {
            if (n2 = kc(n2), n2 < 1 || n2 > Wn)
              return [];
            var r2 = Un, e3 = Hl(n2, Un);
            t2 = mi(t2), n2 -= Un;
            for (var u2 = O2(e3, t2); ++r2 < n2; )
              t2(r2);
            return u2;
          }
          function Ha(n2) {
            return bh(n2) ? c(n2, no) : bc(n2) ? [n2] : Tu(Cs(Ec(n2)));
          }
          function Ja(n2) {
            var t2 = ++wl;
            return Ec(n2) + t2;
          }
          function Ya(n2) {
            return n2 && n2.length ? Yr2(n2, La, me) : X;
          }
          function Qa(n2, t2) {
            return n2 && n2.length ? Yr2(n2, mi(t2, 2), me) : X;
          }
          function Xa(n2) {
            return w(n2, La);
          }
          function nl(n2, t2) {
            return w(n2, mi(t2, 2));
          }
          function tl(n2) {
            return n2 && n2.length ? Yr2(n2, La, Ne) : X;
          }
          function rl(n2, t2) {
            return n2 && n2.length ? Yr2(n2, mi(t2, 2), Ne) : X;
          }
          function el(n2) {
            return n2 && n2.length ? k(n2, La) : 0;
          }
          function ul(n2, t2) {
            return n2 && n2.length ? k(n2, mi(t2, 2)) : 0;
          }
          x3 = null == x3 ? re : be.defaults(re.Object(), x3, be.pick(re, qr));
          var il = x3.Array, ol = x3.Date, fl = x3.Error, cl = x3.Function, al = x3.Math, ll = x3.Object, sl = x3.RegExp, hl = x3.String, pl = x3.TypeError, _l = il.prototype, vl = cl.prototype, gl = ll.prototype, yl = x3["__core-js_shared__"], dl = vl.toString, bl = gl.hasOwnProperty, wl = 0, ml = function() {
            var n2 = /[^.]+$/.exec(yl && yl.keys && yl.keys.IE_PROTO || "");
            return n2 ? "Symbol(src)_1." + n2 : "";
          }(), xl = gl.toString, jl = dl.call(ll), Al = re._, kl = sl("^" + dl.call(bl).replace(St, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), Ol = ie ? x3.Buffer : X, Il = x3.Symbol, Rl = x3.Uint8Array, zl = Ol ? Ol.allocUnsafe : X, El = F(ll.getPrototypeOf, ll), Sl = ll.create, Wl = gl.propertyIsEnumerable, Ll = _l.splice, Cl = Il ? Il.isConcatSpreadable : X, Ul = Il ? Il.iterator : X, Bl = Il ? Il.toStringTag : X, Tl = function() {
            try {
              var n2 = Ai(ll, "defineProperty");
              return n2({}, "", {}), n2;
            } catch (n3) {
            }
          }(), $l = x3.clearTimeout !== re.clearTimeout && x3.clearTimeout, Dl = ol && ol.now !== re.Date.now && ol.now, Ml = x3.setTimeout !== re.setTimeout && x3.setTimeout, Fl = al.ceil, Nl = al.floor, Pl = ll.getOwnPropertySymbols, ql = Ol ? Ol.isBuffer : X, Zl = x3.isFinite, Kl = _l.join, Vl = F(ll.keys, ll), Gl = al.max, Hl = al.min, Jl = ol.now, Yl = x3.parseInt, Ql = al.random, Xl = _l.reverse, ns = Ai(x3, "DataView"), ts = Ai(x3, "Map"), rs = Ai(x3, "Promise"), es = Ai(x3, "Set"), us = Ai(x3, "WeakMap"), is = Ai(ll, "create"), os = us && new us(), fs = {}, cs = to(ns), as = to(ts), ls = to(rs), ss = to(es), hs = to(us), ps = Il ? Il.prototype : X, _s = ps ? ps.valueOf : X, vs = ps ? ps.toString : X, gs = function() {
            function n2() {
            }
            return function(t2) {
              if (!fc(t2))
                return {};
              if (Sl)
                return Sl(t2);
              n2.prototype = t2;
              var r2 = new n2();
              return n2.prototype = X, r2;
            };
          }();
          Z2.templateSettings = { escape: kt, evaluate: Ot, interpolate: It, variable: "", imports: { _: Z2 } }, Z2.prototype = J2.prototype, Z2.prototype.constructor = Z2, Y2.prototype = gs(J2.prototype), Y2.prototype.constructor = Y2, Ct2.prototype = gs(J2.prototype), Ct2.prototype.constructor = Ct2, Xt2.prototype.clear = nr2, Xt2.prototype.delete = tr2, Xt2.prototype.get = rr2, Xt2.prototype.has = er2, Xt2.prototype.set = ur2, ir2.prototype.clear = or2, ir2.prototype.delete = fr2, ir2.prototype.get = cr2, ir2.prototype.has = ar2, ir2.prototype.set = lr2, sr2.prototype.clear = hr2, sr2.prototype.delete = pr2, sr2.prototype.get = _r2, sr2.prototype.has = vr2, sr2.prototype.set = gr2, yr2.prototype.add = yr2.prototype.push = dr2, yr2.prototype.has = br2, wr2.prototype.clear = mr2, wr2.prototype.delete = xr2, wr2.prototype.get = jr2, wr2.prototype.has = Ar2, wr2.prototype.set = kr2;
          var ys = Pu(ue2), ds = Pu(oe2, true), bs = qu(), ws = qu(true), ms = os ? function(n2, t2) {
            return os.set(n2, t2), n2;
          } : La, xs = Tl ? function(n2, t2) {
            return Tl(n2, "toString", {
              configurable: true,
              enumerable: false,
              value: Sa(t2),
              writable: true
            });
          } : La, js = uu, As = $l || function(n2) {
            return re.clearTimeout(n2);
          }, ks = es && 1 / P(new es([, -0]))[1] == Sn ? function(n2) {
            return new es(n2);
          } : Da, Os = os ? function(n2) {
            return os.get(n2);
          } : Da, Is = Pl ? function(n2) {
            return null == n2 ? [] : (n2 = ll(n2), i(Pl(n2), function(t2) {
              return Wl.call(n2, t2);
            }));
          } : Pa, Rs = Pl ? function(n2) {
            for (var t2 = []; n2; )
              a(t2, Is(n2)), n2 = El(n2);
            return t2;
          } : Pa, zs = we;
          (ns && zs(new ns(new ArrayBuffer(1))) != ct || ts && zs(new ts()) != Gn || rs && zs(rs.resolve()) != Qn || es && zs(new es()) != tt || us && zs(new us()) != it) && (zs = function(n2) {
            var t2 = we(n2), r2 = t2 == Yn ? n2.constructor : X, e3 = r2 ? to(r2) : "";
            if (e3)
              switch (e3) {
                case cs:
                  return ct;
                case as:
                  return Gn;
                case ls:
                  return Qn;
                case ss:
                  return tt;
                case hs:
                  return it;
              }
            return t2;
          });
          var Es = yl ? uc : qa, Ss = Qi(ms), Ws = Ml || function(n2, t2) {
            return re.setTimeout(n2, t2);
          }, Ls = Qi(xs), Cs = Pi(function(n2) {
            var t2 = [];
            return 46 === n2.charCodeAt(0) && t2.push(""), n2.replace(Et, function(n3, r2, e3, u2) {
              t2.push(e3 ? u2.replace(Mt, "$1") : r2 || n3);
            }), t2;
          }), Us = uu(function(n2, t2) {
            return Jf(n2) ? Hr2(n2, ee2(t2, 1, Jf, true)) : [];
          }), Bs = uu(function(n2, t2) {
            var r2 = jo(t2);
            return Jf(r2) && (r2 = X), Jf(n2) ? Hr2(n2, ee2(t2, 1, Jf, true), mi(r2, 2)) : [];
          }), Ts = uu(function(n2, t2) {
            var r2 = jo(t2);
            return Jf(r2) && (r2 = X), Jf(n2) ? Hr2(n2, ee2(t2, 1, Jf, true), X, r2) : [];
          }), $s = uu(function(n2) {
            var t2 = c(n2, ju);
            return t2.length && t2[0] === n2[0] ? ke(t2) : [];
          }), Ds = uu(function(n2) {
            var t2 = jo(n2), r2 = c(n2, ju);
            return t2 === jo(r2) ? t2 = X : r2.pop(), r2.length && r2[0] === n2[0] ? ke(r2, mi(t2, 2)) : [];
          }), Ms = uu(function(n2) {
            var t2 = jo(n2), r2 = c(n2, ju);
            return t2 = "function" == typeof t2 ? t2 : X, t2 && r2.pop(), r2.length && r2[0] === n2[0] ? ke(r2, X, t2) : [];
          }), Fs = uu(Oo), Ns = gi(function(n2, t2) {
            var r2 = null == n2 ? 0 : n2.length, e3 = Tr2(n2, t2);
            return nu(n2, c(t2, function(n3) {
              return Ci(n3, r2) ? +n3 : n3;
            }).sort(Lu)), e3;
          }), Ps = uu(function(n2) {
            return gu(ee2(n2, 1, Jf, true));
          }), qs = uu(function(n2) {
            var t2 = jo(n2);
            return Jf(t2) && (t2 = X), gu(ee2(n2, 1, Jf, true), mi(t2, 2));
          }), Zs = uu(function(n2) {
            var t2 = jo(n2);
            return t2 = "function" == typeof t2 ? t2 : X, gu(ee2(n2, 1, Jf, true), X, t2);
          }), Ks = uu(function(n2, t2) {
            return Jf(n2) ? Hr2(n2, t2) : [];
          }), Vs = uu(function(n2) {
            return mu(i(n2, Jf));
          }), Gs = uu(function(n2) {
            var t2 = jo(n2);
            return Jf(t2) && (t2 = X), mu(i(n2, Jf), mi(t2, 2));
          }), Hs = uu(function(n2) {
            var t2 = jo(n2);
            return t2 = "function" == typeof t2 ? t2 : X, mu(i(n2, Jf), X, t2);
          }), Js = uu(Go), Ys = uu(function(n2) {
            var t2 = n2.length, r2 = t2 > 1 ? n2[t2 - 1] : X;
            return r2 = "function" == typeof r2 ? (n2.pop(), r2) : X, Ho(n2, r2);
          }), Qs = gi(function(n2) {
            var t2 = n2.length, r2 = t2 ? n2[0] : 0, e3 = this.__wrapped__, u2 = function(t3) {
              return Tr2(t3, n2);
            };
            return !(t2 > 1 || this.__actions__.length) && e3 instanceof Ct2 && Ci(r2) ? (e3 = e3.slice(r2, +r2 + (t2 ? 1 : 0)), e3.__actions__.push({ func: nf, args: [u2], thisArg: X }), new Y2(e3, this.__chain__).thru(function(n3) {
              return t2 && !n3.length && n3.push(X), n3;
            })) : this.thru(u2);
          }), Xs = Fu(function(n2, t2, r2) {
            bl.call(n2, r2) ? ++n2[r2] : Br2(n2, r2, 1);
          }), nh = Ju(ho), th = Ju(po), rh = Fu(function(n2, t2, r2) {
            bl.call(n2, r2) ? n2[r2].push(t2) : Br2(n2, r2, [t2]);
          }), eh = uu(function(t2, r2, e3) {
            var u2 = -1, i2 = "function" == typeof r2, o2 = Hf(t2) ? il(t2.length) : [];
            return ys(t2, function(t3) {
              o2[++u2] = i2 ? n(r2, t3, e3) : Ie(t3, r2, e3);
            }), o2;
          }), uh = Fu(function(n2, t2, r2) {
            Br2(n2, r2, t2);
          }), ih = Fu(function(n2, t2, r2) {
            n2[r2 ? 0 : 1].push(t2);
          }, function() {
            return [[], []];
          }), oh = uu(function(n2, t2) {
            if (null == n2)
              return [];
            var r2 = t2.length;
            return r2 > 1 && Ui(n2, t2[0], t2[1]) ? t2 = [] : r2 > 2 && Ui(t2[0], t2[1], t2[2]) && (t2 = [t2[0]]), He(n2, ee2(t2, 1), []);
          }), fh = Dl || function() {
            return re.Date.now();
          }, ch = uu(function(n2, t2, r2) {
            var e3 = _n;
            if (r2.length) {
              var u2 = N(r2, wi(ch));
              e3 |= bn;
            }
            return ai(n2, e3, t2, r2, u2);
          }), ah = uu(function(n2, t2, r2) {
            var e3 = _n | vn;
            if (r2.length) {
              var u2 = N(r2, wi(ah));
              e3 |= bn;
            }
            return ai(t2, e3, n2, r2, u2);
          }), lh = uu(function(n2, t2) {
            return Gr2(n2, 1, t2);
          }), sh = uu(function(n2, t2, r2) {
            return Gr2(n2, Ic(t2) || 0, r2);
          });
          Cf.Cache = sr2;
          var hh = js(function(t2, r2) {
            r2 = 1 == r2.length && bh(r2[0]) ? c(r2[0], z(mi())) : c(ee2(r2, 1), z(mi()));
            var e3 = r2.length;
            return uu(function(u2) {
              for (var i2 = -1, o2 = Hl(u2.length, e3); ++i2 < o2; )
                u2[i2] = r2[i2].call(this, u2[i2]);
              return n(t2, this, u2);
            });
          }), ph = uu(function(n2, t2) {
            return ai(n2, bn, X, t2, N(t2, wi(ph)));
          }), _h = uu(function(n2, t2) {
            return ai(n2, wn, X, t2, N(t2, wi(_h)));
          }), vh = gi(function(n2, t2) {
            return ai(n2, xn, X, X, X, t2);
          }), gh = ii(me), yh = ii(function(n2, t2) {
            return n2 >= t2;
          }), dh = Re(function() {
            return arguments;
          }()) ? Re : function(n2) {
            return cc(n2) && bl.call(n2, "callee") && !Wl.call(n2, "callee");
          }, bh = il.isArray, wh = ce ? z(ce) : ze, mh = ql || qa, xh = ae ? z(ae) : Ee, jh = le ? z(le) : Le, Ah = se ? z(se) : Be, kh = he ? z(he) : Te, Oh = pe ? z(pe) : $e, Ih = ii(Ne), Rh = ii(function(n2, t2) {
            return n2 <= t2;
          }), zh = Nu(function(n2, t2) {
            if (Mi(t2) || Hf(t2))
              return $u(t2, Pc(t2), n2), X;
            for (var r2 in t2)
              bl.call(t2, r2) && Sr2(n2, r2, t2[r2]);
          }), Eh = Nu(function(n2, t2) {
            $u(t2, qc(t2), n2);
          }), Sh = Nu(function(n2, t2, r2, e3) {
            $u(t2, qc(t2), n2, e3);
          }), Wh = Nu(function(n2, t2, r2, e3) {
            $u(t2, Pc(t2), n2, e3);
          }), Lh = gi(Tr2), Ch = uu(function(n2, t2) {
            n2 = ll(n2);
            var r2 = -1, e3 = t2.length, u2 = e3 > 2 ? t2[2] : X;
            for (u2 && Ui(t2[0], t2[1], u2) && (e3 = 1); ++r2 < e3; )
              for (var i2 = t2[r2], o2 = qc(i2), f2 = -1, c2 = o2.length; ++f2 < c2; ) {
                var a2 = o2[f2], l2 = n2[a2];
                (l2 === X || Gf(l2, gl[a2]) && !bl.call(n2, a2)) && (n2[a2] = i2[a2]);
              }
            return n2;
          }), Uh = uu(function(t2) {
            return t2.push(X, si), n(Mh, X, t2);
          }), Bh = Xu(function(n2, t2, r2) {
            null != t2 && "function" != typeof t2.toString && (t2 = xl.call(t2)), n2[t2] = r2;
          }, Sa(La)), Th = Xu(function(n2, t2, r2) {
            null != t2 && "function" != typeof t2.toString && (t2 = xl.call(t2)), bl.call(n2, t2) ? n2[t2].push(r2) : n2[t2] = [r2];
          }, mi), $h = uu(Ie), Dh = Nu(function(n2, t2, r2) {
            Ke(n2, t2, r2);
          }), Mh = Nu(function(n2, t2, r2, e3) {
            Ke(n2, t2, r2, e3);
          }), Fh = gi(function(n2, t2) {
            var r2 = {};
            if (null == n2)
              return r2;
            var e3 = false;
            t2 = c(t2, function(t3) {
              return t3 = ku(t3, n2), e3 || (e3 = t3.length > 1), t3;
            }), $u(n2, di(n2), r2), e3 && (r2 = Fr2(r2, an | ln | sn, hi));
            for (var u2 = t2.length; u2--; )
              yu(r2, t2[u2]);
            return r2;
          }), Nh = gi(function(n2, t2) {
            return null == n2 ? {} : Je(n2, t2);
          }), Ph = ci(Pc), qh = ci(qc), Zh = Vu(function(n2, t2, r2) {
            return t2 = t2.toLowerCase(), n2 + (r2 ? fa(t2) : t2);
          }), Kh = Vu(function(n2, t2, r2) {
            return n2 + (r2 ? "-" : "") + t2.toLowerCase();
          }), Vh = Vu(function(n2, t2, r2) {
            return n2 + (r2 ? " " : "") + t2.toLowerCase();
          }), Gh = Ku("toLowerCase"), Hh = Vu(function(n2, t2, r2) {
            return n2 + (r2 ? "_" : "") + t2.toLowerCase();
          }), Jh = Vu(function(n2, t2, r2) {
            return n2 + (r2 ? " " : "") + Qh(t2);
          }), Yh = Vu(function(n2, t2, r2) {
            return n2 + (r2 ? " " : "") + t2.toUpperCase();
          }), Qh = Ku("toUpperCase"), Xh = uu(function(t2, r2) {
            try {
              return n(t2, X, r2);
            } catch (n2) {
              return rc(n2) ? n2 : new fl(n2);
            }
          }), np = gi(function(n2, t2) {
            return r(t2, function(t3) {
              t3 = no(t3), Br2(n2, t3, ch(n2[t3], n2));
            }), n2;
          }), tp = Yu(), rp = Yu(true), ep = uu(function(n2, t2) {
            return function(r2) {
              return Ie(r2, n2, t2);
            };
          }), up = uu(function(n2, t2) {
            return function(r2) {
              return Ie(n2, r2, t2);
            };
          }), ip = ti(c), op = ti(u), fp2 = ti(h), cp = ui(), ap = ui(true), lp = ni(function(n2, t2) {
            return n2 + t2;
          }, 0), sp = fi("ceil"), hp = ni(function(n2, t2) {
            return n2 / t2;
          }, 1), pp = fi("floor"), _p = ni(function(n2, t2) {
            return n2 * t2;
          }, 1), vp = fi("round"), gp = ni(function(n2, t2) {
            return n2 - t2;
          }, 0);
          return Z2.after = If, Z2.ary = Rf, Z2.assign = zh, Z2.assignIn = Eh, Z2.assignInWith = Sh, Z2.assignWith = Wh, Z2.at = Lh, Z2.before = zf, Z2.bind = ch, Z2.bindAll = np, Z2.bindKey = ah, Z2.castArray = Nf, Z2.chain = Qo, Z2.chunk = uo, Z2.compact = io, Z2.concat = oo, Z2.cond = za, Z2.conforms = Ea, Z2.constant = Sa, Z2.countBy = Xs, Z2.create = Sc, Z2.curry = Ef, Z2.curryRight = Sf, Z2.debounce = Wf, Z2.defaults = Ch, Z2.defaultsDeep = Uh, Z2.defer = lh, Z2.delay = sh, Z2.difference = Us, Z2.differenceBy = Bs, Z2.differenceWith = Ts, Z2.drop = fo, Z2.dropRight = co, Z2.dropRightWhile = ao, Z2.dropWhile = lo, Z2.fill = so, Z2.filter = lf, Z2.flatMap = sf, Z2.flatMapDeep = hf, Z2.flatMapDepth = pf, Z2.flatten = _o, Z2.flattenDeep = vo, Z2.flattenDepth = go, Z2.flip = Lf, Z2.flow = tp, Z2.flowRight = rp, Z2.fromPairs = yo, Z2.functions = $c, Z2.functionsIn = Dc, Z2.groupBy = rh, Z2.initial = mo, Z2.intersection = $s, Z2.intersectionBy = Ds, Z2.intersectionWith = Ms, Z2.invert = Bh, Z2.invertBy = Th, Z2.invokeMap = eh, Z2.iteratee = Ca, Z2.keyBy = uh, Z2.keys = Pc, Z2.keysIn = qc, Z2.map = yf, Z2.mapKeys = Zc, Z2.mapValues = Kc, Z2.matches = Ua, Z2.matchesProperty = Ba, Z2.memoize = Cf, Z2.merge = Dh, Z2.mergeWith = Mh, Z2.method = ep, Z2.methodOf = up, Z2.mixin = Ta, Z2.negate = Uf, Z2.nthArg = Ma, Z2.omit = Fh, Z2.omitBy = Vc, Z2.once = Bf, Z2.orderBy = df, Z2.over = ip, Z2.overArgs = hh, Z2.overEvery = op, Z2.overSome = fp2, Z2.partial = ph, Z2.partialRight = _h, Z2.partition = ih, Z2.pick = Nh, Z2.pickBy = Gc, Z2.property = Fa, Z2.propertyOf = Na, Z2.pull = Fs, Z2.pullAll = Oo, Z2.pullAllBy = Io, Z2.pullAllWith = Ro, Z2.pullAt = Ns, Z2.range = cp, Z2.rangeRight = ap, Z2.rearg = vh, Z2.reject = mf, Z2.remove = zo, Z2.rest = Tf, Z2.reverse = Eo, Z2.sampleSize = jf, Z2.set = Jc, Z2.setWith = Yc, Z2.shuffle = Af, Z2.slice = So, Z2.sortBy = oh, Z2.sortedUniq = $o, Z2.sortedUniqBy = Do, Z2.split = da, Z2.spread = $f, Z2.tail = Mo, Z2.take = Fo, Z2.takeRight = No, Z2.takeRightWhile = Po, Z2.takeWhile = qo, Z2.tap = Xo, Z2.throttle = Df, Z2.thru = nf, Z2.toArray = jc, Z2.toPairs = Ph, Z2.toPairsIn = qh, Z2.toPath = Ha, Z2.toPlainObject = Rc, Z2.transform = Qc, Z2.unary = Mf, Z2.union = Ps, Z2.unionBy = qs, Z2.unionWith = Zs, Z2.uniq = Zo, Z2.uniqBy = Ko, Z2.uniqWith = Vo, Z2.unset = Xc, Z2.unzip = Go, Z2.unzipWith = Ho, Z2.update = na, Z2.updateWith = ta, Z2.values = ra, Z2.valuesIn = ea, Z2.without = Ks, Z2.words = Ra, Z2.wrap = Ff, Z2.xor = Vs, Z2.xorBy = Gs, Z2.xorWith = Hs, Z2.zip = Js, Z2.zipObject = Jo, Z2.zipObjectDeep = Yo, Z2.zipWith = Ys, Z2.entries = Ph, Z2.entriesIn = qh, Z2.extend = Eh, Z2.extendWith = Sh, Ta(Z2, Z2), Z2.add = lp, Z2.attempt = Xh, Z2.camelCase = Zh, Z2.capitalize = fa, Z2.ceil = sp, Z2.clamp = ua, Z2.clone = Pf, Z2.cloneDeep = Zf, Z2.cloneDeepWith = Kf, Z2.cloneWith = qf, Z2.conformsTo = Vf, Z2.deburr = ca, Z2.defaultTo = Wa, Z2.divide = hp, Z2.endsWith = aa, Z2.eq = Gf, Z2.escape = la, Z2.escapeRegExp = sa, Z2.every = af, Z2.find = nh, Z2.findIndex = ho, Z2.findKey = Wc, Z2.findLast = th, Z2.findLastIndex = po, Z2.findLastKey = Lc, Z2.floor = pp, Z2.forEach = _f, Z2.forEachRight = vf, Z2.forIn = Cc, Z2.forInRight = Uc, Z2.forOwn = Bc, Z2.forOwnRight = Tc, Z2.get = Mc, Z2.gt = gh, Z2.gte = yh, Z2.has = Fc, Z2.hasIn = Nc, Z2.head = bo, Z2.identity = La, Z2.includes = gf, Z2.indexOf = wo, Z2.inRange = ia, Z2.invoke = $h, Z2.isArguments = dh, Z2.isArray = bh, Z2.isArrayBuffer = wh, Z2.isArrayLike = Hf, Z2.isArrayLikeObject = Jf, Z2.isBoolean = Yf, Z2.isBuffer = mh, Z2.isDate = xh, Z2.isElement = Qf, Z2.isEmpty = Xf, Z2.isEqual = nc, Z2.isEqualWith = tc, Z2.isError = rc, Z2.isFinite = ec, Z2.isFunction = uc, Z2.isInteger = ic, Z2.isLength = oc, Z2.isMap = jh, Z2.isMatch = ac, Z2.isMatchWith = lc, Z2.isNaN = sc, Z2.isNative = hc, Z2.isNil = _c, Z2.isNull = pc, Z2.isNumber = vc, Z2.isObject = fc, Z2.isObjectLike = cc, Z2.isPlainObject = gc, Z2.isRegExp = Ah, Z2.isSafeInteger = yc, Z2.isSet = kh, Z2.isString = dc, Z2.isSymbol = bc, Z2.isTypedArray = Oh, Z2.isUndefined = wc, Z2.isWeakMap = mc, Z2.isWeakSet = xc, Z2.join = xo, Z2.kebabCase = Kh, Z2.last = jo, Z2.lastIndexOf = Ao, Z2.lowerCase = Vh, Z2.lowerFirst = Gh, Z2.lt = Ih, Z2.lte = Rh, Z2.max = Ya, Z2.maxBy = Qa, Z2.mean = Xa, Z2.meanBy = nl, Z2.min = tl, Z2.minBy = rl, Z2.stubArray = Pa, Z2.stubFalse = qa, Z2.stubObject = Za, Z2.stubString = Ka, Z2.stubTrue = Va, Z2.multiply = _p, Z2.nth = ko, Z2.noConflict = $a, Z2.noop = Da, Z2.now = fh, Z2.pad = ha, Z2.padEnd = pa, Z2.padStart = _a, Z2.parseInt = va, Z2.random = oa, Z2.reduce = bf, Z2.reduceRight = wf, Z2.repeat = ga, Z2.replace = ya, Z2.result = Hc, Z2.round = vp, Z2.runInContext = p2, Z2.sample = xf, Z2.size = kf, Z2.snakeCase = Hh, Z2.some = Of, Z2.sortedIndex = Wo, Z2.sortedIndexBy = Lo, Z2.sortedIndexOf = Co, Z2.sortedLastIndex = Uo, Z2.sortedLastIndexBy = Bo, Z2.sortedLastIndexOf = To, Z2.startCase = Jh, Z2.startsWith = ba, Z2.subtract = gp, Z2.sum = el, Z2.sumBy = ul, Z2.template = wa, Z2.times = Ga, Z2.toFinite = Ac, Z2.toInteger = kc, Z2.toLength = Oc, Z2.toLower = ma, Z2.toNumber = Ic, Z2.toSafeInteger = zc, Z2.toString = Ec, Z2.toUpper = xa, Z2.trim = ja, Z2.trimEnd = Aa, Z2.trimStart = ka, Z2.truncate = Oa, Z2.unescape = Ia, Z2.uniqueId = Ja, Z2.upperCase = Yh, Z2.upperFirst = Qh, Z2.each = _f, Z2.eachRight = vf, Z2.first = bo, Ta(Z2, function() {
            var n2 = {};
            return ue2(Z2, function(t2, r2) {
              bl.call(Z2.prototype, r2) || (n2[r2] = t2);
            }), n2;
          }(), { chain: false }), Z2.VERSION = nn, r(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(n2) {
            Z2[n2].placeholder = Z2;
          }), r(["drop", "take"], function(n2, t2) {
            Ct2.prototype[n2] = function(r2) {
              r2 = r2 === X ? 1 : Gl(kc(r2), 0);
              var e3 = this.__filtered__ && !t2 ? new Ct2(this) : this.clone();
              return e3.__filtered__ ? e3.__takeCount__ = Hl(r2, e3.__takeCount__) : e3.__views__.push({ size: Hl(r2, Un), type: n2 + (e3.__dir__ < 0 ? "Right" : "") }), e3;
            }, Ct2.prototype[n2 + "Right"] = function(t3) {
              return this.reverse()[n2](t3).reverse();
            };
          }), r(["filter", "map", "takeWhile"], function(n2, t2) {
            var r2 = t2 + 1, e3 = r2 == Rn || r2 == En;
            Ct2.prototype[n2] = function(n3) {
              var t3 = this.clone();
              return t3.__iteratees__.push({ iteratee: mi(n3, 3), type: r2 }), t3.__filtered__ = t3.__filtered__ || e3, t3;
            };
          }), r(["head", "last"], function(n2, t2) {
            var r2 = "take" + (t2 ? "Right" : "");
            Ct2.prototype[n2] = function() {
              return this[r2](1).value()[0];
            };
          }), r(["initial", "tail"], function(n2, t2) {
            var r2 = "drop" + (t2 ? "" : "Right");
            Ct2.prototype[n2] = function() {
              return this.__filtered__ ? new Ct2(this) : this[r2](1);
            };
          }), Ct2.prototype.compact = function() {
            return this.filter(La);
          }, Ct2.prototype.find = function(n2) {
            return this.filter(n2).head();
          }, Ct2.prototype.findLast = function(n2) {
            return this.reverse().find(n2);
          }, Ct2.prototype.invokeMap = uu(function(n2, t2) {
            return "function" == typeof n2 ? new Ct2(this) : this.map(function(r2) {
              return Ie(r2, n2, t2);
            });
          }), Ct2.prototype.reject = function(n2) {
            return this.filter(Uf(mi(n2)));
          }, Ct2.prototype.slice = function(n2, t2) {
            n2 = kc(n2);
            var r2 = this;
            return r2.__filtered__ && (n2 > 0 || t2 < 0) ? new Ct2(r2) : (n2 < 0 ? r2 = r2.takeRight(-n2) : n2 && (r2 = r2.drop(n2)), t2 !== X && (t2 = kc(t2), r2 = t2 < 0 ? r2.dropRight(-t2) : r2.take(t2 - n2)), r2);
          }, Ct2.prototype.takeRightWhile = function(n2) {
            return this.reverse().takeWhile(n2).reverse();
          }, Ct2.prototype.toArray = function() {
            return this.take(Un);
          }, ue2(Ct2.prototype, function(n2, t2) {
            var r2 = /^(?:filter|find|map|reject)|While$/.test(t2), e3 = /^(?:head|last)$/.test(t2), u2 = Z2[e3 ? "take" + ("last" == t2 ? "Right" : "") : t2], i2 = e3 || /^find/.test(t2);
            u2 && (Z2.prototype[t2] = function() {
              var t3 = this.__wrapped__, o2 = e3 ? [1] : arguments, f2 = t3 instanceof Ct2, c2 = o2[0], l2 = f2 || bh(t3), s2 = function(n3) {
                var t4 = u2.apply(Z2, a([n3], o2));
                return e3 && h2 ? t4[0] : t4;
              };
              l2 && r2 && "function" == typeof c2 && 1 != c2.length && (f2 = l2 = false);
              var h2 = this.__chain__, p3 = !!this.__actions__.length, _2 = i2 && !h2, v2 = f2 && !p3;
              if (!i2 && l2) {
                t3 = v2 ? t3 : new Ct2(this);
                var g2 = n2.apply(t3, o2);
                return g2.__actions__.push({ func: nf, args: [s2], thisArg: X }), new Y2(g2, h2);
              }
              return _2 && v2 ? n2.apply(this, o2) : (g2 = this.thru(s2), _2 ? e3 ? g2.value()[0] : g2.value() : g2);
            });
          }), r(["pop", "push", "shift", "sort", "splice", "unshift"], function(n2) {
            var t2 = _l[n2], r2 = /^(?:push|sort|unshift)$/.test(n2) ? "tap" : "thru", e3 = /^(?:pop|shift)$/.test(n2);
            Z2.prototype[n2] = function() {
              var n3 = arguments;
              if (e3 && !this.__chain__) {
                var u2 = this.value();
                return t2.apply(bh(u2) ? u2 : [], n3);
              }
              return this[r2](function(r3) {
                return t2.apply(bh(r3) ? r3 : [], n3);
              });
            };
          }), ue2(Ct2.prototype, function(n2, t2) {
            var r2 = Z2[t2];
            if (r2) {
              var e3 = r2.name + "";
              bl.call(fs, e3) || (fs[e3] = []), fs[e3].push({ name: t2, func: r2 });
            }
          }), fs[Qu(X, vn).name] = [{ name: "wrapper", func: X }], Ct2.prototype.clone = $t2, Ct2.prototype.reverse = Yt2, Ct2.prototype.value = Qt2, Z2.prototype.at = Qs, Z2.prototype.chain = tf, Z2.prototype.commit = rf, Z2.prototype.next = ef, Z2.prototype.plant = of, Z2.prototype.reverse = ff, Z2.prototype.toJSON = Z2.prototype.valueOf = Z2.prototype.value = cf, Z2.prototype.first = Z2.prototype.head, Ul && (Z2.prototype[Ul] = uf), Z2;
        }, be = de();
        "function" == typeof define && "object" == typeof define.amd && define.amd ? (re._ = be, define(function() {
          return be;
        })) : ue ? ((ue.exports = be)._ = be, ee._ = be) : re._ = be;
      }).call(exports);
    }
  });

  // node_modules/lodash/fp/_mapping.js
  var require_mapping = __commonJS({
    "node_modules/lodash/fp/_mapping.js"(exports) {
      exports.aliasToReal = {
        "each": "forEach",
        "eachRight": "forEachRight",
        "entries": "toPairs",
        "entriesIn": "toPairsIn",
        "extend": "assignIn",
        "extendAll": "assignInAll",
        "extendAllWith": "assignInAllWith",
        "extendWith": "assignInWith",
        "first": "head",
        "conforms": "conformsTo",
        "matches": "isMatch",
        "property": "get",
        "__": "placeholder",
        "F": "stubFalse",
        "T": "stubTrue",
        "all": "every",
        "allPass": "overEvery",
        "always": "constant",
        "any": "some",
        "anyPass": "overSome",
        "apply": "spread",
        "assoc": "set",
        "assocPath": "set",
        "complement": "negate",
        "compose": "flowRight",
        "contains": "includes",
        "dissoc": "unset",
        "dissocPath": "unset",
        "dropLast": "dropRight",
        "dropLastWhile": "dropRightWhile",
        "equals": "isEqual",
        "identical": "eq",
        "indexBy": "keyBy",
        "init": "initial",
        "invertObj": "invert",
        "juxt": "over",
        "omitAll": "omit",
        "nAry": "ary",
        "path": "get",
        "pathEq": "matchesProperty",
        "pathOr": "getOr",
        "paths": "at",
        "pickAll": "pick",
        "pipe": "flow",
        "pluck": "map",
        "prop": "get",
        "propEq": "matchesProperty",
        "propOr": "getOr",
        "props": "at",
        "symmetricDifference": "xor",
        "symmetricDifferenceBy": "xorBy",
        "symmetricDifferenceWith": "xorWith",
        "takeLast": "takeRight",
        "takeLastWhile": "takeRightWhile",
        "unapply": "rest",
        "unnest": "flatten",
        "useWith": "overArgs",
        "where": "conformsTo",
        "whereEq": "isMatch",
        "zipObj": "zipObject"
      };
      exports.aryMethod = {
        "1": [
          "assignAll",
          "assignInAll",
          "attempt",
          "castArray",
          "ceil",
          "create",
          "curry",
          "curryRight",
          "defaultsAll",
          "defaultsDeepAll",
          "floor",
          "flow",
          "flowRight",
          "fromPairs",
          "invert",
          "iteratee",
          "memoize",
          "method",
          "mergeAll",
          "methodOf",
          "mixin",
          "nthArg",
          "over",
          "overEvery",
          "overSome",
          "rest",
          "reverse",
          "round",
          "runInContext",
          "spread",
          "template",
          "trim",
          "trimEnd",
          "trimStart",
          "uniqueId",
          "words",
          "zipAll"
        ],
        "2": [
          "add",
          "after",
          "ary",
          "assign",
          "assignAllWith",
          "assignIn",
          "assignInAllWith",
          "at",
          "before",
          "bind",
          "bindAll",
          "bindKey",
          "chunk",
          "cloneDeepWith",
          "cloneWith",
          "concat",
          "conformsTo",
          "countBy",
          "curryN",
          "curryRightN",
          "debounce",
          "defaults",
          "defaultsDeep",
          "defaultTo",
          "delay",
          "difference",
          "divide",
          "drop",
          "dropRight",
          "dropRightWhile",
          "dropWhile",
          "endsWith",
          "eq",
          "every",
          "filter",
          "find",
          "findIndex",
          "findKey",
          "findLast",
          "findLastIndex",
          "findLastKey",
          "flatMap",
          "flatMapDeep",
          "flattenDepth",
          "forEach",
          "forEachRight",
          "forIn",
          "forInRight",
          "forOwn",
          "forOwnRight",
          "get",
          "groupBy",
          "gt",
          "gte",
          "has",
          "hasIn",
          "includes",
          "indexOf",
          "intersection",
          "invertBy",
          "invoke",
          "invokeMap",
          "isEqual",
          "isMatch",
          "join",
          "keyBy",
          "lastIndexOf",
          "lt",
          "lte",
          "map",
          "mapKeys",
          "mapValues",
          "matchesProperty",
          "maxBy",
          "meanBy",
          "merge",
          "mergeAllWith",
          "minBy",
          "multiply",
          "nth",
          "omit",
          "omitBy",
          "overArgs",
          "pad",
          "padEnd",
          "padStart",
          "parseInt",
          "partial",
          "partialRight",
          "partition",
          "pick",
          "pickBy",
          "propertyOf",
          "pull",
          "pullAll",
          "pullAt",
          "random",
          "range",
          "rangeRight",
          "rearg",
          "reject",
          "remove",
          "repeat",
          "restFrom",
          "result",
          "sampleSize",
          "some",
          "sortBy",
          "sortedIndex",
          "sortedIndexOf",
          "sortedLastIndex",
          "sortedLastIndexOf",
          "sortedUniqBy",
          "split",
          "spreadFrom",
          "startsWith",
          "subtract",
          "sumBy",
          "take",
          "takeRight",
          "takeRightWhile",
          "takeWhile",
          "tap",
          "throttle",
          "thru",
          "times",
          "trimChars",
          "trimCharsEnd",
          "trimCharsStart",
          "truncate",
          "union",
          "uniqBy",
          "uniqWith",
          "unset",
          "unzipWith",
          "without",
          "wrap",
          "xor",
          "zip",
          "zipObject",
          "zipObjectDeep"
        ],
        "3": [
          "assignInWith",
          "assignWith",
          "clamp",
          "differenceBy",
          "differenceWith",
          "findFrom",
          "findIndexFrom",
          "findLastFrom",
          "findLastIndexFrom",
          "getOr",
          "includesFrom",
          "indexOfFrom",
          "inRange",
          "intersectionBy",
          "intersectionWith",
          "invokeArgs",
          "invokeArgsMap",
          "isEqualWith",
          "isMatchWith",
          "flatMapDepth",
          "lastIndexOfFrom",
          "mergeWith",
          "orderBy",
          "padChars",
          "padCharsEnd",
          "padCharsStart",
          "pullAllBy",
          "pullAllWith",
          "rangeStep",
          "rangeStepRight",
          "reduce",
          "reduceRight",
          "replace",
          "set",
          "slice",
          "sortedIndexBy",
          "sortedLastIndexBy",
          "transform",
          "unionBy",
          "unionWith",
          "update",
          "xorBy",
          "xorWith",
          "zipWith"
        ],
        "4": [
          "fill",
          "setWith",
          "updateWith"
        ]
      };
      exports.aryRearg = {
        "2": [1, 0],
        "3": [2, 0, 1],
        "4": [3, 2, 0, 1]
      };
      exports.iterateeAry = {
        "dropRightWhile": 1,
        "dropWhile": 1,
        "every": 1,
        "filter": 1,
        "find": 1,
        "findFrom": 1,
        "findIndex": 1,
        "findIndexFrom": 1,
        "findKey": 1,
        "findLast": 1,
        "findLastFrom": 1,
        "findLastIndex": 1,
        "findLastIndexFrom": 1,
        "findLastKey": 1,
        "flatMap": 1,
        "flatMapDeep": 1,
        "flatMapDepth": 1,
        "forEach": 1,
        "forEachRight": 1,
        "forIn": 1,
        "forInRight": 1,
        "forOwn": 1,
        "forOwnRight": 1,
        "map": 1,
        "mapKeys": 1,
        "mapValues": 1,
        "partition": 1,
        "reduce": 2,
        "reduceRight": 2,
        "reject": 1,
        "remove": 1,
        "some": 1,
        "takeRightWhile": 1,
        "takeWhile": 1,
        "times": 1,
        "transform": 2
      };
      exports.iterateeRearg = {
        "mapKeys": [1],
        "reduceRight": [1, 0]
      };
      exports.methodRearg = {
        "assignInAllWith": [1, 0],
        "assignInWith": [1, 2, 0],
        "assignAllWith": [1, 0],
        "assignWith": [1, 2, 0],
        "differenceBy": [1, 2, 0],
        "differenceWith": [1, 2, 0],
        "getOr": [2, 1, 0],
        "intersectionBy": [1, 2, 0],
        "intersectionWith": [1, 2, 0],
        "isEqualWith": [1, 2, 0],
        "isMatchWith": [2, 1, 0],
        "mergeAllWith": [1, 0],
        "mergeWith": [1, 2, 0],
        "padChars": [2, 1, 0],
        "padCharsEnd": [2, 1, 0],
        "padCharsStart": [2, 1, 0],
        "pullAllBy": [2, 1, 0],
        "pullAllWith": [2, 1, 0],
        "rangeStep": [1, 2, 0],
        "rangeStepRight": [1, 2, 0],
        "setWith": [3, 1, 2, 0],
        "sortedIndexBy": [2, 1, 0],
        "sortedLastIndexBy": [2, 1, 0],
        "unionBy": [1, 2, 0],
        "unionWith": [1, 2, 0],
        "updateWith": [3, 1, 2, 0],
        "xorBy": [1, 2, 0],
        "xorWith": [1, 2, 0],
        "zipWith": [1, 2, 0]
      };
      exports.methodSpread = {
        "assignAll": { "start": 0 },
        "assignAllWith": { "start": 0 },
        "assignInAll": { "start": 0 },
        "assignInAllWith": { "start": 0 },
        "defaultsAll": { "start": 0 },
        "defaultsDeepAll": { "start": 0 },
        "invokeArgs": { "start": 2 },
        "invokeArgsMap": { "start": 2 },
        "mergeAll": { "start": 0 },
        "mergeAllWith": { "start": 0 },
        "partial": { "start": 1 },
        "partialRight": { "start": 1 },
        "without": { "start": 1 },
        "zipAll": { "start": 0 }
      };
      exports.mutate = {
        "array": {
          "fill": true,
          "pull": true,
          "pullAll": true,
          "pullAllBy": true,
          "pullAllWith": true,
          "pullAt": true,
          "remove": true,
          "reverse": true
        },
        "object": {
          "assign": true,
          "assignAll": true,
          "assignAllWith": true,
          "assignIn": true,
          "assignInAll": true,
          "assignInAllWith": true,
          "assignInWith": true,
          "assignWith": true,
          "defaults": true,
          "defaultsAll": true,
          "defaultsDeep": true,
          "defaultsDeepAll": true,
          "merge": true,
          "mergeAll": true,
          "mergeAllWith": true,
          "mergeWith": true
        },
        "set": {
          "set": true,
          "setWith": true,
          "unset": true,
          "update": true,
          "updateWith": true
        }
      };
      exports.realToAlias = function() {
        var hasOwnProperty2 = Object.prototype.hasOwnProperty, object2 = exports.aliasToReal, result = {};
        for (var key in object2) {
          var value = object2[key];
          if (hasOwnProperty2.call(result, value)) {
            result[value].push(key);
          } else {
            result[value] = [key];
          }
        }
        return result;
      }();
      exports.remap = {
        "assignAll": "assign",
        "assignAllWith": "assignWith",
        "assignInAll": "assignIn",
        "assignInAllWith": "assignInWith",
        "curryN": "curry",
        "curryRightN": "curryRight",
        "defaultsAll": "defaults",
        "defaultsDeepAll": "defaultsDeep",
        "findFrom": "find",
        "findIndexFrom": "findIndex",
        "findLastFrom": "findLast",
        "findLastIndexFrom": "findLastIndex",
        "getOr": "get",
        "includesFrom": "includes",
        "indexOfFrom": "indexOf",
        "invokeArgs": "invoke",
        "invokeArgsMap": "invokeMap",
        "lastIndexOfFrom": "lastIndexOf",
        "mergeAll": "merge",
        "mergeAllWith": "mergeWith",
        "padChars": "pad",
        "padCharsEnd": "padEnd",
        "padCharsStart": "padStart",
        "propertyOf": "get",
        "rangeStep": "range",
        "rangeStepRight": "rangeRight",
        "restFrom": "rest",
        "spreadFrom": "spread",
        "trimChars": "trim",
        "trimCharsEnd": "trimEnd",
        "trimCharsStart": "trimStart",
        "zipAll": "zip"
      };
      exports.skipFixed = {
        "castArray": true,
        "flow": true,
        "flowRight": true,
        "iteratee": true,
        "mixin": true,
        "rearg": true,
        "runInContext": true
      };
      exports.skipRearg = {
        "add": true,
        "assign": true,
        "assignIn": true,
        "bind": true,
        "bindKey": true,
        "concat": true,
        "difference": true,
        "divide": true,
        "eq": true,
        "gt": true,
        "gte": true,
        "isEqual": true,
        "lt": true,
        "lte": true,
        "matchesProperty": true,
        "merge": true,
        "multiply": true,
        "overArgs": true,
        "partial": true,
        "partialRight": true,
        "propertyOf": true,
        "random": true,
        "range": true,
        "rangeRight": true,
        "subtract": true,
        "zip": true,
        "zipObject": true,
        "zipObjectDeep": true
      };
    }
  });

  // node_modules/lodash/fp/placeholder.js
  var require_placeholder = __commonJS({
    "node_modules/lodash/fp/placeholder.js"(exports, module) {
      module.exports = {};
    }
  });

  // node_modules/lodash/fp/_baseConvert.js
  var require_baseConvert = __commonJS({
    "node_modules/lodash/fp/_baseConvert.js"(exports, module) {
      var mapping = require_mapping();
      var fallbackHolder = require_placeholder();
      var push = Array.prototype.push;
      function baseArity(func, n) {
        return n == 2 ? function(a, b) {
          return func.apply(void 0, arguments);
        } : function(a) {
          return func.apply(void 0, arguments);
        };
      }
      function baseAry(func, n) {
        return n == 2 ? function(a, b) {
          return func(a, b);
        } : function(a) {
          return func(a);
        };
      }
      function cloneArray(array2) {
        var length2 = array2 ? array2.length : 0, result = Array(length2);
        while (length2--) {
          result[length2] = array2[length2];
        }
        return result;
      }
      function createCloner(func) {
        return function(object2) {
          return func({}, object2);
        };
      }
      function flatSpread(func, start) {
        return function() {
          var length2 = arguments.length, lastIndex = length2 - 1, args = Array(length2);
          while (length2--) {
            args[length2] = arguments[length2];
          }
          var array2 = args[start], otherArgs = args.slice(0, start);
          if (array2) {
            push.apply(otherArgs, array2);
          }
          if (start != lastIndex) {
            push.apply(otherArgs, args.slice(start + 1));
          }
          return func.apply(this, otherArgs);
        };
      }
      function wrapImmutable(func, cloner) {
        return function() {
          var length2 = arguments.length;
          if (!length2) {
            return;
          }
          var args = Array(length2);
          while (length2--) {
            args[length2] = arguments[length2];
          }
          var result = args[0] = cloner.apply(void 0, args);
          func.apply(void 0, args);
          return result;
        };
      }
      function baseConvert(util, name, func, options) {
        var isLib = typeof name == "function", isObj = name === Object(name);
        if (isObj) {
          options = func;
          func = name;
          name = void 0;
        }
        if (func == null) {
          throw new TypeError();
        }
        options || (options = {});
        var config = {
          "cap": "cap" in options ? options.cap : true,
          "curry": "curry" in options ? options.curry : true,
          "fixed": "fixed" in options ? options.fixed : true,
          "immutable": "immutable" in options ? options.immutable : true,
          "rearg": "rearg" in options ? options.rearg : true
        };
        var defaultHolder = isLib ? func : fallbackHolder, forceCurry = "curry" in options && options.curry, forceFixed = "fixed" in options && options.fixed, forceRearg = "rearg" in options && options.rearg, pristine = isLib ? func.runInContext() : void 0;
        var helpers = isLib ? func : {
          "ary": util.ary,
          "assign": util.assign,
          "clone": util.clone,
          "curry": util.curry,
          "forEach": util.forEach,
          "isArray": util.isArray,
          "isError": util.isError,
          "isFunction": util.isFunction,
          "isWeakMap": util.isWeakMap,
          "iteratee": util.iteratee,
          "keys": util.keys,
          "rearg": util.rearg,
          "toInteger": util.toInteger,
          "toPath": util.toPath
        };
        var ary = helpers.ary, assign = helpers.assign, clone = helpers.clone, curry = helpers.curry, each = helpers.forEach, isArray = helpers.isArray, isError = helpers.isError, isFunction = helpers.isFunction, isWeakMap = helpers.isWeakMap, keys = helpers.keys, rearg = helpers.rearg, toInteger = helpers.toInteger, toPath = helpers.toPath;
        var aryMethodKeys = keys(mapping.aryMethod);
        var wrappers = {
          "castArray": function(castArray) {
            return function() {
              var value = arguments[0];
              return isArray(value) ? castArray(cloneArray(value)) : castArray.apply(void 0, arguments);
            };
          },
          "iteratee": function(iteratee) {
            return function() {
              var func2 = arguments[0], arity = arguments[1], result = iteratee(func2, arity), length2 = result.length;
              if (config.cap && typeof arity == "number") {
                arity = arity > 2 ? arity - 2 : 1;
                return length2 && length2 <= arity ? result : baseAry(result, arity);
              }
              return result;
            };
          },
          "mixin": function(mixin) {
            return function(source) {
              var func2 = this;
              if (!isFunction(func2)) {
                return mixin(func2, Object(source));
              }
              var pairs2 = [];
              each(keys(source), function(key) {
                if (isFunction(source[key])) {
                  pairs2.push([key, func2.prototype[key]]);
                }
              });
              mixin(func2, Object(source));
              each(pairs2, function(pair2) {
                var value = pair2[1];
                if (isFunction(value)) {
                  func2.prototype[pair2[0]] = value;
                } else {
                  delete func2.prototype[pair2[0]];
                }
              });
              return func2;
            };
          },
          "nthArg": function(nthArg) {
            return function(n) {
              var arity = n < 0 ? 1 : toInteger(n) + 1;
              return curry(nthArg(n), arity);
            };
          },
          "rearg": function(rearg2) {
            return function(func2, indexes) {
              var arity = indexes ? indexes.length : 0;
              return curry(rearg2(func2, indexes), arity);
            };
          },
          "runInContext": function(runInContext) {
            return function(context) {
              return baseConvert(util, runInContext(context), options);
            };
          }
        };
        function castCap(name2, func2) {
          if (config.cap) {
            var indexes = mapping.iterateeRearg[name2];
            if (indexes) {
              return iterateeRearg(func2, indexes);
            }
            var n = !isLib && mapping.iterateeAry[name2];
            if (n) {
              return iterateeAry(func2, n);
            }
          }
          return func2;
        }
        function castCurry(name2, func2, n) {
          return forceCurry || config.curry && n > 1 ? curry(func2, n) : func2;
        }
        function castFixed(name2, func2, n) {
          if (config.fixed && (forceFixed || !mapping.skipFixed[name2])) {
            var data = mapping.methodSpread[name2], start = data && data.start;
            return start === void 0 ? ary(func2, n) : flatSpread(func2, start);
          }
          return func2;
        }
        function castRearg(name2, func2, n) {
          return config.rearg && n > 1 && (forceRearg || !mapping.skipRearg[name2]) ? rearg(func2, mapping.methodRearg[name2] || mapping.aryRearg[n]) : func2;
        }
        function cloneByPath(object2, path) {
          path = toPath(path);
          var index = -1, length2 = path.length, lastIndex = length2 - 1, result = clone(Object(object2)), nested = result;
          while (nested != null && ++index < length2) {
            var key = path[index], value = nested[key];
            if (value != null && !(isFunction(value) || isError(value) || isWeakMap(value))) {
              nested[key] = clone(index == lastIndex ? value : Object(value));
            }
            nested = nested[key];
          }
          return result;
        }
        function convertLib(options2) {
          return _.runInContext.convert(options2)(void 0);
        }
        function createConverter(name2, func2) {
          var realName = mapping.aliasToReal[name2] || name2, methodName = mapping.remap[realName] || realName, oldOptions = options;
          return function(options2) {
            var newUtil = isLib ? pristine : helpers, newFunc = isLib ? pristine[methodName] : func2, newOptions = assign(assign({}, oldOptions), options2);
            return baseConvert(newUtil, realName, newFunc, newOptions);
          };
        }
        function iterateeAry(func2, n) {
          return overArg(func2, function(func3) {
            return typeof func3 == "function" ? baseAry(func3, n) : func3;
          });
        }
        function iterateeRearg(func2, indexes) {
          return overArg(func2, function(func3) {
            var n = indexes.length;
            return baseArity(rearg(baseAry(func3, n), indexes), n);
          });
        }
        function overArg(func2, transform) {
          return function() {
            var length2 = arguments.length;
            if (!length2) {
              return func2();
            }
            var args = Array(length2);
            while (length2--) {
              args[length2] = arguments[length2];
            }
            var index = config.rearg ? 0 : length2 - 1;
            args[index] = transform(args[index]);
            return func2.apply(void 0, args);
          };
        }
        function wrap(name2, func2, placeholder) {
          var result, realName = mapping.aliasToReal[name2] || name2, wrapped = func2, wrapper = wrappers[realName];
          if (wrapper) {
            wrapped = wrapper(func2);
          } else if (config.immutable) {
            if (mapping.mutate.array[realName]) {
              wrapped = wrapImmutable(func2, cloneArray);
            } else if (mapping.mutate.object[realName]) {
              wrapped = wrapImmutable(func2, createCloner(func2));
            } else if (mapping.mutate.set[realName]) {
              wrapped = wrapImmutable(func2, cloneByPath);
            }
          }
          each(aryMethodKeys, function(aryKey) {
            each(mapping.aryMethod[aryKey], function(otherName) {
              if (realName == otherName) {
                var data = mapping.methodSpread[realName], afterRearg = data && data.afterRearg;
                result = afterRearg ? castFixed(realName, castRearg(realName, wrapped, aryKey), aryKey) : castRearg(realName, castFixed(realName, wrapped, aryKey), aryKey);
                result = castCap(realName, result);
                result = castCurry(realName, result, aryKey);
                return false;
              }
            });
            return !result;
          });
          result || (result = wrapped);
          if (result == func2) {
            result = forceCurry ? curry(result, 1) : function() {
              return func2.apply(this, arguments);
            };
          }
          result.convert = createConverter(realName, func2);
          result.placeholder = func2.placeholder = placeholder;
          return result;
        }
        if (!isObj) {
          return wrap(name, func, defaultHolder);
        }
        var _ = func;
        var pairs = [];
        each(aryMethodKeys, function(aryKey) {
          each(mapping.aryMethod[aryKey], function(key) {
            var func2 = _[mapping.remap[key] || key];
            if (func2) {
              pairs.push([key, wrap(key, func2, _)]);
            }
          });
        });
        each(keys(_), function(key) {
          var func2 = _[key];
          if (typeof func2 == "function") {
            var length2 = pairs.length;
            while (length2--) {
              if (pairs[length2][0] == key) {
                return;
              }
            }
            func2.convert = createConverter(key, func2);
            pairs.push([key, func2]);
          }
        });
        each(pairs, function(pair2) {
          _[pair2[0]] = pair2[1];
        });
        _.convert = convertLib;
        _.placeholder = _;
        each(keys(_), function(key) {
          each(mapping.realToAlias[key] || [], function(alias) {
            _[alias] = _[key];
          });
        });
        return _;
      }
      module.exports = baseConvert;
    }
  });

  // node_modules/lodash/fp.js
  var require_fp = __commonJS({
    "node_modules/lodash/fp.js"(exports, module) {
      var _ = require_lodash_min().runInContext();
      module.exports = require_baseConvert()(_, _);
    }
  });

  // node_modules/@turf/helpers/dist/es/index.js
  var earthRadius = 63710088e-1;
  var factors = {
    centimeters: earthRadius * 100,
    centimetres: earthRadius * 100,
    degrees: earthRadius / 111325,
    feet: earthRadius * 3.28084,
    inches: earthRadius * 39.37,
    kilometers: earthRadius / 1e3,
    kilometres: earthRadius / 1e3,
    meters: earthRadius,
    metres: earthRadius,
    miles: earthRadius / 1609.344,
    millimeters: earthRadius * 1e3,
    millimetres: earthRadius * 1e3,
    nauticalmiles: earthRadius / 1852,
    radians: 1,
    yards: earthRadius * 1.0936
  };
  var unitsFactors = {
    centimeters: 100,
    centimetres: 100,
    degrees: 1 / 111325,
    feet: 3.28084,
    inches: 39.37,
    kilometers: 1 / 1e3,
    kilometres: 1 / 1e3,
    meters: 1,
    metres: 1,
    miles: 1 / 1609.344,
    millimeters: 1e3,
    millimetres: 1e3,
    nauticalmiles: 1 / 1852,
    radians: 1 / earthRadius,
    yards: 1.0936133
  };
  function feature(geom, properties, options) {
    if (options === void 0) {
      options = {};
    }
    var feat = { type: "Feature" };
    if (options.id === 0 || options.id) {
      feat.id = options.id;
    }
    if (options.bbox) {
      feat.bbox = options.bbox;
    }
    feat.properties = properties || {};
    feat.geometry = geom;
    return feat;
  }
  function point(coordinates, properties, options) {
    if (options === void 0) {
      options = {};
    }
    if (!coordinates) {
      throw new Error("coordinates is required");
    }
    if (!Array.isArray(coordinates)) {
      throw new Error("coordinates must be an Array");
    }
    if (coordinates.length < 2) {
      throw new Error("coordinates must be at least 2 numbers long");
    }
    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {
      throw new Error("coordinates must contain numbers");
    }
    var geom = {
      type: "Point",
      coordinates
    };
    return feature(geom, properties, options);
  }
  function polygon(coordinates, properties, options) {
    if (options === void 0) {
      options = {};
    }
    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {
      var ring = coordinates_1[_i];
      if (ring.length < 4) {
        throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
      }
      for (var j = 0; j < ring[ring.length - 1].length; j++) {
        if (ring[ring.length - 1][j] !== ring[0][j]) {
          throw new Error("First and last Position are not equivalent.");
        }
      }
    }
    var geom = {
      type: "Polygon",
      coordinates
    };
    return feature(geom, properties, options);
  }
  function lineString(coordinates, properties, options) {
    if (options === void 0) {
      options = {};
    }
    if (coordinates.length < 2) {
      throw new Error("coordinates must be an array of two or more positions");
    }
    var geom = {
      type: "LineString",
      coordinates
    };
    return feature(geom, properties, options);
  }
  function featureCollection(features, options) {
    if (options === void 0) {
      options = {};
    }
    var fc = { type: "FeatureCollection" };
    if (options.id) {
      fc.id = options.id;
    }
    if (options.bbox) {
      fc.bbox = options.bbox;
    }
    fc.features = features;
    return fc;
  }
  function multiPoint(coordinates, properties, options) {
    if (options === void 0) {
      options = {};
    }
    var geom = {
      type: "MultiPoint",
      coordinates
    };
    return feature(geom, properties, options);
  }
  function radiansToLength(radians3, units) {
    if (units === void 0) {
      units = "kilometers";
    }
    var factor = factors[units];
    if (!factor) {
      throw new Error(units + " units is invalid");
    }
    return radians3 * factor;
  }
  function lengthToRadians(distance2, units) {
    if (units === void 0) {
      units = "kilometers";
    }
    var factor = factors[units];
    if (!factor) {
      throw new Error(units + " units is invalid");
    }
    return distance2 / factor;
  }
  function radiansToDegrees(radians3) {
    var degrees3 = radians3 % (2 * Math.PI);
    return degrees3 * 180 / Math.PI;
  }
  function degreesToRadians(degrees3) {
    var radians3 = degrees3 % 360;
    return radians3 * Math.PI / 180;
  }
  function isNumber(num) {
    return !isNaN(num) && num !== null && !Array.isArray(num);
  }

  // node_modules/@turf/invariant/dist/es/index.js
  function getCoord(coord) {
    if (!coord) {
      throw new Error("coord is required");
    }
    if (!Array.isArray(coord)) {
      if (coord.type === "Feature" && coord.geometry !== null && coord.geometry.type === "Point") {
        return coord.geometry.coordinates;
      }
      if (coord.type === "Point") {
        return coord.coordinates;
      }
    }
    if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {
      return coord;
    }
    throw new Error("coord must be GeoJSON Point or an Array of numbers");
  }
  function getCoords(coords) {
    if (Array.isArray(coords)) {
      return coords;
    }
    if (coords.type === "Feature") {
      if (coords.geometry !== null) {
        return coords.geometry.coordinates;
      }
    } else {
      if (coords.coordinates) {
        return coords.coordinates;
      }
    }
    throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
  }
  function featureOf(feature2, type, name) {
    if (!feature2) {
      throw new Error("No feature passed");
    }
    if (!name) {
      throw new Error(".featureOf() requires a name");
    }
    if (!feature2 || feature2.type !== "Feature" || !feature2.geometry) {
      throw new Error("Invalid input to " + name + ", Feature with geometry required");
    }
    if (!feature2.geometry || feature2.geometry.type !== type) {
      throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature2.geometry.type);
    }
  }
  function getGeom(geojson) {
    if (geojson.type === "Feature") {
      return geojson.geometry;
    }
    return geojson;
  }
  function getType(geojson, _name) {
    if (geojson.type === "FeatureCollection") {
      return "FeatureCollection";
    }
    if (geojson.type === "GeometryCollection") {
      return "GeometryCollection";
    }
    if (geojson.type === "Feature" && geojson.geometry !== null) {
      return geojson.geometry.type;
    }
    return geojson.type;
  }

  // node_modules/@turf/distance/dist/es/index.js
  function distance(from, to, options) {
    if (options === void 0) {
      options = {};
    }
    var coordinates1 = getCoord(from);
    var coordinates2 = getCoord(to);
    var dLat = degreesToRadians(coordinates2[1] - coordinates1[1]);
    var dLon = degreesToRadians(coordinates2[0] - coordinates1[0]);
    var lat1 = degreesToRadians(coordinates1[1]);
    var lat2 = degreesToRadians(coordinates2[1]);
    var a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);
    return radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), options.units);
  }
  var es_default = distance;

  // node_modules/@turf/meta/dist/es/index.js
  function coordEach(geojson, callback, excludeWrapCoord) {
    if (geojson === null)
      return;
    var j, k, l, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === "FeatureCollection", isFeature = type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
      geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;
      isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
      stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
      for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
        var multiFeatureIndex = 0;
        var geometryIndex = 0;
        geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;
        if (geometry === null)
          continue;
        coords = geometry.coordinates;
        var geomType = geometry.type;
        wrapShrink = excludeWrapCoord && (geomType === "Polygon" || geomType === "MultiPolygon") ? 1 : 0;
        switch (geomType) {
          case null:
            break;
          case "Point":
            if (callback(
              coords,
              coordIndex,
              featureIndex,
              multiFeatureIndex,
              geometryIndex
            ) === false)
              return false;
            coordIndex++;
            multiFeatureIndex++;
            break;
          case "LineString":
          case "MultiPoint":
            for (j = 0; j < coords.length; j++) {
              if (callback(
                coords[j],
                coordIndex,
                featureIndex,
                multiFeatureIndex,
                geometryIndex
              ) === false)
                return false;
              coordIndex++;
              if (geomType === "MultiPoint")
                multiFeatureIndex++;
            }
            if (geomType === "LineString")
              multiFeatureIndex++;
            break;
          case "Polygon":
          case "MultiLineString":
            for (j = 0; j < coords.length; j++) {
              for (k = 0; k < coords[j].length - wrapShrink; k++) {
                if (callback(
                  coords[j][k],
                  coordIndex,
                  featureIndex,
                  multiFeatureIndex,
                  geometryIndex
                ) === false)
                  return false;
                coordIndex++;
              }
              if (geomType === "MultiLineString")
                multiFeatureIndex++;
              if (geomType === "Polygon")
                geometryIndex++;
            }
            if (geomType === "Polygon")
              multiFeatureIndex++;
            break;
          case "MultiPolygon":
            for (j = 0; j < coords.length; j++) {
              geometryIndex = 0;
              for (k = 0; k < coords[j].length; k++) {
                for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                  if (callback(
                    coords[j][k][l],
                    coordIndex,
                    featureIndex,
                    multiFeatureIndex,
                    geometryIndex
                  ) === false)
                    return false;
                  coordIndex++;
                }
                geometryIndex++;
              }
              multiFeatureIndex++;
            }
            break;
          case "GeometryCollection":
            for (j = 0; j < geometry.geometries.length; j++)
              if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false)
                return false;
            break;
          default:
            throw new Error("Unknown Geometry Type");
        }
      }
    }
  }
  function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {
    var previousValue = initialValue;
    coordEach(
      geojson,
      function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
        if (coordIndex === 0 && initialValue === void 0)
          previousValue = currentCoord;
        else
          previousValue = callback(
            previousValue,
            currentCoord,
            coordIndex,
            featureIndex,
            multiFeatureIndex,
            geometryIndex
          );
      },
      excludeWrapCoord
    );
    return previousValue;
  }
  function featureEach(geojson, callback) {
    if (geojson.type === "Feature") {
      callback(geojson, 0);
    } else if (geojson.type === "FeatureCollection") {
      for (var i = 0; i < geojson.features.length; i++) {
        if (callback(geojson.features[i], i) === false)
          break;
      }
    }
  }
  function geomEach(geojson, callback) {
    var i, j, g, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === "FeatureCollection", isFeature = geojson.type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
    for (i = 0; i < stop; i++) {
      geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;
      featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};
      featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;
      featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;
      isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
      stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
      for (g = 0; g < stopG; g++) {
        geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;
        if (geometry === null) {
          if (callback(
            null,
            featureIndex,
            featureProperties,
            featureBBox,
            featureId
          ) === false)
            return false;
          continue;
        }
        switch (geometry.type) {
          case "Point":
          case "LineString":
          case "MultiPoint":
          case "Polygon":
          case "MultiLineString":
          case "MultiPolygon": {
            if (callback(
              geometry,
              featureIndex,
              featureProperties,
              featureBBox,
              featureId
            ) === false)
              return false;
            break;
          }
          case "GeometryCollection": {
            for (j = 0; j < geometry.geometries.length; j++) {
              if (callback(
                geometry.geometries[j],
                featureIndex,
                featureProperties,
                featureBBox,
                featureId
              ) === false)
                return false;
            }
            break;
          }
          default:
            throw new Error("Unknown Geometry Type");
        }
      }
      featureIndex++;
    }
  }
  function flattenEach(geojson, callback) {
    geomEach(geojson, function(geometry, featureIndex, properties, bbox3, id) {
      var type = geometry === null ? null : geometry.type;
      switch (type) {
        case null:
        case "Point":
        case "LineString":
        case "Polygon":
          if (callback(
            feature(geometry, properties, { bbox: bbox3, id }),
            featureIndex,
            0
          ) === false)
            return false;
          return;
      }
      var geomType;
      switch (type) {
        case "MultiPoint":
          geomType = "Point";
          break;
        case "MultiLineString":
          geomType = "LineString";
          break;
        case "MultiPolygon":
          geomType = "Polygon";
          break;
      }
      for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {
        var coordinate = geometry.coordinates[multiFeatureIndex];
        var geom = {
          type: geomType,
          coordinates: coordinate
        };
        if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false)
          return false;
      }
    });
  }
  function segmentEach(geojson, callback) {
    flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {
      var segmentIndex = 0;
      if (!feature2.geometry)
        return;
      var type = feature2.geometry.type;
      if (type === "Point" || type === "MultiPoint")
        return;
      var previousCoords;
      var previousFeatureIndex = 0;
      var previousMultiIndex = 0;
      var prevGeomIndex = 0;
      if (coordEach(
        feature2,
        function(currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {
          if (previousCoords === void 0 || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {
            previousCoords = currentCoord;
            previousFeatureIndex = featureIndex;
            previousMultiIndex = multiPartIndexCoord;
            prevGeomIndex = geometryIndex;
            segmentIndex = 0;
            return;
          }
          var currentSegment = lineString(
            [previousCoords, currentCoord],
            feature2.properties
          );
          if (callback(
            currentSegment,
            featureIndex,
            multiFeatureIndex,
            geometryIndex,
            segmentIndex
          ) === false)
            return false;
          segmentIndex++;
          previousCoords = currentCoord;
        }
      ) === false)
        return false;
    });
  }
  function segmentReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    var started = false;
    segmentEach(
      geojson,
      function(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
        if (started === false && initialValue === void 0)
          previousValue = currentSegment;
        else
          previousValue = callback(
            previousValue,
            currentSegment,
            featureIndex,
            multiFeatureIndex,
            geometryIndex,
            segmentIndex
          );
        started = true;
      }
    );
    return previousValue;
  }

  // node_modules/@turf/length/dist/es/index.js
  function length(geojson, options) {
    if (options === void 0) {
      options = {};
    }
    return segmentReduce(geojson, function(previousValue, segment) {
      var coords = segment.geometry.coordinates;
      return previousValue + es_default(coords[0], coords[1], options);
    }, 0);
  }

  // node_modules/@turf/bearing/dist/es/index.js
  function bearing(start, end, options) {
    if (options === void 0) {
      options = {};
    }
    if (options.final === true) {
      return calculateFinalBearing(start, end);
    }
    var coordinates1 = getCoord(start);
    var coordinates2 = getCoord(end);
    var lon1 = degreesToRadians(coordinates1[0]);
    var lon2 = degreesToRadians(coordinates2[0]);
    var lat1 = degreesToRadians(coordinates1[1]);
    var lat2 = degreesToRadians(coordinates2[1]);
    var a = Math.sin(lon2 - lon1) * Math.cos(lat2);
    var b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
    return radiansToDegrees(Math.atan2(a, b));
  }
  function calculateFinalBearing(start, end) {
    var bear = bearing(end, start);
    bear = (bear + 180) % 360;
    return bear;
  }

  // node_modules/@turf/destination/dist/es/index.js
  function destination(origin, distance2, bearing2, options) {
    if (options === void 0) {
      options = {};
    }
    var coordinates1 = getCoord(origin);
    var longitude1 = degreesToRadians(coordinates1[0]);
    var latitude1 = degreesToRadians(coordinates1[1]);
    var bearingRad = degreesToRadians(bearing2);
    var radians3 = lengthToRadians(distance2, options.units);
    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians3) + Math.cos(latitude1) * Math.sin(radians3) * Math.cos(bearingRad));
    var longitude2 = longitude1 + Math.atan2(Math.sin(bearingRad) * Math.sin(radians3) * Math.cos(latitude1), Math.cos(radians3) - Math.sin(latitude1) * Math.sin(latitude2));
    var lng = radiansToDegrees(longitude2);
    var lat = radiansToDegrees(latitude2);
    return point([lng, lat], options.properties);
  }

  // node_modules/@turf/line-segment/dist/es/index.js
  function lineSegment(geojson) {
    if (!geojson) {
      throw new Error("geojson is required");
    }
    var results = [];
    flattenEach(geojson, function(feature2) {
      lineSegmentFeature(feature2, results);
    });
    return featureCollection(results);
  }
  function lineSegmentFeature(geojson, results) {
    var coords = [];
    var geometry = geojson.geometry;
    if (geometry !== null) {
      switch (geometry.type) {
        case "Polygon":
          coords = getCoords(geometry);
          break;
        case "LineString":
          coords = [getCoords(geometry)];
      }
      coords.forEach(function(coord) {
        var segments = createSegments(coord, geojson.properties);
        segments.forEach(function(segment) {
          segment.id = results.length;
          results.push(segment);
        });
      });
    }
  }
  function createSegments(coords, properties) {
    var segments = [];
    coords.reduce(function(previousCoords, currentCoords) {
      var segment = lineString([previousCoords, currentCoords], properties);
      segment.bbox = bbox(previousCoords, currentCoords);
      segments.push(segment);
      return currentCoords;
    });
    return segments;
  }
  function bbox(coords1, coords2) {
    var x12 = coords1[0];
    var y1 = coords1[1];
    var x2 = coords2[0];
    var y2 = coords2[1];
    var west = x12 < x2 ? x12 : x2;
    var south = y1 < y2 ? y1 : y2;
    var east = x12 > x2 ? x12 : x2;
    var north = y1 > y2 ? y1 : y2;
    return [west, south, east, north];
  }
  var es_default2 = lineSegment;

  // node_modules/@turf/line-intersect/dist/es/index.js
  var import_geojson_rbush = __toESM(require_geojson_rbush(), 1);
  function lineIntersect(line1, line2) {
    var unique = {};
    var results = [];
    if (line1.type === "LineString") {
      line1 = feature(line1);
    }
    if (line2.type === "LineString") {
      line2 = feature(line2);
    }
    if (line1.type === "Feature" && line2.type === "Feature" && line1.geometry !== null && line2.geometry !== null && line1.geometry.type === "LineString" && line2.geometry.type === "LineString" && line1.geometry.coordinates.length === 2 && line2.geometry.coordinates.length === 2) {
      var intersect2 = intersects(line1, line2);
      if (intersect2) {
        results.push(intersect2);
      }
      return featureCollection(results);
    }
    var tree = (0, import_geojson_rbush.default)();
    tree.load(es_default2(line2));
    featureEach(es_default2(line1), function(segment) {
      featureEach(tree.search(segment), function(match) {
        var intersect3 = intersects(segment, match);
        if (intersect3) {
          var key = getCoords(intersect3).join(",");
          if (!unique[key]) {
            unique[key] = true;
            results.push(intersect3);
          }
        }
      });
    });
    return featureCollection(results);
  }
  function intersects(line1, line2) {
    var coords1 = getCoords(line1);
    var coords2 = getCoords(line2);
    if (coords1.length !== 2) {
      throw new Error("<intersects> line1 must only contain 2 coordinates");
    }
    if (coords2.length !== 2) {
      throw new Error("<intersects> line2 must only contain 2 coordinates");
    }
    var x12 = coords1[0][0];
    var y1 = coords1[0][1];
    var x2 = coords1[1][0];
    var y2 = coords1[1][1];
    var x3 = coords2[0][0];
    var y3 = coords2[0][1];
    var x4 = coords2[1][0];
    var y4 = coords2[1][1];
    var denom = (y4 - y3) * (x2 - x12) - (x4 - x3) * (y2 - y1);
    var numeA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x12 - x3);
    var numeB = (x2 - x12) * (y1 - y3) - (y2 - y1) * (x12 - x3);
    if (denom === 0) {
      if (numeA === 0 && numeB === 0) {
        return null;
      }
      return null;
    }
    var uA = numeA / denom;
    var uB = numeB / denom;
    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {
      var x5 = x12 + uA * (x2 - x12);
      var y5 = y1 + uA * (y2 - y1);
      return point([x5, y5]);
    }
    return null;
  }
  var es_default3 = lineIntersect;

  // node_modules/@turf/nearest-point-on-line/dist/es/index.js
  function nearestPointOnLine(lines, pt, options) {
    if (options === void 0) {
      options = {};
    }
    var closestPt = point([Infinity, Infinity], {
      dist: Infinity
    });
    var length2 = 0;
    flattenEach(lines, function(line) {
      var coords = getCoords(line);
      for (var i = 0; i < coords.length - 1; i++) {
        var start = point(coords[i]);
        start.properties.dist = es_default(pt, start, options);
        var stop_1 = point(coords[i + 1]);
        stop_1.properties.dist = es_default(pt, stop_1, options);
        var sectionLength = es_default(start, stop_1, options);
        var heightDistance = Math.max(start.properties.dist, stop_1.properties.dist);
        var direction = bearing(start, stop_1);
        var perpendicularPt1 = destination(pt, heightDistance, direction + 90, options);
        var perpendicularPt2 = destination(pt, heightDistance, direction - 90, options);
        var intersect2 = es_default3(lineString([
          perpendicularPt1.geometry.coordinates,
          perpendicularPt2.geometry.coordinates
        ]), lineString([start.geometry.coordinates, stop_1.geometry.coordinates]));
        var intersectPt = null;
        if (intersect2.features.length > 0) {
          intersectPt = intersect2.features[0];
          intersectPt.properties.dist = es_default(pt, intersectPt, options);
          intersectPt.properties.location = length2 + es_default(start, intersectPt, options);
        }
        if (start.properties.dist < closestPt.properties.dist) {
          closestPt = start;
          closestPt.properties.index = i;
          closestPt.properties.location = length2;
        }
        if (stop_1.properties.dist < closestPt.properties.dist) {
          closestPt = stop_1;
          closestPt.properties.index = i + 1;
          closestPt.properties.location = length2 + sectionLength;
        }
        if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {
          closestPt = intersectPt;
          closestPt.properties.index = i;
        }
        length2 += sectionLength;
      }
    });
    return closestPt;
  }
  var es_default4 = nearestPointOnLine;

  // node_modules/@turf/line-slice/dist/es/index.js
  function lineSlice(startPt, stopPt, line) {
    var coords = getCoords(line);
    if (getType(line) !== "LineString")
      throw new Error("line must be a LineString");
    var startVertex = es_default4(line, startPt);
    var stopVertex = es_default4(line, stopPt);
    var ends;
    if (startVertex.properties.index <= stopVertex.properties.index) {
      ends = [startVertex, stopVertex];
    } else {
      ends = [stopVertex, startVertex];
    }
    var clipCoords = [ends[0].geometry.coordinates];
    for (var i = ends[0].properties.index + 1; i < ends[1].properties.index + 1; i++) {
      clipCoords.push(coords[i]);
    }
    clipCoords.push(ends[1].geometry.coordinates);
    return lineString(clipCoords, line.properties);
  }
  var es_default5 = lineSlice;

  // libs/shared/utils/src/lib/geometry/line-calculations.ts
  var O = __toESM(require_Option());
  var import_function2 = __toESM(require_function());

  // node_modules/@turf/bbox/dist/es/index.js
  function bbox2(geojson) {
    var result = [Infinity, Infinity, -Infinity, -Infinity];
    coordEach(geojson, function(coord) {
      if (result[0] > coord[0]) {
        result[0] = coord[0];
      }
      if (result[1] > coord[1]) {
        result[1] = coord[1];
      }
      if (result[2] < coord[0]) {
        result[2] = coord[0];
      }
      if (result[3] < coord[1]) {
        result[3] = coord[1];
      }
    });
    return result;
  }
  bbox2["default"] = bbox2;
  var es_default6 = bbox2;

  // node_modules/@turf/isolines/dist/es/index.js
  var import_object_assign = __toESM(require_object_assign(), 1);

  // node_modules/@turf/convex/dist/es/index.js
  var import_concaveman = __toESM(require_concaveman(), 1);

  // node_modules/@turf/boolean-point-in-polygon/dist/es/index.js
  function booleanPointInPolygon(point2, polygon2, options) {
    if (options === void 0) {
      options = {};
    }
    if (!point2) {
      throw new Error("point is required");
    }
    if (!polygon2) {
      throw new Error("polygon is required");
    }
    var pt = getCoord(point2);
    var geom = getGeom(polygon2);
    var type = geom.type;
    var bbox3 = polygon2.bbox;
    var polys = geom.coordinates;
    if (bbox3 && inBBox(pt, bbox3) === false) {
      return false;
    }
    if (type === "Polygon") {
      polys = [polys];
    }
    var insidePoly = false;
    for (var i = 0; i < polys.length && !insidePoly; i++) {
      if (inRing(pt, polys[i][0], options.ignoreBoundary)) {
        var inHole = false;
        var k = 1;
        while (k < polys[i].length && !inHole) {
          if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {
            inHole = true;
          }
          k++;
        }
        if (!inHole) {
          insidePoly = true;
        }
      }
    }
    return insidePoly;
  }
  function inRing(pt, ring, ignoreBoundary) {
    var isInside = false;
    if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) {
      ring = ring.slice(0, ring.length - 1);
    }
    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
      var xi = ring[i][0];
      var yi = ring[i][1];
      var xj = ring[j][0];
      var yj = ring[j][1];
      var onBoundary = pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0 && (xi - pt[0]) * (xj - pt[0]) <= 0 && (yi - pt[1]) * (yj - pt[1]) <= 0;
      if (onBoundary) {
        return !ignoreBoundary;
      }
      var intersect2 = yi > pt[1] !== yj > pt[1] && pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi;
      if (intersect2) {
        isInside = !isInside;
      }
    }
    return isInside;
  }
  function inBBox(pt, bbox3) {
    return bbox3[0] <= pt[0] && bbox3[1] <= pt[1] && bbox3[2] >= pt[0] && bbox3[3] >= pt[1];
  }

  // node_modules/@turf/tin/dist/es/index.js
  var Triangle = function() {
    function Triangle2(a, b, c) {
      this.a = a;
      this.b = b;
      this.c = c;
      var A = b.x - a.x;
      var B2 = b.y - a.y;
      var C = c.x - a.x;
      var D = c.y - a.y;
      var E = A * (a.x + b.x) + B2 * (a.y + b.y);
      var F = C * (a.x + c.x) + D * (a.y + c.y);
      var G = 2 * (A * (c.y - b.y) - B2 * (c.x - b.x));
      var dx;
      var dy;
      this.x = (D * E - B2 * F) / G;
      this.y = (A * F - C * E) / G;
      dx = this.x - a.x;
      dy = this.y - a.y;
      this.r = dx * dx + dy * dy;
    }
    return Triangle2;
  }();

  // node_modules/topojson-server/src/hash/point-hash.js
  var buffer = new ArrayBuffer(16);
  var floats = new Float64Array(buffer);
  var uints = new Uint32Array(buffer);

  // node_modules/@turf/collect/dist/es/index.js
  var import_rbush = __toESM(require_rbush(), 1);

  // node_modules/@turf/bezier-spline/dist/es/lib/spline.js
  var Spline = function() {
    function Spline2(options) {
      this.points = options.points || [];
      this.duration = options.duration || 1e4;
      this.sharpness = options.sharpness || 0.85;
      this.centers = [];
      this.controls = [];
      this.stepLength = options.stepLength || 60;
      this.length = this.points.length;
      this.delay = 0;
      for (var i = 0; i < this.length; i++) {
        this.points[i].z = this.points[i].z || 0;
      }
      for (var i = 0; i < this.length - 1; i++) {
        var p1 = this.points[i];
        var p2 = this.points[i + 1];
        this.centers.push({
          x: (p1.x + p2.x) / 2,
          y: (p1.y + p2.y) / 2,
          z: (p1.z + p2.z) / 2
        });
      }
      this.controls.push([this.points[0], this.points[0]]);
      for (var i = 0; i < this.centers.length - 1; i++) {
        var dx = this.points[i + 1].x - (this.centers[i].x + this.centers[i + 1].x) / 2;
        var dy = this.points[i + 1].y - (this.centers[i].y + this.centers[i + 1].y) / 2;
        var dz = this.points[i + 1].z - (this.centers[i].y + this.centers[i + 1].z) / 2;
        this.controls.push([
          {
            x: (1 - this.sharpness) * this.points[i + 1].x + this.sharpness * (this.centers[i].x + dx),
            y: (1 - this.sharpness) * this.points[i + 1].y + this.sharpness * (this.centers[i].y + dy),
            z: (1 - this.sharpness) * this.points[i + 1].z + this.sharpness * (this.centers[i].z + dz)
          },
          {
            x: (1 - this.sharpness) * this.points[i + 1].x + this.sharpness * (this.centers[i + 1].x + dx),
            y: (1 - this.sharpness) * this.points[i + 1].y + this.sharpness * (this.centers[i + 1].y + dy),
            z: (1 - this.sharpness) * this.points[i + 1].z + this.sharpness * (this.centers[i + 1].z + dz)
          }
        ]);
      }
      this.controls.push([
        this.points[this.length - 1],
        this.points[this.length - 1]
      ]);
      this.steps = this.cacheSteps(this.stepLength);
      return this;
    }
    Spline2.prototype.cacheSteps = function(mindist) {
      var steps = [];
      var laststep = this.pos(0);
      steps.push(0);
      for (var t = 0; t < this.duration; t += 10) {
        var step = this.pos(t);
        var dist = Math.sqrt((step.x - laststep.x) * (step.x - laststep.x) + (step.y - laststep.y) * (step.y - laststep.y) + (step.z - laststep.z) * (step.z - laststep.z));
        if (dist > mindist) {
          steps.push(t);
          laststep = step;
        }
      }
      return steps;
    };
    Spline2.prototype.vector = function(t) {
      var p1 = this.pos(t + 10);
      var p2 = this.pos(t - 10);
      return {
        angle: 180 * Math.atan2(p1.y - p2.y, p1.x - p2.x) / 3.14,
        speed: Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y) + (p2.z - p1.z) * (p2.z - p1.z))
      };
    };
    Spline2.prototype.pos = function(time) {
      var t = time - this.delay;
      if (t < 0) {
        t = 0;
      }
      if (t > this.duration) {
        t = this.duration - 1;
      }
      var t2 = t / this.duration;
      if (t2 >= 1) {
        return this.points[this.length - 1];
      }
      var n = Math.floor((this.points.length - 1) * t2);
      var t1 = (this.length - 1) * t2 - n;
      return bezier(t1, this.points[n], this.controls[n][1], this.controls[n + 1][0], this.points[n + 1]);
    };
    return Spline2;
  }();
  function bezier(t, p1, c1, c2, p2) {
    var b = B(t);
    var pos = {
      x: p2.x * b[0] + c2.x * b[1] + c1.x * b[2] + p1.x * b[3],
      y: p2.y * b[0] + c2.y * b[1] + c1.y * b[2] + p1.y * b[3],
      z: p2.z * b[0] + c2.z * b[1] + c1.z * b[2] + p1.z * b[3]
    };
    return pos;
  }
  function B(t) {
    var t2 = t * t;
    var t3 = t2 * t;
    return [
      t3,
      3 * t2 * (1 - t),
      3 * t * (1 - t) * (1 - t),
      (1 - t) * (1 - t) * (1 - t)
    ];
  }

  // node_modules/@turf/bbox-polygon/dist/es/index.js
  function bboxPolygon(bbox3, options) {
    if (options === void 0) {
      options = {};
    }
    var west = Number(bbox3[0]);
    var south = Number(bbox3[1]);
    var east = Number(bbox3[2]);
    var north = Number(bbox3[3]);
    if (bbox3.length === 6) {
      throw new Error("@turf/bbox-polygon does not support BBox with 6 positions");
    }
    var lowLeft = [west, south];
    var topLeft = [west, north];
    var topRight = [east, north];
    var lowRight = [east, south];
    return polygon([[lowLeft, lowRight, topRight, topLeft, lowLeft]], options.properties, { bbox: bbox3, id: options.id });
  }

  // node_modules/@turf/envelope/dist/es/index.js
  function envelope(geojson) {
    return bboxPolygon(es_default6(geojson));
  }
  var es_default9 = envelope;

  // node_modules/@turf/circle/dist/es/index.js
  function circle(center, radius, options) {
    if (options === void 0) {
      options = {};
    }
    var steps = options.steps || 64;
    var properties = options.properties ? options.properties : !Array.isArray(center) && center.type === "Feature" && center.properties ? center.properties : {};
    var coordinates = [];
    for (var i = 0; i < steps; i++) {
      coordinates.push(destination(center, radius, i * -360 / steps, options).geometry.coordinates);
    }
    coordinates.push(coordinates[0]);
    return polygon([coordinates], properties);
  }
  var es_default10 = circle;

  // node_modules/@turf/midpoint/dist/es/index.js
  function midpoint(point1, point2) {
    var dist = es_default(point1, point2);
    var heading = bearing(point1, point2);
    var midpoint2 = destination(point1, dist / 2, heading);
    return midpoint2;
  }
  var es_default11 = midpoint;

  // node_modules/@turf/tesselate/dist/es/index.js
  var import_earcut = __toESM(require_earcut(), 1);

  // node_modules/@turf/nearest-point-to-line/dist/es/index.js
  var import_object_assign2 = __toESM(require_object_assign(), 1);

  // node_modules/@turf/unkink-polygon/dist/es/index.js
  var import_rbush2 = __toESM(require_rbush(), 1);

  // node_modules/@turf/great-circle/dist/es/index.js
  var D2R = Math.PI / 180;
  var R2D = 180 / Math.PI;
  var Coord = function(lon, lat) {
    this.lon = lon;
    this.lat = lat;
    this.x = D2R * lon;
    this.y = D2R * lat;
  };
  Coord.prototype.view = function() {
    return String(this.lon).slice(0, 4) + "," + String(this.lat).slice(0, 4);
  };
  Coord.prototype.antipode = function() {
    var anti_lat = -1 * this.lat;
    var anti_lon = this.lon < 0 ? 180 + this.lon : (180 - this.lon) * -1;
    return new Coord(anti_lon, anti_lat);
  };
  var LineString = function() {
    this.coords = [];
    this.length = 0;
  };
  LineString.prototype.move_to = function(coord) {
    this.length++;
    this.coords.push(coord);
  };
  var Arc = function(properties) {
    this.properties = properties || {};
    this.geometries = [];
  };
  Arc.prototype.json = function() {
    if (this.geometries.length <= 0) {
      return {
        geometry: { type: "LineString", coordinates: null },
        type: "Feature",
        properties: this.properties
      };
    } else if (this.geometries.length === 1) {
      return {
        geometry: { type: "LineString", coordinates: this.geometries[0].coords },
        type: "Feature",
        properties: this.properties
      };
    } else {
      var multiline = [];
      for (var i = 0; i < this.geometries.length; i++) {
        multiline.push(this.geometries[i].coords);
      }
      return {
        geometry: { type: "MultiLineString", coordinates: multiline },
        type: "Feature",
        properties: this.properties
      };
    }
  };
  Arc.prototype.wkt = function() {
    var wkt_string = "";
    var wkt = "LINESTRING(";
    var collect = function(c) {
      wkt += c[0] + " " + c[1] + ",";
    };
    for (var i = 0; i < this.geometries.length; i++) {
      if (this.geometries[i].coords.length === 0) {
        return "LINESTRING(empty)";
      } else {
        var coords = this.geometries[i].coords;
        coords.forEach(collect);
        wkt_string += wkt.substring(0, wkt.length - 1) + ")";
      }
    }
    return wkt_string;
  };
  var GreatCircle = function(start, end, properties) {
    if (!start || start.x === void 0 || start.y === void 0) {
      throw new Error(
        "GreatCircle constructor expects two args: start and end objects with x and y properties"
      );
    }
    if (!end || end.x === void 0 || end.y === void 0) {
      throw new Error(
        "GreatCircle constructor expects two args: start and end objects with x and y properties"
      );
    }
    this.start = new Coord(start.x, start.y);
    this.end = new Coord(end.x, end.y);
    this.properties = properties || {};
    var w = this.start.x - this.end.x;
    var h = this.start.y - this.end.y;
    var z = Math.pow(Math.sin(h / 2), 2) + Math.cos(this.start.y) * Math.cos(this.end.y) * Math.pow(Math.sin(w / 2), 2);
    this.g = 2 * Math.asin(Math.sqrt(z));
    if (this.g === Math.PI) {
      throw new Error(
        "it appears " + start.view() + " and " + end.view() + " are 'antipodal', e.g diametrically opposite, thus there is no single route but rather infinite"
      );
    } else if (isNaN(this.g)) {
      throw new Error(
        "could not calculate great circle between " + start + " and " + end
      );
    }
  };
  GreatCircle.prototype.interpolate = function(f) {
    var A = Math.sin((1 - f) * this.g) / Math.sin(this.g);
    var B2 = Math.sin(f * this.g) / Math.sin(this.g);
    var x2 = A * Math.cos(this.start.y) * Math.cos(this.start.x) + B2 * Math.cos(this.end.y) * Math.cos(this.end.x);
    var y2 = A * Math.cos(this.start.y) * Math.sin(this.start.x) + B2 * Math.cos(this.end.y) * Math.sin(this.end.x);
    var z = A * Math.sin(this.start.y) + B2 * Math.sin(this.end.y);
    var lat = R2D * Math.atan2(z, Math.sqrt(Math.pow(x2, 2) + Math.pow(y2, 2)));
    var lon = R2D * Math.atan2(y2, x2);
    return [lon, lat];
  };
  GreatCircle.prototype.Arc = function(npoints, options) {
    var first_pass = [];
    if (!npoints || npoints <= 2) {
      first_pass.push([this.start.lon, this.start.lat]);
      first_pass.push([this.end.lon, this.end.lat]);
    } else {
      var delta = 1 / (npoints - 1);
      for (var i = 0; i < npoints; ++i) {
        var step = delta * i;
        var pair2 = this.interpolate(step);
        first_pass.push(pair2);
      }
    }
    var bHasBigDiff = false;
    var dfMaxSmallDiffLong = 0;
    var dfDateLineOffset = options && options.offset ? options.offset : 10;
    var dfLeftBorderX = 180 - dfDateLineOffset;
    var dfRightBorderX = -180 + dfDateLineOffset;
    var dfDiffSpace = 360 - dfDateLineOffset;
    for (var j = 1; j < first_pass.length; ++j) {
      var dfPrevX = first_pass[j - 1][0];
      var dfX = first_pass[j][0];
      var dfDiffLong = Math.abs(dfX - dfPrevX);
      if (dfDiffLong > dfDiffSpace && (dfX > dfLeftBorderX && dfPrevX < dfRightBorderX || dfPrevX > dfLeftBorderX && dfX < dfRightBorderX)) {
        bHasBigDiff = true;
      } else if (dfDiffLong > dfMaxSmallDiffLong) {
        dfMaxSmallDiffLong = dfDiffLong;
      }
    }
    var poMulti = [];
    if (bHasBigDiff && dfMaxSmallDiffLong < dfDateLineOffset) {
      var poNewLS = [];
      poMulti.push(poNewLS);
      for (var k = 0; k < first_pass.length; ++k) {
        var dfX0 = parseFloat(first_pass[k][0]);
        if (k > 0 && Math.abs(dfX0 - first_pass[k - 1][0]) > dfDiffSpace) {
          var dfX1 = parseFloat(first_pass[k - 1][0]);
          var dfY1 = parseFloat(first_pass[k - 1][1]);
          var dfX2 = parseFloat(first_pass[k][0]);
          var dfY2 = parseFloat(first_pass[k][1]);
          if (dfX1 > -180 && dfX1 < dfRightBorderX && dfX2 === 180 && k + 1 < first_pass.length && first_pass[k - 1][0] > -180 && first_pass[k - 1][0] < dfRightBorderX) {
            poNewLS.push([-180, first_pass[k][1]]);
            k++;
            poNewLS.push([first_pass[k][0], first_pass[k][1]]);
            continue;
          } else if (dfX1 > dfLeftBorderX && dfX1 < 180 && dfX2 === -180 && k + 1 < first_pass.length && first_pass[k - 1][0] > dfLeftBorderX && first_pass[k - 1][0] < 180) {
            poNewLS.push([180, first_pass[k][1]]);
            k++;
            poNewLS.push([first_pass[k][0], first_pass[k][1]]);
            continue;
          }
          if (dfX1 < dfRightBorderX && dfX2 > dfLeftBorderX) {
            var tmpX = dfX1;
            dfX1 = dfX2;
            dfX2 = tmpX;
            var tmpY = dfY1;
            dfY1 = dfY2;
            dfY2 = tmpY;
          }
          if (dfX1 > dfLeftBorderX && dfX2 < dfRightBorderX) {
            dfX2 += 360;
          }
          if (dfX1 <= 180 && dfX2 >= 180 && dfX1 < dfX2) {
            var dfRatio = (180 - dfX1) / (dfX2 - dfX1);
            var dfY = dfRatio * dfY2 + (1 - dfRatio) * dfY1;
            poNewLS.push([
              first_pass[k - 1][0] > dfLeftBorderX ? 180 : -180,
              dfY
            ]);
            poNewLS = [];
            poNewLS.push([
              first_pass[k - 1][0] > dfLeftBorderX ? -180 : 180,
              dfY
            ]);
            poMulti.push(poNewLS);
          } else {
            poNewLS = [];
            poMulti.push(poNewLS);
          }
          poNewLS.push([dfX0, first_pass[k][1]]);
        } else {
          poNewLS.push([first_pass[k][0], first_pass[k][1]]);
        }
      }
    } else {
      var poNewLS0 = [];
      poMulti.push(poNewLS0);
      for (var l = 0; l < first_pass.length; ++l) {
        poNewLS0.push([first_pass[l][0], first_pass[l][1]]);
      }
    }
    var arc = new Arc(this.properties);
    for (var m = 0; m < poMulti.length; ++m) {
      var line = new LineString();
      arc.geometries.push(line);
      var points = poMulti[m];
      for (var j0 = 0; j0 < points.length; ++j0) {
        line.move_to(points[j0]);
      }
    }
    return arc;
  };

  // node_modules/@turf/line-split/dist/es/index.js
  var import_geojson_rbush2 = __toESM(require_geojson_rbush(), 1);

  // node_modules/@turf/line-overlap/dist/es/index.js
  var import_geojson_rbush3 = __toESM(require_geojson_rbush(), 1);
  var import_deep_equal = __toESM(require_deep_equal(), 1);

  // node_modules/@turf/isobands/dist/es/index.js
  var import_object_assign3 = __toESM(require_object_assign(), 1);
  var isoBandNextXTL = [];
  var isoBandNextYTL = [];
  var isoBandNextOTL = [];
  var isoBandNextXTR = [];
  var isoBandNextYTR = [];
  var isoBandNextOTR = [];
  var isoBandNextXRT = [];
  var isoBandNextYRT = [];
  var isoBandNextORT = [];
  var isoBandNextXRB = [];
  var isoBandNextYRB = [];
  var isoBandNextORB = [];
  var isoBandNextXBL = [];
  var isoBandNextYBL = [];
  var isoBandNextOBL = [];
  var isoBandNextXBR = [];
  var isoBandNextYBR = [];
  var isoBandNextOBR = [];
  var isoBandNextXLT = [];
  var isoBandNextYLT = [];
  var isoBandNextOLT = [];
  var isoBandNextXLB = [];
  var isoBandNextYLB = [];
  var isoBandNextOLB = [];
  isoBandNextXRT[85] = isoBandNextXRB[85] = -1;
  isoBandNextYRT[85] = isoBandNextYRB[85] = 0;
  isoBandNextORT[85] = isoBandNextORB[85] = 1;
  isoBandNextXLT[85] = isoBandNextXLB[85] = 1;
  isoBandNextYLT[85] = isoBandNextYLB[85] = 0;
  isoBandNextOLT[85] = isoBandNextOLB[85] = 1;
  isoBandNextXTL[85] = isoBandNextXTR[85] = 0;
  isoBandNextYTL[85] = isoBandNextYTR[85] = -1;
  isoBandNextOTL[85] = isoBandNextOBL[85] = 0;
  isoBandNextXBR[85] = isoBandNextXBL[85] = 0;
  isoBandNextYBR[85] = isoBandNextYBL[85] = 1;
  isoBandNextOTR[85] = isoBandNextOBR[85] = 1;
  isoBandNextXLB[1] = isoBandNextXLB[169] = 0;
  isoBandNextYLB[1] = isoBandNextYLB[169] = -1;
  isoBandNextOLB[1] = isoBandNextOLB[169] = 0;
  isoBandNextXBL[1] = isoBandNextXBL[169] = -1;
  isoBandNextYBL[1] = isoBandNextYBL[169] = 0;
  isoBandNextOBL[1] = isoBandNextOBL[169] = 0;
  isoBandNextXRB[4] = isoBandNextXRB[166] = 0;
  isoBandNextYRB[4] = isoBandNextYRB[166] = -1;
  isoBandNextORB[4] = isoBandNextORB[166] = 1;
  isoBandNextXBR[4] = isoBandNextXBR[166] = 1;
  isoBandNextYBR[4] = isoBandNextYBR[166] = 0;
  isoBandNextOBR[4] = isoBandNextOBR[166] = 0;
  isoBandNextXRT[16] = isoBandNextXRT[154] = 0;
  isoBandNextYRT[16] = isoBandNextYRT[154] = 1;
  isoBandNextORT[16] = isoBandNextORT[154] = 1;
  isoBandNextXTR[16] = isoBandNextXTR[154] = 1;
  isoBandNextYTR[16] = isoBandNextYTR[154] = 0;
  isoBandNextOTR[16] = isoBandNextOTR[154] = 1;
  isoBandNextXLT[64] = isoBandNextXLT[106] = 0;
  isoBandNextYLT[64] = isoBandNextYLT[106] = 1;
  isoBandNextOLT[64] = isoBandNextOLT[106] = 0;
  isoBandNextXTL[64] = isoBandNextXTL[106] = -1;
  isoBandNextYTL[64] = isoBandNextYTL[106] = 0;
  isoBandNextOTL[64] = isoBandNextOTL[106] = 1;
  isoBandNextXLT[2] = isoBandNextXLT[168] = 0;
  isoBandNextYLT[2] = isoBandNextYLT[168] = -1;
  isoBandNextOLT[2] = isoBandNextOLT[168] = 1;
  isoBandNextXLB[2] = isoBandNextXLB[168] = 0;
  isoBandNextYLB[2] = isoBandNextYLB[168] = -1;
  isoBandNextOLB[2] = isoBandNextOLB[168] = 0;
  isoBandNextXBL[2] = isoBandNextXBL[168] = -1;
  isoBandNextYBL[2] = isoBandNextYBL[168] = 0;
  isoBandNextOBL[2] = isoBandNextOBL[168] = 0;
  isoBandNextXBR[2] = isoBandNextXBR[168] = -1;
  isoBandNextYBR[2] = isoBandNextYBR[168] = 0;
  isoBandNextOBR[2] = isoBandNextOBR[168] = 1;
  isoBandNextXRT[8] = isoBandNextXRT[162] = 0;
  isoBandNextYRT[8] = isoBandNextYRT[162] = -1;
  isoBandNextORT[8] = isoBandNextORT[162] = 0;
  isoBandNextXRB[8] = isoBandNextXRB[162] = 0;
  isoBandNextYRB[8] = isoBandNextYRB[162] = -1;
  isoBandNextORB[8] = isoBandNextORB[162] = 1;
  isoBandNextXBL[8] = isoBandNextXBL[162] = 1;
  isoBandNextYBL[8] = isoBandNextYBL[162] = 0;
  isoBandNextOBL[8] = isoBandNextOBL[162] = 1;
  isoBandNextXBR[8] = isoBandNextXBR[162] = 1;
  isoBandNextYBR[8] = isoBandNextYBR[162] = 0;
  isoBandNextOBR[8] = isoBandNextOBR[162] = 0;
  isoBandNextXRT[32] = isoBandNextXRT[138] = 0;
  isoBandNextYRT[32] = isoBandNextYRT[138] = 1;
  isoBandNextORT[32] = isoBandNextORT[138] = 1;
  isoBandNextXRB[32] = isoBandNextXRB[138] = 0;
  isoBandNextYRB[32] = isoBandNextYRB[138] = 1;
  isoBandNextORB[32] = isoBandNextORB[138] = 0;
  isoBandNextXTL[32] = isoBandNextXTL[138] = 1;
  isoBandNextYTL[32] = isoBandNextYTL[138] = 0;
  isoBandNextOTL[32] = isoBandNextOTL[138] = 0;
  isoBandNextXTR[32] = isoBandNextXTR[138] = 1;
  isoBandNextYTR[32] = isoBandNextYTR[138] = 0;
  isoBandNextOTR[32] = isoBandNextOTR[138] = 1;
  isoBandNextXLB[128] = isoBandNextXLB[42] = 0;
  isoBandNextYLB[128] = isoBandNextYLB[42] = 1;
  isoBandNextOLB[128] = isoBandNextOLB[42] = 1;
  isoBandNextXLT[128] = isoBandNextXLT[42] = 0;
  isoBandNextYLT[128] = isoBandNextYLT[42] = 1;
  isoBandNextOLT[128] = isoBandNextOLT[42] = 0;
  isoBandNextXTL[128] = isoBandNextXTL[42] = -1;
  isoBandNextYTL[128] = isoBandNextYTL[42] = 0;
  isoBandNextOTL[128] = isoBandNextOTL[42] = 1;
  isoBandNextXTR[128] = isoBandNextXTR[42] = -1;
  isoBandNextYTR[128] = isoBandNextYTR[42] = 0;
  isoBandNextOTR[128] = isoBandNextOTR[42] = 0;
  isoBandNextXRB[5] = isoBandNextXRB[165] = -1;
  isoBandNextYRB[5] = isoBandNextYRB[165] = 0;
  isoBandNextORB[5] = isoBandNextORB[165] = 0;
  isoBandNextXLB[5] = isoBandNextXLB[165] = 1;
  isoBandNextYLB[5] = isoBandNextYLB[165] = 0;
  isoBandNextOLB[5] = isoBandNextOLB[165] = 0;
  isoBandNextXBR[20] = isoBandNextXBR[150] = 0;
  isoBandNextYBR[20] = isoBandNextYBR[150] = 1;
  isoBandNextOBR[20] = isoBandNextOBR[150] = 1;
  isoBandNextXTR[20] = isoBandNextXTR[150] = 0;
  isoBandNextYTR[20] = isoBandNextYTR[150] = -1;
  isoBandNextOTR[20] = isoBandNextOTR[150] = 1;
  isoBandNextXRT[80] = isoBandNextXRT[90] = -1;
  isoBandNextYRT[80] = isoBandNextYRT[90] = 0;
  isoBandNextORT[80] = isoBandNextORT[90] = 1;
  isoBandNextXLT[80] = isoBandNextXLT[90] = 1;
  isoBandNextYLT[80] = isoBandNextYLT[90] = 0;
  isoBandNextOLT[80] = isoBandNextOLT[90] = 1;
  isoBandNextXBL[65] = isoBandNextXBL[105] = 0;
  isoBandNextYBL[65] = isoBandNextYBL[105] = 1;
  isoBandNextOBL[65] = isoBandNextOBL[105] = 0;
  isoBandNextXTL[65] = isoBandNextXTL[105] = 0;
  isoBandNextYTL[65] = isoBandNextYTL[105] = -1;
  isoBandNextOTL[65] = isoBandNextOTL[105] = 0;
  isoBandNextXRT[160] = isoBandNextXRT[10] = -1;
  isoBandNextYRT[160] = isoBandNextYRT[10] = 0;
  isoBandNextORT[160] = isoBandNextORT[10] = 1;
  isoBandNextXRB[160] = isoBandNextXRB[10] = -1;
  isoBandNextYRB[160] = isoBandNextYRB[10] = 0;
  isoBandNextORB[160] = isoBandNextORB[10] = 0;
  isoBandNextXLB[160] = isoBandNextXLB[10] = 1;
  isoBandNextYLB[160] = isoBandNextYLB[10] = 0;
  isoBandNextOLB[160] = isoBandNextOLB[10] = 0;
  isoBandNextXLT[160] = isoBandNextXLT[10] = 1;
  isoBandNextYLT[160] = isoBandNextYLT[10] = 0;
  isoBandNextOLT[160] = isoBandNextOLT[10] = 1;
  isoBandNextXBR[130] = isoBandNextXBR[40] = 0;
  isoBandNextYBR[130] = isoBandNextYBR[40] = 1;
  isoBandNextOBR[130] = isoBandNextOBR[40] = 1;
  isoBandNextXBL[130] = isoBandNextXBL[40] = 0;
  isoBandNextYBL[130] = isoBandNextYBL[40] = 1;
  isoBandNextOBL[130] = isoBandNextOBL[40] = 0;
  isoBandNextXTL[130] = isoBandNextXTL[40] = 0;
  isoBandNextYTL[130] = isoBandNextYTL[40] = -1;
  isoBandNextOTL[130] = isoBandNextOTL[40] = 0;
  isoBandNextXTR[130] = isoBandNextXTR[40] = 0;
  isoBandNextYTR[130] = isoBandNextYTR[40] = -1;
  isoBandNextOTR[130] = isoBandNextOTR[40] = 1;
  isoBandNextXRB[37] = isoBandNextXRB[133] = 0;
  isoBandNextYRB[37] = isoBandNextYRB[133] = 1;
  isoBandNextORB[37] = isoBandNextORB[133] = 1;
  isoBandNextXLB[37] = isoBandNextXLB[133] = 0;
  isoBandNextYLB[37] = isoBandNextYLB[133] = 1;
  isoBandNextOLB[37] = isoBandNextOLB[133] = 0;
  isoBandNextXTL[37] = isoBandNextXTL[133] = -1;
  isoBandNextYTL[37] = isoBandNextYTL[133] = 0;
  isoBandNextOTL[37] = isoBandNextOTL[133] = 0;
  isoBandNextXTR[37] = isoBandNextXTR[133] = 1;
  isoBandNextYTR[37] = isoBandNextYTR[133] = 0;
  isoBandNextOTR[37] = isoBandNextOTR[133] = 0;
  isoBandNextXBR[148] = isoBandNextXBR[22] = -1;
  isoBandNextYBR[148] = isoBandNextYBR[22] = 0;
  isoBandNextOBR[148] = isoBandNextOBR[22] = 0;
  isoBandNextXLB[148] = isoBandNextXLB[22] = 0;
  isoBandNextYLB[148] = isoBandNextYLB[22] = -1;
  isoBandNextOLB[148] = isoBandNextOLB[22] = 1;
  isoBandNextXLT[148] = isoBandNextXLT[22] = 0;
  isoBandNextYLT[148] = isoBandNextYLT[22] = 1;
  isoBandNextOLT[148] = isoBandNextOLT[22] = 1;
  isoBandNextXTR[148] = isoBandNextXTR[22] = -1;
  isoBandNextYTR[148] = isoBandNextYTR[22] = 0;
  isoBandNextOTR[148] = isoBandNextOTR[22] = 1;
  isoBandNextXRT[82] = isoBandNextXRT[88] = 0;
  isoBandNextYRT[82] = isoBandNextYRT[88] = -1;
  isoBandNextORT[82] = isoBandNextORT[88] = 1;
  isoBandNextXBR[82] = isoBandNextXBR[88] = 1;
  isoBandNextYBR[82] = isoBandNextYBR[88] = 0;
  isoBandNextOBR[82] = isoBandNextOBR[88] = 1;
  isoBandNextXBL[82] = isoBandNextXBL[88] = -1;
  isoBandNextYBL[82] = isoBandNextYBL[88] = 0;
  isoBandNextOBL[82] = isoBandNextOBL[88] = 1;
  isoBandNextXLT[82] = isoBandNextXLT[88] = 0;
  isoBandNextYLT[82] = isoBandNextYLT[88] = -1;
  isoBandNextOLT[82] = isoBandNextOLT[88] = 0;
  isoBandNextXRT[73] = isoBandNextXRT[97] = 0;
  isoBandNextYRT[73] = isoBandNextYRT[97] = 1;
  isoBandNextORT[73] = isoBandNextORT[97] = 0;
  isoBandNextXRB[73] = isoBandNextXRB[97] = 0;
  isoBandNextYRB[73] = isoBandNextYRB[97] = -1;
  isoBandNextORB[73] = isoBandNextORB[97] = 0;
  isoBandNextXBL[73] = isoBandNextXBL[97] = 1;
  isoBandNextYBL[73] = isoBandNextYBL[97] = 0;
  isoBandNextOBL[73] = isoBandNextOBL[97] = 0;
  isoBandNextXTL[73] = isoBandNextXTL[97] = 1;
  isoBandNextYTL[73] = isoBandNextYTL[97] = 0;
  isoBandNextOTL[73] = isoBandNextOTL[97] = 1;
  isoBandNextXRT[145] = isoBandNextXRT[25] = 0;
  isoBandNextYRT[145] = isoBandNextYRT[25] = -1;
  isoBandNextORT[145] = isoBandNextORT[25] = 0;
  isoBandNextXBL[145] = isoBandNextXBL[25] = 1;
  isoBandNextYBL[145] = isoBandNextYBL[25] = 0;
  isoBandNextOBL[145] = isoBandNextOBL[25] = 1;
  isoBandNextXLB[145] = isoBandNextXLB[25] = 0;
  isoBandNextYLB[145] = isoBandNextYLB[25] = 1;
  isoBandNextOLB[145] = isoBandNextOLB[25] = 1;
  isoBandNextXTR[145] = isoBandNextXTR[25] = -1;
  isoBandNextYTR[145] = isoBandNextYTR[25] = 0;
  isoBandNextOTR[145] = isoBandNextOTR[25] = 0;
  isoBandNextXRB[70] = isoBandNextXRB[100] = 0;
  isoBandNextYRB[70] = isoBandNextYRB[100] = 1;
  isoBandNextORB[70] = isoBandNextORB[100] = 0;
  isoBandNextXBR[70] = isoBandNextXBR[100] = -1;
  isoBandNextYBR[70] = isoBandNextYBR[100] = 0;
  isoBandNextOBR[70] = isoBandNextOBR[100] = 1;
  isoBandNextXLT[70] = isoBandNextXLT[100] = 0;
  isoBandNextYLT[70] = isoBandNextYLT[100] = -1;
  isoBandNextOLT[70] = isoBandNextOLT[100] = 1;
  isoBandNextXTL[70] = isoBandNextXTL[100] = 1;
  isoBandNextYTL[70] = isoBandNextYTL[100] = 0;
  isoBandNextOTL[70] = isoBandNextOTL[100] = 0;
  isoBandNextXRB[101] = isoBandNextXRB[69] = 0;
  isoBandNextYRB[101] = isoBandNextYRB[69] = 1;
  isoBandNextORB[101] = isoBandNextORB[69] = 0;
  isoBandNextXTL[101] = isoBandNextXTL[69] = 1;
  isoBandNextYTL[101] = isoBandNextYTL[69] = 0;
  isoBandNextOTL[101] = isoBandNextOTL[69] = 0;
  isoBandNextXLB[149] = isoBandNextXLB[21] = 0;
  isoBandNextYLB[149] = isoBandNextYLB[21] = 1;
  isoBandNextOLB[149] = isoBandNextOLB[21] = 1;
  isoBandNextXTR[149] = isoBandNextXTR[21] = -1;
  isoBandNextYTR[149] = isoBandNextYTR[21] = 0;
  isoBandNextOTR[149] = isoBandNextOTR[21] = 0;
  isoBandNextXBR[86] = isoBandNextXBR[84] = -1;
  isoBandNextYBR[86] = isoBandNextYBR[84] = 0;
  isoBandNextOBR[86] = isoBandNextOBR[84] = 1;
  isoBandNextXLT[86] = isoBandNextXLT[84] = 0;
  isoBandNextYLT[86] = isoBandNextYLT[84] = -1;
  isoBandNextOLT[86] = isoBandNextOLT[84] = 1;
  isoBandNextXRT[89] = isoBandNextXRT[81] = 0;
  isoBandNextYRT[89] = isoBandNextYRT[81] = -1;
  isoBandNextORT[89] = isoBandNextORT[81] = 0;
  isoBandNextXBL[89] = isoBandNextXBL[81] = 1;
  isoBandNextYBL[89] = isoBandNextYBL[81] = 0;
  isoBandNextOBL[89] = isoBandNextOBL[81] = 1;
  isoBandNextXRT[96] = isoBandNextXRT[74] = 0;
  isoBandNextYRT[96] = isoBandNextYRT[74] = 1;
  isoBandNextORT[96] = isoBandNextORT[74] = 0;
  isoBandNextXRB[96] = isoBandNextXRB[74] = -1;
  isoBandNextYRB[96] = isoBandNextYRB[74] = 0;
  isoBandNextORB[96] = isoBandNextORB[74] = 1;
  isoBandNextXLT[96] = isoBandNextXLT[74] = 1;
  isoBandNextYLT[96] = isoBandNextYLT[74] = 0;
  isoBandNextOLT[96] = isoBandNextOLT[74] = 0;
  isoBandNextXTL[96] = isoBandNextXTL[74] = 1;
  isoBandNextYTL[96] = isoBandNextYTL[74] = 0;
  isoBandNextOTL[96] = isoBandNextOTL[74] = 1;
  isoBandNextXRT[24] = isoBandNextXRT[146] = 0;
  isoBandNextYRT[24] = isoBandNextYRT[146] = -1;
  isoBandNextORT[24] = isoBandNextORT[146] = 1;
  isoBandNextXBR[24] = isoBandNextXBR[146] = 1;
  isoBandNextYBR[24] = isoBandNextYBR[146] = 0;
  isoBandNextOBR[24] = isoBandNextOBR[146] = 1;
  isoBandNextXBL[24] = isoBandNextXBL[146] = 0;
  isoBandNextYBL[24] = isoBandNextYBL[146] = 1;
  isoBandNextOBL[24] = isoBandNextOBL[146] = 1;
  isoBandNextXTR[24] = isoBandNextXTR[146] = 0;
  isoBandNextYTR[24] = isoBandNextYTR[146] = -1;
  isoBandNextOTR[24] = isoBandNextOTR[146] = 0;
  isoBandNextXRB[6] = isoBandNextXRB[164] = -1;
  isoBandNextYRB[6] = isoBandNextYRB[164] = 0;
  isoBandNextORB[6] = isoBandNextORB[164] = 1;
  isoBandNextXBR[6] = isoBandNextXBR[164] = -1;
  isoBandNextYBR[6] = isoBandNextYBR[164] = 0;
  isoBandNextOBR[6] = isoBandNextOBR[164] = 0;
  isoBandNextXLB[6] = isoBandNextXLB[164] = 0;
  isoBandNextYLB[6] = isoBandNextYLB[164] = -1;
  isoBandNextOLB[6] = isoBandNextOLB[164] = 1;
  isoBandNextXLT[6] = isoBandNextXLT[164] = 1;
  isoBandNextYLT[6] = isoBandNextYLT[164] = 0;
  isoBandNextOLT[6] = isoBandNextOLT[164] = 0;
  isoBandNextXBL[129] = isoBandNextXBL[41] = 0;
  isoBandNextYBL[129] = isoBandNextYBL[41] = 1;
  isoBandNextOBL[129] = isoBandNextOBL[41] = 1;
  isoBandNextXLB[129] = isoBandNextXLB[41] = 0;
  isoBandNextYLB[129] = isoBandNextYLB[41] = 1;
  isoBandNextOLB[129] = isoBandNextOLB[41] = 0;
  isoBandNextXTL[129] = isoBandNextXTL[41] = -1;
  isoBandNextYTL[129] = isoBandNextYTL[41] = 0;
  isoBandNextOTL[129] = isoBandNextOTL[41] = 0;
  isoBandNextXTR[129] = isoBandNextXTR[41] = 0;
  isoBandNextYTR[129] = isoBandNextYTR[41] = -1;
  isoBandNextOTR[129] = isoBandNextOTR[41] = 0;
  isoBandNextXBR[66] = isoBandNextXBR[104] = 0;
  isoBandNextYBR[66] = isoBandNextYBR[104] = 1;
  isoBandNextOBR[66] = isoBandNextOBR[104] = 0;
  isoBandNextXBL[66] = isoBandNextXBL[104] = -1;
  isoBandNextYBL[66] = isoBandNextYBL[104] = 0;
  isoBandNextOBL[66] = isoBandNextOBL[104] = 1;
  isoBandNextXLT[66] = isoBandNextXLT[104] = 0;
  isoBandNextYLT[66] = isoBandNextYLT[104] = -1;
  isoBandNextOLT[66] = isoBandNextOLT[104] = 0;
  isoBandNextXTL[66] = isoBandNextXTL[104] = 0;
  isoBandNextYTL[66] = isoBandNextYTL[104] = -1;
  isoBandNextOTL[66] = isoBandNextOTL[104] = 1;
  isoBandNextXRT[144] = isoBandNextXRT[26] = -1;
  isoBandNextYRT[144] = isoBandNextYRT[26] = 0;
  isoBandNextORT[144] = isoBandNextORT[26] = 0;
  isoBandNextXLB[144] = isoBandNextXLB[26] = 1;
  isoBandNextYLB[144] = isoBandNextYLB[26] = 0;
  isoBandNextOLB[144] = isoBandNextOLB[26] = 1;
  isoBandNextXLT[144] = isoBandNextXLT[26] = 0;
  isoBandNextYLT[144] = isoBandNextYLT[26] = 1;
  isoBandNextOLT[144] = isoBandNextOLT[26] = 1;
  isoBandNextXTR[144] = isoBandNextXTR[26] = -1;
  isoBandNextYTR[144] = isoBandNextYTR[26] = 0;
  isoBandNextOTR[144] = isoBandNextOTR[26] = 1;
  isoBandNextXRB[36] = isoBandNextXRB[134] = 0;
  isoBandNextYRB[36] = isoBandNextYRB[134] = 1;
  isoBandNextORB[36] = isoBandNextORB[134] = 1;
  isoBandNextXBR[36] = isoBandNextXBR[134] = 0;
  isoBandNextYBR[36] = isoBandNextYBR[134] = 1;
  isoBandNextOBR[36] = isoBandNextOBR[134] = 0;
  isoBandNextXTL[36] = isoBandNextXTL[134] = 0;
  isoBandNextYTL[36] = isoBandNextYTL[134] = -1;
  isoBandNextOTL[36] = isoBandNextOTL[134] = 1;
  isoBandNextXTR[36] = isoBandNextXTR[134] = 1;
  isoBandNextYTR[36] = isoBandNextYTR[134] = 0;
  isoBandNextOTR[36] = isoBandNextOTR[134] = 0;
  isoBandNextXRT[9] = isoBandNextXRT[161] = -1;
  isoBandNextYRT[9] = isoBandNextYRT[161] = 0;
  isoBandNextORT[9] = isoBandNextORT[161] = 0;
  isoBandNextXRB[9] = isoBandNextXRB[161] = 0;
  isoBandNextYRB[9] = isoBandNextYRB[161] = -1;
  isoBandNextORB[9] = isoBandNextORB[161] = 0;
  isoBandNextXBL[9] = isoBandNextXBL[161] = 1;
  isoBandNextYBL[9] = isoBandNextYBL[161] = 0;
  isoBandNextOBL[9] = isoBandNextOBL[161] = 0;
  isoBandNextXLB[9] = isoBandNextXLB[161] = 1;
  isoBandNextYLB[9] = isoBandNextYLB[161] = 0;
  isoBandNextOLB[9] = isoBandNextOLB[161] = 1;
  isoBandNextXRT[136] = 0;
  isoBandNextYRT[136] = 1;
  isoBandNextORT[136] = 1;
  isoBandNextXRB[136] = 0;
  isoBandNextYRB[136] = 1;
  isoBandNextORB[136] = 0;
  isoBandNextXBR[136] = -1;
  isoBandNextYBR[136] = 0;
  isoBandNextOBR[136] = 1;
  isoBandNextXBL[136] = -1;
  isoBandNextYBL[136] = 0;
  isoBandNextOBL[136] = 0;
  isoBandNextXLB[136] = 0;
  isoBandNextYLB[136] = -1;
  isoBandNextOLB[136] = 0;
  isoBandNextXLT[136] = 0;
  isoBandNextYLT[136] = -1;
  isoBandNextOLT[136] = 1;
  isoBandNextXTL[136] = 1;
  isoBandNextYTL[136] = 0;
  isoBandNextOTL[136] = 0;
  isoBandNextXTR[136] = 1;
  isoBandNextYTR[136] = 0;
  isoBandNextOTR[136] = 1;
  isoBandNextXRT[34] = 0;
  isoBandNextYRT[34] = -1;
  isoBandNextORT[34] = 0;
  isoBandNextXRB[34] = 0;
  isoBandNextYRB[34] = -1;
  isoBandNextORB[34] = 1;
  isoBandNextXBR[34] = 1;
  isoBandNextYBR[34] = 0;
  isoBandNextOBR[34] = 0;
  isoBandNextXBL[34] = 1;
  isoBandNextYBL[34] = 0;
  isoBandNextOBL[34] = 1;
  isoBandNextXLB[34] = 0;
  isoBandNextYLB[34] = 1;
  isoBandNextOLB[34] = 1;
  isoBandNextXLT[34] = 0;
  isoBandNextYLT[34] = 1;
  isoBandNextOLT[34] = 0;
  isoBandNextXTL[34] = -1;
  isoBandNextYTL[34] = 0;
  isoBandNextOTL[34] = 1;
  isoBandNextXTR[34] = -1;
  isoBandNextYTR[34] = 0;
  isoBandNextOTR[34] = 0;
  isoBandNextXRT[35] = 0;
  isoBandNextYRT[35] = 1;
  isoBandNextORT[35] = 1;
  isoBandNextXRB[35] = 0;
  isoBandNextYRB[35] = -1;
  isoBandNextORB[35] = 1;
  isoBandNextXBR[35] = 1;
  isoBandNextYBR[35] = 0;
  isoBandNextOBR[35] = 0;
  isoBandNextXBL[35] = -1;
  isoBandNextYBL[35] = 0;
  isoBandNextOBL[35] = 0;
  isoBandNextXLB[35] = 0;
  isoBandNextYLB[35] = -1;
  isoBandNextOLB[35] = 0;
  isoBandNextXLT[35] = 0;
  isoBandNextYLT[35] = 1;
  isoBandNextOLT[35] = 0;
  isoBandNextXTL[35] = -1;
  isoBandNextYTL[35] = 0;
  isoBandNextOTL[35] = 1;
  isoBandNextXTR[35] = 1;
  isoBandNextYTR[35] = 0;
  isoBandNextOTR[35] = 1;
  isoBandNextXRT[153] = 0;
  isoBandNextYRT[153] = 1;
  isoBandNextORT[153] = 1;
  isoBandNextXBL[153] = -1;
  isoBandNextYBL[153] = 0;
  isoBandNextOBL[153] = 0;
  isoBandNextXLB[153] = 0;
  isoBandNextYLB[153] = -1;
  isoBandNextOLB[153] = 0;
  isoBandNextXTR[153] = 1;
  isoBandNextYTR[153] = 0;
  isoBandNextOTR[153] = 1;
  isoBandNextXRB[102] = 0;
  isoBandNextYRB[102] = -1;
  isoBandNextORB[102] = 1;
  isoBandNextXBR[102] = 1;
  isoBandNextYBR[102] = 0;
  isoBandNextOBR[102] = 0;
  isoBandNextXLT[102] = 0;
  isoBandNextYLT[102] = 1;
  isoBandNextOLT[102] = 0;
  isoBandNextXTL[102] = -1;
  isoBandNextYTL[102] = 0;
  isoBandNextOTL[102] = 1;
  isoBandNextXRT[155] = 0;
  isoBandNextYRT[155] = -1;
  isoBandNextORT[155] = 0;
  isoBandNextXBL[155] = 1;
  isoBandNextYBL[155] = 0;
  isoBandNextOBL[155] = 1;
  isoBandNextXLB[155] = 0;
  isoBandNextYLB[155] = 1;
  isoBandNextOLB[155] = 1;
  isoBandNextXTR[155] = -1;
  isoBandNextYTR[155] = 0;
  isoBandNextOTR[155] = 0;
  isoBandNextXRB[103] = 0;
  isoBandNextYRB[103] = 1;
  isoBandNextORB[103] = 0;
  isoBandNextXBR[103] = -1;
  isoBandNextYBR[103] = 0;
  isoBandNextOBR[103] = 1;
  isoBandNextXLT[103] = 0;
  isoBandNextYLT[103] = -1;
  isoBandNextOLT[103] = 1;
  isoBandNextXTL[103] = 1;
  isoBandNextYTL[103] = 0;
  isoBandNextOTL[103] = 0;
  isoBandNextXRT[152] = 0;
  isoBandNextYRT[152] = 1;
  isoBandNextORT[152] = 1;
  isoBandNextXBR[152] = -1;
  isoBandNextYBR[152] = 0;
  isoBandNextOBR[152] = 1;
  isoBandNextXBL[152] = -1;
  isoBandNextYBL[152] = 0;
  isoBandNextOBL[152] = 0;
  isoBandNextXLB[152] = 0;
  isoBandNextYLB[152] = -1;
  isoBandNextOLB[152] = 0;
  isoBandNextXLT[152] = 0;
  isoBandNextYLT[152] = -1;
  isoBandNextOLT[152] = 1;
  isoBandNextXTR[152] = 1;
  isoBandNextYTR[152] = 0;
  isoBandNextOTR[152] = 1;
  isoBandNextXRT[156] = 0;
  isoBandNextYRT[156] = -1;
  isoBandNextORT[156] = 1;
  isoBandNextXBR[156] = 1;
  isoBandNextYBR[156] = 0;
  isoBandNextOBR[156] = 1;
  isoBandNextXBL[156] = -1;
  isoBandNextYBL[156] = 0;
  isoBandNextOBL[156] = 0;
  isoBandNextXLB[156] = 0;
  isoBandNextYLB[156] = -1;
  isoBandNextOLB[156] = 0;
  isoBandNextXLT[156] = 0;
  isoBandNextYLT[156] = 1;
  isoBandNextOLT[156] = 1;
  isoBandNextXTR[156] = -1;
  isoBandNextYTR[156] = 0;
  isoBandNextOTR[156] = 1;
  isoBandNextXRT[137] = 0;
  isoBandNextYRT[137] = 1;
  isoBandNextORT[137] = 1;
  isoBandNextXRB[137] = 0;
  isoBandNextYRB[137] = 1;
  isoBandNextORB[137] = 0;
  isoBandNextXBL[137] = -1;
  isoBandNextYBL[137] = 0;
  isoBandNextOBL[137] = 0;
  isoBandNextXLB[137] = 0;
  isoBandNextYLB[137] = -1;
  isoBandNextOLB[137] = 0;
  isoBandNextXTL[137] = 1;
  isoBandNextYTL[137] = 0;
  isoBandNextOTL[137] = 0;
  isoBandNextXTR[137] = 1;
  isoBandNextYTR[137] = 0;
  isoBandNextOTR[137] = 1;
  isoBandNextXRT[139] = 0;
  isoBandNextYRT[139] = 1;
  isoBandNextORT[139] = 1;
  isoBandNextXRB[139] = 0;
  isoBandNextYRB[139] = -1;
  isoBandNextORB[139] = 0;
  isoBandNextXBL[139] = 1;
  isoBandNextYBL[139] = 0;
  isoBandNextOBL[139] = 0;
  isoBandNextXLB[139] = 0;
  isoBandNextYLB[139] = 1;
  isoBandNextOLB[139] = 0;
  isoBandNextXTL[139] = -1;
  isoBandNextYTL[139] = 0;
  isoBandNextOTL[139] = 0;
  isoBandNextXTR[139] = 1;
  isoBandNextYTR[139] = 0;
  isoBandNextOTR[139] = 1;
  isoBandNextXRT[98] = 0;
  isoBandNextYRT[98] = -1;
  isoBandNextORT[98] = 0;
  isoBandNextXRB[98] = 0;
  isoBandNextYRB[98] = -1;
  isoBandNextORB[98] = 1;
  isoBandNextXBR[98] = 1;
  isoBandNextYBR[98] = 0;
  isoBandNextOBR[98] = 0;
  isoBandNextXBL[98] = 1;
  isoBandNextYBL[98] = 0;
  isoBandNextOBL[98] = 1;
  isoBandNextXLT[98] = 0;
  isoBandNextYLT[98] = 1;
  isoBandNextOLT[98] = 0;
  isoBandNextXTL[98] = -1;
  isoBandNextYTL[98] = 0;
  isoBandNextOTL[98] = 1;
  isoBandNextXRT[99] = 0;
  isoBandNextYRT[99] = 1;
  isoBandNextORT[99] = 0;
  isoBandNextXRB[99] = 0;
  isoBandNextYRB[99] = -1;
  isoBandNextORB[99] = 1;
  isoBandNextXBR[99] = 1;
  isoBandNextYBR[99] = 0;
  isoBandNextOBR[99] = 0;
  isoBandNextXBL[99] = -1;
  isoBandNextYBL[99] = 0;
  isoBandNextOBL[99] = 1;
  isoBandNextXLT[99] = 0;
  isoBandNextYLT[99] = -1;
  isoBandNextOLT[99] = 0;
  isoBandNextXTL[99] = 1;
  isoBandNextYTL[99] = 0;
  isoBandNextOTL[99] = 1;
  isoBandNextXRB[38] = 0;
  isoBandNextYRB[38] = -1;
  isoBandNextORB[38] = 1;
  isoBandNextXBR[38] = 1;
  isoBandNextYBR[38] = 0;
  isoBandNextOBR[38] = 0;
  isoBandNextXLB[38] = 0;
  isoBandNextYLB[38] = 1;
  isoBandNextOLB[38] = 1;
  isoBandNextXLT[38] = 0;
  isoBandNextYLT[38] = 1;
  isoBandNextOLT[38] = 0;
  isoBandNextXTL[38] = -1;
  isoBandNextYTL[38] = 0;
  isoBandNextOTL[38] = 1;
  isoBandNextXTR[38] = -1;
  isoBandNextYTR[38] = 0;
  isoBandNextOTR[38] = 0;
  isoBandNextXRB[39] = 0;
  isoBandNextYRB[39] = 1;
  isoBandNextORB[39] = 1;
  isoBandNextXBR[39] = -1;
  isoBandNextYBR[39] = 0;
  isoBandNextOBR[39] = 0;
  isoBandNextXLB[39] = 0;
  isoBandNextYLB[39] = -1;
  isoBandNextOLB[39] = 1;
  isoBandNextXLT[39] = 0;
  isoBandNextYLT[39] = 1;
  isoBandNextOLT[39] = 0;
  isoBandNextXTL[39] = -1;
  isoBandNextYTL[39] = 0;
  isoBandNextOTL[39] = 1;
  isoBandNextXTR[39] = 1;
  isoBandNextYTR[39] = 0;
  isoBandNextOTR[39] = 0;
  var p00 = function(cell) {
    return [
      [cell.bottomleft, 0],
      [0, 0],
      [0, cell.leftbottom]
    ];
  };
  var p01 = function(cell) {
    return [
      [1, cell.rightbottom],
      [1, 0],
      [cell.bottomright, 0]
    ];
  };
  var p02 = function(cell) {
    return [
      [cell.topright, 1],
      [1, 1],
      [1, cell.righttop]
    ];
  };
  var p03 = function(cell) {
    return [
      [0, cell.lefttop],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p04 = function(cell) {
    return [
      [cell.bottomright, 0],
      [cell.bottomleft, 0],
      [0, cell.leftbottom],
      [0, cell.lefttop]
    ];
  };
  var p05 = function(cell) {
    return [
      [cell.bottomright, 0],
      [cell.bottomleft, 0],
      [1, cell.righttop],
      [1, cell.rightbottom]
    ];
  };
  var p06 = function(cell) {
    return [
      [1, cell.righttop],
      [1, cell.rightbottom],
      [cell.topleft, 1],
      [cell.topright, 1]
    ];
  };
  var p07 = function(cell) {
    return [
      [0, cell.leftbottom],
      [0, cell.lefttop],
      [cell.topleft, 1],
      [cell.topright, 1]
    ];
  };
  var p08 = function(cell) {
    return [
      [0, 0],
      [0, cell.leftbottom],
      [1, cell.rightbottom],
      [1, 0]
    ];
  };
  var p09 = function(cell) {
    return [
      [1, 0],
      [cell.bottomright, 0],
      [cell.topright, 1],
      [1, 1]
    ];
  };
  var p10 = function(cell) {
    return [
      [1, 1],
      [1, cell.righttop],
      [0, cell.lefttop],
      [0, 1]
    ];
  };
  var p11 = function(cell) {
    return [
      [cell.bottomleft, 0],
      [0, 0],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p12 = function(cell) {
    return [
      [1, cell.righttop],
      [1, cell.rightbottom],
      [0, cell.leftbottom],
      [0, cell.lefttop]
    ];
  };
  var p13 = function(cell) {
    return [
      [cell.topleft, 1],
      [cell.topright, 1],
      [cell.bottomright, 0],
      [cell.bottomleft, 0]
    ];
  };
  var p14 = function() {
    return [
      [0, 0],
      [0, 1],
      [1, 1],
      [1, 0]
    ];
  };
  var p15 = function(cell) {
    return [
      [1, cell.rightbottom],
      [1, 0],
      [0, 0],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p16 = function(cell) {
    return [
      [cell.topright, 1],
      [1, 1],
      [1, 0],
      [0, 0],
      [0, cell.leftbottom]
    ];
  };
  var p17 = function(cell) {
    return [
      [1, 0],
      [cell.bottomright, 0],
      [0, cell.lefttop],
      [0, 1],
      [1, 1]
    ];
  };
  var p18 = function(cell) {
    return [
      [1, 1],
      [1, cell.righttop],
      [cell.bottomleft, 0],
      [0, 0],
      [0, 1]
    ];
  };
  var p19 = function(cell) {
    return [
      [1, cell.righttop],
      [1, cell.rightbottom],
      [0, cell.lefttop],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p20 = function(cell) {
    return [
      [1, 1],
      [1, cell.righttop],
      [cell.bottomright, 0],
      [cell.bottomleft, 0],
      [cell.topright, 1]
    ];
  };
  var p21 = function(cell) {
    return [
      [1, cell.rightbottom],
      [1, 0],
      [cell.bottomright, 0],
      [0, cell.leftbottom],
      [0, cell.lefttop]
    ];
  };
  var p22 = function(cell) {
    return [
      [cell.topright, 1],
      [cell.bottomleft, 0],
      [0, 0],
      [0, cell.leftbottom],
      [cell.topleft, 1]
    ];
  };
  var p23 = function(cell) {
    return [
      [cell.bottomright, 0],
      [cell.bottomleft, 0],
      [0, cell.lefttop],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p24 = function(cell) {
    return [
      [1, 1],
      [1, cell.righttop],
      [0, cell.leftbottom],
      [0, cell.lefttop],
      [cell.topright, 1]
    ];
  };
  var p25 = function(cell) {
    return [
      [1, cell.rightbottom],
      [1, 0],
      [cell.bottomright, 0],
      [cell.topleft, 1],
      [cell.topright, 1]
    ];
  };
  var p26 = function(cell) {
    return [
      [1, cell.righttop],
      [1, cell.rightbottom],
      [cell.bottomleft, 0],
      [0, 0],
      [0, cell.leftbottom]
    ];
  };
  var p27 = function(cell) {
    return [
      [1, cell.rightbottom],
      [1, 0],
      [0, 0],
      [0, cell.leftbottom],
      [cell.topleft, 1],
      [cell.topright, 1]
    ];
  };
  var p28 = function(cell) {
    return [
      [1, 1],
      [1, 0],
      [cell.bottomright, 0],
      [0, cell.leftbottom],
      [0, cell.lefttop],
      [cell.topright, 1]
    ];
  };
  var p29 = function(cell) {
    return [
      [1, 1],
      [1, cell.righttop],
      [cell.bottomright, 0],
      [cell.bottomleft, 0],
      [0, cell.lefttop],
      [0, 1]
    ];
  };
  var p30 = function(cell) {
    return [
      [1, cell.righttop],
      [1, cell.rightbottom],
      [cell.bottomleft, 0],
      [0, 0],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p31 = function(cell) {
    return [
      [1, 1],
      [1, cell.righttop],
      [cell.bottomleft, 0],
      [0, 0],
      [0, cell.leftbottom],
      [cell.topright, 1]
    ];
  };
  var p32 = function(cell) {
    return [
      [1, cell.rightbottom],
      [1, 0],
      [cell.bottomright, 0],
      [0, cell.lefttop],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p33 = function(cell) {
    return [
      [1, cell.righttop],
      [1, cell.rightbottom],
      [cell.bottomright, 0],
      [cell.bottomleft, 0],
      [0, cell.leftbottom],
      [0, cell.lefttop],
      [cell.topleft, 1],
      [cell.topright, 1]
    ];
  };
  var p34 = function(cell) {
    return [
      [1, 1],
      [1, cell.righttop],
      [cell.bottomleft, 0],
      [0, 0],
      [0, cell.leftbottom],
      [cell.topright, 1]
    ];
  };
  var p35 = function(cell) {
    return [
      [1, cell.rightbottom],
      [1, 0],
      [cell.bottomright, 0],
      [0, cell.lefttop],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p36 = function(cell) {
    return [
      [1, 1],
      [1, cell.righttop],
      [cell.bottomright, 0],
      [cell.bottomleft, 0],
      [0, cell.leftbottom],
      [0, cell.lefttop],
      [cell.topright, 1]
    ];
  };
  var p37 = function(cell) {
    return [
      [1, cell.righttop],
      [1, cell.rightbottom],
      [cell.bottomleft, 0],
      [0, 0],
      [0, cell.leftbottom],
      [cell.topleft, 1],
      [cell.topright, 1]
    ];
  };
  var p38 = function(cell) {
    return [
      [1, cell.righttop],
      [1, cell.rightbottom],
      [cell.bottomright, 0],
      [cell.bottomleft, 0],
      [0, cell.lefttop],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p39 = function(cell) {
    return [
      [1, cell.rightbottom],
      [1, 0],
      [cell.bottomright, 0],
      [0, cell.leftbottom],
      [0, cell.lefttop],
      [cell.topleft, 1],
      [cell.topright, 1]
    ];
  };
  var isoBandEdgeRT = [];
  var isoBandEdgeRB = [];
  var isoBandEdgeBR = [];
  var isoBandEdgeBL = [];
  var isoBandEdgeLB = [];
  var isoBandEdgeLT = [];
  var isoBandEdgeTL = [];
  var isoBandEdgeTR = [];
  isoBandEdgeBL[1] = isoBandEdgeLB[1] = 18;
  isoBandEdgeBL[169] = isoBandEdgeLB[169] = 18;
  isoBandEdgeBR[4] = isoBandEdgeRB[4] = 12;
  isoBandEdgeBR[166] = isoBandEdgeRB[166] = 12;
  isoBandEdgeRT[16] = isoBandEdgeTR[16] = 4;
  isoBandEdgeRT[154] = isoBandEdgeTR[154] = 4;
  isoBandEdgeLT[64] = isoBandEdgeTL[64] = 22;
  isoBandEdgeLT[106] = isoBandEdgeTL[106] = 22;
  isoBandEdgeBR[2] = isoBandEdgeLT[2] = 17;
  isoBandEdgeBL[2] = isoBandEdgeLB[2] = 18;
  isoBandEdgeBR[168] = isoBandEdgeLT[168] = 17;
  isoBandEdgeBL[168] = isoBandEdgeLB[168] = 18;
  isoBandEdgeRT[8] = isoBandEdgeBL[8] = 9;
  isoBandEdgeRB[8] = isoBandEdgeBR[8] = 12;
  isoBandEdgeRT[162] = isoBandEdgeBL[162] = 9;
  isoBandEdgeRB[162] = isoBandEdgeBR[162] = 12;
  isoBandEdgeRT[32] = isoBandEdgeTR[32] = 4;
  isoBandEdgeRB[32] = isoBandEdgeTL[32] = 1;
  isoBandEdgeRT[138] = isoBandEdgeTR[138] = 4;
  isoBandEdgeRB[138] = isoBandEdgeTL[138] = 1;
  isoBandEdgeLB[128] = isoBandEdgeTR[128] = 21;
  isoBandEdgeLT[128] = isoBandEdgeTL[128] = 22;
  isoBandEdgeLB[42] = isoBandEdgeTR[42] = 21;
  isoBandEdgeLT[42] = isoBandEdgeTL[42] = 22;
  isoBandEdgeRB[5] = isoBandEdgeLB[5] = 14;
  isoBandEdgeRB[165] = isoBandEdgeLB[165] = 14;
  isoBandEdgeBR[20] = isoBandEdgeTR[20] = 6;
  isoBandEdgeBR[150] = isoBandEdgeTR[150] = 6;
  isoBandEdgeRT[80] = isoBandEdgeLT[80] = 11;
  isoBandEdgeRT[90] = isoBandEdgeLT[90] = 11;
  isoBandEdgeBL[65] = isoBandEdgeTL[65] = 3;
  isoBandEdgeBL[105] = isoBandEdgeTL[105] = 3;
  isoBandEdgeRT[160] = isoBandEdgeLT[160] = 11;
  isoBandEdgeRB[160] = isoBandEdgeLB[160] = 14;
  isoBandEdgeRT[10] = isoBandEdgeLT[10] = 11;
  isoBandEdgeRB[10] = isoBandEdgeLB[10] = 14;
  isoBandEdgeBR[130] = isoBandEdgeTR[130] = 6;
  isoBandEdgeBL[130] = isoBandEdgeTL[130] = 3;
  isoBandEdgeBR[40] = isoBandEdgeTR[40] = 6;
  isoBandEdgeBL[40] = isoBandEdgeTL[40] = 3;
  isoBandEdgeRB[101] = isoBandEdgeTL[101] = 1;
  isoBandEdgeRB[69] = isoBandEdgeTL[69] = 1;
  isoBandEdgeLB[149] = isoBandEdgeTR[149] = 21;
  isoBandEdgeLB[21] = isoBandEdgeTR[21] = 21;
  isoBandEdgeBR[86] = isoBandEdgeLT[86] = 17;
  isoBandEdgeBR[84] = isoBandEdgeLT[84] = 17;
  isoBandEdgeRT[89] = isoBandEdgeBL[89] = 9;
  isoBandEdgeRT[81] = isoBandEdgeBL[81] = 9;
  isoBandEdgeRT[96] = isoBandEdgeTL[96] = 0;
  isoBandEdgeRB[96] = isoBandEdgeLT[96] = 15;
  isoBandEdgeRT[74] = isoBandEdgeTL[74] = 0;
  isoBandEdgeRB[74] = isoBandEdgeLT[74] = 15;
  isoBandEdgeRT[24] = isoBandEdgeBR[24] = 8;
  isoBandEdgeBL[24] = isoBandEdgeTR[24] = 7;
  isoBandEdgeRT[146] = isoBandEdgeBR[146] = 8;
  isoBandEdgeBL[146] = isoBandEdgeTR[146] = 7;
  isoBandEdgeRB[6] = isoBandEdgeLT[6] = 15;
  isoBandEdgeBR[6] = isoBandEdgeLB[6] = 16;
  isoBandEdgeRB[164] = isoBandEdgeLT[164] = 15;
  isoBandEdgeBR[164] = isoBandEdgeLB[164] = 16;
  isoBandEdgeBL[129] = isoBandEdgeTR[129] = 7;
  isoBandEdgeLB[129] = isoBandEdgeTL[129] = 20;
  isoBandEdgeBL[41] = isoBandEdgeTR[41] = 7;
  isoBandEdgeLB[41] = isoBandEdgeTL[41] = 20;
  isoBandEdgeBR[66] = isoBandEdgeTL[66] = 2;
  isoBandEdgeBL[66] = isoBandEdgeLT[66] = 19;
  isoBandEdgeBR[104] = isoBandEdgeTL[104] = 2;
  isoBandEdgeBL[104] = isoBandEdgeLT[104] = 19;
  isoBandEdgeRT[144] = isoBandEdgeLB[144] = 10;
  isoBandEdgeLT[144] = isoBandEdgeTR[144] = 23;
  isoBandEdgeRT[26] = isoBandEdgeLB[26] = 10;
  isoBandEdgeLT[26] = isoBandEdgeTR[26] = 23;
  isoBandEdgeRB[36] = isoBandEdgeTR[36] = 5;
  isoBandEdgeBR[36] = isoBandEdgeTL[36] = 2;
  isoBandEdgeRB[134] = isoBandEdgeTR[134] = 5;
  isoBandEdgeBR[134] = isoBandEdgeTL[134] = 2;
  isoBandEdgeRT[9] = isoBandEdgeLB[9] = 10;
  isoBandEdgeRB[9] = isoBandEdgeBL[9] = 13;
  isoBandEdgeRT[161] = isoBandEdgeLB[161] = 10;
  isoBandEdgeRB[161] = isoBandEdgeBL[161] = 13;
  isoBandEdgeRB[37] = isoBandEdgeTR[37] = 5;
  isoBandEdgeLB[37] = isoBandEdgeTL[37] = 20;
  isoBandEdgeRB[133] = isoBandEdgeTR[133] = 5;
  isoBandEdgeLB[133] = isoBandEdgeTL[133] = 20;
  isoBandEdgeBR[148] = isoBandEdgeLB[148] = 16;
  isoBandEdgeLT[148] = isoBandEdgeTR[148] = 23;
  isoBandEdgeBR[22] = isoBandEdgeLB[22] = 16;
  isoBandEdgeLT[22] = isoBandEdgeTR[22] = 23;
  isoBandEdgeRT[82] = isoBandEdgeBR[82] = 8;
  isoBandEdgeBL[82] = isoBandEdgeLT[82] = 19;
  isoBandEdgeRT[88] = isoBandEdgeBR[88] = 8;
  isoBandEdgeBL[88] = isoBandEdgeLT[88] = 19;
  isoBandEdgeRT[73] = isoBandEdgeTL[73] = 0;
  isoBandEdgeRB[73] = isoBandEdgeBL[73] = 13;
  isoBandEdgeRT[97] = isoBandEdgeTL[97] = 0;
  isoBandEdgeRB[97] = isoBandEdgeBL[97] = 13;
  isoBandEdgeRT[145] = isoBandEdgeBL[145] = 9;
  isoBandEdgeLB[145] = isoBandEdgeTR[145] = 21;
  isoBandEdgeRT[25] = isoBandEdgeBL[25] = 9;
  isoBandEdgeLB[25] = isoBandEdgeTR[25] = 21;
  isoBandEdgeRB[70] = isoBandEdgeTL[70] = 1;
  isoBandEdgeBR[70] = isoBandEdgeLT[70] = 17;
  isoBandEdgeRB[100] = isoBandEdgeTL[100] = 1;
  isoBandEdgeBR[100] = isoBandEdgeLT[100] = 17;
  isoBandEdgeRT[34] = isoBandEdgeBL[34] = 9;
  isoBandEdgeRB[34] = isoBandEdgeBR[34] = 12;
  isoBandEdgeLB[34] = isoBandEdgeTR[34] = 21;
  isoBandEdgeLT[34] = isoBandEdgeTL[34] = 22;
  isoBandEdgeRT[136] = isoBandEdgeTR[136] = 4;
  isoBandEdgeRB[136] = isoBandEdgeTL[136] = 1;
  isoBandEdgeBR[136] = isoBandEdgeLT[136] = 17;
  isoBandEdgeBL[136] = isoBandEdgeLB[136] = 18;
  isoBandEdgeRT[35] = isoBandEdgeTR[35] = 4;
  isoBandEdgeRB[35] = isoBandEdgeBR[35] = 12;
  isoBandEdgeBL[35] = isoBandEdgeLB[35] = 18;
  isoBandEdgeLT[35] = isoBandEdgeTL[35] = 22;
  isoBandEdgeRT[153] = isoBandEdgeTR[153] = 4;
  isoBandEdgeBL[153] = isoBandEdgeLB[153] = 18;
  isoBandEdgeRB[102] = isoBandEdgeBR[102] = 12;
  isoBandEdgeLT[102] = isoBandEdgeTL[102] = 22;
  isoBandEdgeRT[155] = isoBandEdgeBL[155] = 9;
  isoBandEdgeLB[155] = isoBandEdgeTR[155] = 23;
  isoBandEdgeRB[103] = isoBandEdgeTL[103] = 1;
  isoBandEdgeBR[103] = isoBandEdgeLT[103] = 17;
  isoBandEdgeRT[152] = isoBandEdgeTR[152] = 4;
  isoBandEdgeBR[152] = isoBandEdgeLT[152] = 17;
  isoBandEdgeBL[152] = isoBandEdgeLB[152] = 18;
  isoBandEdgeRT[156] = isoBandEdgeBR[156] = 8;
  isoBandEdgeBL[156] = isoBandEdgeLB[156] = 18;
  isoBandEdgeLT[156] = isoBandEdgeTR[156] = 23;
  isoBandEdgeRT[137] = isoBandEdgeTR[137] = 4;
  isoBandEdgeRB[137] = isoBandEdgeTL[137] = 1;
  isoBandEdgeBL[137] = isoBandEdgeLB[137] = 18;
  isoBandEdgeRT[139] = isoBandEdgeTR[139] = 4;
  isoBandEdgeRB[139] = isoBandEdgeBL[139] = 13;
  isoBandEdgeLB[139] = isoBandEdgeTL[139] = 20;
  isoBandEdgeRT[98] = isoBandEdgeBL[98] = 9;
  isoBandEdgeRB[98] = isoBandEdgeBR[98] = 12;
  isoBandEdgeLT[98] = isoBandEdgeTL[98] = 22;
  isoBandEdgeRT[99] = isoBandEdgeTL[99] = 0;
  isoBandEdgeRB[99] = isoBandEdgeBR[99] = 12;
  isoBandEdgeBL[99] = isoBandEdgeLT[99] = 19;
  isoBandEdgeRB[38] = isoBandEdgeBR[38] = 12;
  isoBandEdgeLB[38] = isoBandEdgeTR[38] = 21;
  isoBandEdgeLT[38] = isoBandEdgeTL[38] = 22;
  isoBandEdgeRB[39] = isoBandEdgeTR[39] = 5;
  isoBandEdgeBR[39] = isoBandEdgeLB[39] = 16;
  isoBandEdgeLT[39] = isoBandEdgeTL[39] = 22;
  var polygon_table = [];
  polygon_table[1] = polygon_table[169] = p00;
  polygon_table[4] = polygon_table[166] = p01;
  polygon_table[16] = polygon_table[154] = p02;
  polygon_table[64] = polygon_table[106] = p03;
  polygon_table[168] = polygon_table[2] = p04;
  polygon_table[162] = polygon_table[8] = p05;
  polygon_table[138] = polygon_table[32] = p06;
  polygon_table[42] = polygon_table[128] = p07;
  polygon_table[5] = polygon_table[165] = p08;
  polygon_table[20] = polygon_table[150] = p09;
  polygon_table[80] = polygon_table[90] = p10;
  polygon_table[65] = polygon_table[105] = p11;
  polygon_table[160] = polygon_table[10] = p12;
  polygon_table[130] = polygon_table[40] = p13;
  polygon_table[85] = p14;
  polygon_table[101] = polygon_table[69] = p15;
  polygon_table[149] = polygon_table[21] = p16;
  polygon_table[86] = polygon_table[84] = p17;
  polygon_table[89] = polygon_table[81] = p18;
  polygon_table[96] = polygon_table[74] = p19;
  polygon_table[24] = polygon_table[146] = p20;
  polygon_table[6] = polygon_table[164] = p21;
  polygon_table[129] = polygon_table[41] = p22;
  polygon_table[66] = polygon_table[104] = p23;
  polygon_table[144] = polygon_table[26] = p24;
  polygon_table[36] = polygon_table[134] = p25;
  polygon_table[9] = polygon_table[161] = p26;
  polygon_table[37] = polygon_table[133] = p27;
  polygon_table[148] = polygon_table[22] = p28;
  polygon_table[82] = polygon_table[88] = p29;
  polygon_table[73] = polygon_table[97] = p30;
  polygon_table[145] = polygon_table[25] = p31;
  polygon_table[70] = polygon_table[100] = p32;
  polygon_table[34] = function(c) {
    return [p07(c), p05(c)];
  };
  polygon_table[35] = p33;
  polygon_table[136] = function(c) {
    return [p06(c), p04(c)];
  };
  polygon_table[153] = function(c) {
    return [p02(c), p00(c)];
  };
  polygon_table[102] = function(c) {
    return [p01(c), p03(c)];
  };
  polygon_table[155] = p34;
  polygon_table[103] = p35;
  polygon_table[152] = function(c) {
    return [p02(c), p04(c)];
  };
  polygon_table[156] = p36;
  polygon_table[137] = function(c) {
    return [p06(c), p00(c)];
  };
  polygon_table[139] = p37;
  polygon_table[98] = function(c) {
    return [p05(c), p03(c)];
  };
  polygon_table[99] = p38;
  polygon_table[38] = function(c) {
    return [p01(c), p07(c)];
  };
  polygon_table[39] = p39;

  // node_modules/@turf/polygonize/dist/es/lib/util.js
  function mathSign(x2) {
    return (x2 > 0) - (x2 < 0) || +x2;
  }
  function orientationIndex(p1, p2, q) {
    var dx1 = p2[0] - p1[0], dy1 = p2[1] - p1[1], dx2 = q[0] - p2[0], dy2 = q[1] - p2[1];
    return mathSign(dx1 * dy2 - dx2 * dy1);
  }
  function envelopeIsEqual(env1, env2) {
    var envX1 = env1.geometry.coordinates[0].map(function(c) {
      return c[0];
    }), envY1 = env1.geometry.coordinates[0].map(function(c) {
      return c[1];
    }), envX2 = env2.geometry.coordinates[0].map(function(c) {
      return c[0];
    }), envY2 = env2.geometry.coordinates[0].map(function(c) {
      return c[1];
    });
    return Math.max.apply(null, envX1) === Math.max.apply(null, envX2) && Math.max.apply(null, envY1) === Math.max.apply(null, envY2) && Math.min.apply(null, envX1) === Math.min.apply(null, envX2) && Math.min.apply(null, envY1) === Math.min.apply(null, envY2);
  }
  function envelopeContains(self2, env) {
    return env.geometry.coordinates[0].every(function(c) {
      return booleanPointInPolygon(point(c), self2);
    });
  }
  function coordinatesEqual(coord1, coord2) {
    return coord1[0] === coord2[0] && coord1[1] === coord2[1];
  }

  // node_modules/@turf/polygonize/dist/es/lib/Node.js
  var Node = function() {
    function Node2(coordinates) {
      this.id = Node2.buildId(coordinates);
      this.coordinates = coordinates;
      this.innerEdges = [];
      this.outerEdges = [];
      this.outerEdgesSorted = false;
    }
    Node2.buildId = function(coordinates) {
      return coordinates.join(",");
    };
    Node2.prototype.removeInnerEdge = function(edge) {
      this.innerEdges = this.innerEdges.filter(function(e) {
        return e.from.id !== edge.from.id;
      });
    };
    Node2.prototype.removeOuterEdge = function(edge) {
      this.outerEdges = this.outerEdges.filter(function(e) {
        return e.to.id !== edge.to.id;
      });
    };
    Node2.prototype.addOuterEdge = function(edge) {
      this.outerEdges.push(edge);
      this.outerEdgesSorted = false;
    };
    Node2.prototype.sortOuterEdges = function() {
      var _this = this;
      if (!this.outerEdgesSorted) {
        this.outerEdges.sort(function(a, b) {
          var aNode = a.to, bNode = b.to;
          if (aNode.coordinates[0] - _this.coordinates[0] >= 0 && bNode.coordinates[0] - _this.coordinates[0] < 0)
            return 1;
          if (aNode.coordinates[0] - _this.coordinates[0] < 0 && bNode.coordinates[0] - _this.coordinates[0] >= 0)
            return -1;
          if (aNode.coordinates[0] - _this.coordinates[0] === 0 && bNode.coordinates[0] - _this.coordinates[0] === 0) {
            if (aNode.coordinates[1] - _this.coordinates[1] >= 0 || bNode.coordinates[1] - _this.coordinates[1] >= 0)
              return aNode.coordinates[1] - bNode.coordinates[1];
            return bNode.coordinates[1] - aNode.coordinates[1];
          }
          var det = orientationIndex(_this.coordinates, aNode.coordinates, bNode.coordinates);
          if (det < 0)
            return 1;
          if (det > 0)
            return -1;
          var d1 = Math.pow(aNode.coordinates[0] - _this.coordinates[0], 2) + Math.pow(aNode.coordinates[1] - _this.coordinates[1], 2), d2 = Math.pow(bNode.coordinates[0] - _this.coordinates[0], 2) + Math.pow(bNode.coordinates[1] - _this.coordinates[1], 2);
          return d1 - d2;
        });
        this.outerEdgesSorted = true;
      }
    };
    Node2.prototype.getOuterEdges = function() {
      this.sortOuterEdges();
      return this.outerEdges;
    };
    Node2.prototype.getOuterEdge = function(i) {
      this.sortOuterEdges();
      return this.outerEdges[i];
    };
    Node2.prototype.addInnerEdge = function(edge) {
      this.innerEdges.push(edge);
    };
    return Node2;
  }();
  var Node_default = Node;

  // node_modules/@turf/polygonize/dist/es/lib/Edge.js
  var Edge = function() {
    function Edge2(from, to) {
      this.from = from;
      this.to = to;
      this.next = void 0;
      this.label = void 0;
      this.symetric = void 0;
      this.ring = void 0;
      this.from.addOuterEdge(this);
      this.to.addInnerEdge(this);
    }
    Edge2.prototype.getSymetric = function() {
      if (!this.symetric) {
        this.symetric = new Edge2(this.to, this.from);
        this.symetric.symetric = this;
      }
      return this.symetric;
    };
    Edge2.prototype.deleteEdge = function() {
      this.from.removeOuterEdge(this);
      this.to.removeInnerEdge(this);
    };
    Edge2.prototype.isEqual = function(edge) {
      return this.from.id === edge.from.id && this.to.id === edge.to.id;
    };
    Edge2.prototype.toString = function() {
      return "Edge { " + this.from.id + " -> " + this.to.id + " }";
    };
    Edge2.prototype.toLineString = function() {
      return lineString([this.from.coordinates, this.to.coordinates]);
    };
    Edge2.prototype.compareTo = function(edge) {
      return orientationIndex(edge.from.coordinates, edge.to.coordinates, this.to.coordinates);
    };
    return Edge2;
  }();
  var Edge_default = Edge;

  // node_modules/@turf/polygonize/dist/es/lib/EdgeRing.js
  var EdgeRing = function() {
    function EdgeRing2() {
      this.edges = [];
      this.polygon = void 0;
      this.envelope = void 0;
    }
    EdgeRing2.prototype.push = function(edge) {
      this.edges.push(edge);
      this.polygon = this.envelope = void 0;
    };
    EdgeRing2.prototype.get = function(i) {
      return this.edges[i];
    };
    Object.defineProperty(EdgeRing2.prototype, "length", {
      get: function() {
        return this.edges.length;
      },
      enumerable: true,
      configurable: true
    });
    EdgeRing2.prototype.forEach = function(f) {
      this.edges.forEach(f);
    };
    EdgeRing2.prototype.map = function(f) {
      return this.edges.map(f);
    };
    EdgeRing2.prototype.some = function(f) {
      return this.edges.some(f);
    };
    EdgeRing2.prototype.isValid = function() {
      return true;
    };
    EdgeRing2.prototype.isHole = function() {
      var _this = this;
      var hiIndex = this.edges.reduce(function(high, edge, i) {
        if (edge.from.coordinates[1] > _this.edges[high].from.coordinates[1])
          high = i;
        return high;
      }, 0), iPrev = (hiIndex === 0 ? this.length : hiIndex) - 1, iNext = (hiIndex + 1) % this.length, disc = orientationIndex(this.edges[iPrev].from.coordinates, this.edges[hiIndex].from.coordinates, this.edges[iNext].from.coordinates);
      if (disc === 0)
        return this.edges[iPrev].from.coordinates[0] > this.edges[iNext].from.coordinates[0];
      return disc > 0;
    };
    EdgeRing2.prototype.toMultiPoint = function() {
      return multiPoint(this.edges.map(function(edge) {
        return edge.from.coordinates;
      }));
    };
    EdgeRing2.prototype.toPolygon = function() {
      if (this.polygon)
        return this.polygon;
      var coordinates = this.edges.map(function(edge) {
        return edge.from.coordinates;
      });
      coordinates.push(this.edges[0].from.coordinates);
      return this.polygon = polygon([coordinates]);
    };
    EdgeRing2.prototype.getEnvelope = function() {
      if (this.envelope)
        return this.envelope;
      return this.envelope = es_default9(this.toPolygon());
    };
    EdgeRing2.findEdgeRingContaining = function(testEdgeRing, shellList) {
      var testEnvelope = testEdgeRing.getEnvelope();
      var minEnvelope, minShell;
      shellList.forEach(function(shell) {
        var tryEnvelope = shell.getEnvelope();
        if (minShell)
          minEnvelope = minShell.getEnvelope();
        if (envelopeIsEqual(tryEnvelope, testEnvelope))
          return;
        if (envelopeContains(tryEnvelope, testEnvelope)) {
          var testEdgeRingCoordinates = testEdgeRing.map(function(edge) {
            return edge.from.coordinates;
          });
          var testPoint = void 0;
          var _loop_1 = function(pt2) {
            if (!shell.some(function(edge) {
              return coordinatesEqual(pt2, edge.from.coordinates);
            })) {
              testPoint = pt2;
            }
          };
          for (var _i = 0, testEdgeRingCoordinates_1 = testEdgeRingCoordinates; _i < testEdgeRingCoordinates_1.length; _i++) {
            var pt = testEdgeRingCoordinates_1[_i];
            _loop_1(pt);
          }
          if (testPoint && shell.inside(point(testPoint))) {
            if (!minShell || envelopeContains(minEnvelope, tryEnvelope))
              minShell = shell;
          }
        }
      });
      return minShell;
    };
    EdgeRing2.prototype.inside = function(pt) {
      return booleanPointInPolygon(pt, this.toPolygon());
    };
    return EdgeRing2;
  }();
  var EdgeRing_default = EdgeRing;

  // node_modules/@turf/polygonize/dist/es/lib/Graph.js
  function validateGeoJson(geoJson) {
    if (!geoJson)
      throw new Error("No geojson passed");
    if (geoJson.type !== "FeatureCollection" && geoJson.type !== "GeometryCollection" && geoJson.type !== "MultiLineString" && geoJson.type !== "LineString" && geoJson.type !== "Feature")
      throw new Error("Invalid input type '" + geoJson.type + "'. Geojson must be FeatureCollection, GeometryCollection, LineString, MultiLineString or Feature");
  }
  var Graph = function() {
    function Graph3() {
      this.edges = [];
      this.nodes = {};
    }
    Graph3.fromGeoJson = function(geoJson) {
      validateGeoJson(geoJson);
      var graph = new Graph3();
      flattenEach(geoJson, function(feature2) {
        featureOf(feature2, "LineString", "Graph::fromGeoJson");
        coordReduce(feature2, function(prev, cur) {
          if (prev) {
            var start = graph.getNode(prev), end = graph.getNode(cur);
            graph.addEdge(start, end);
          }
          return cur;
        });
      });
      return graph;
    };
    Graph3.prototype.getNode = function(coordinates) {
      var id = Node_default.buildId(coordinates);
      var node = this.nodes[id];
      if (!node)
        node = this.nodes[id] = new Node_default(coordinates);
      return node;
    };
    Graph3.prototype.addEdge = function(from, to) {
      var edge = new Edge_default(from, to), symetricEdge = edge.getSymetric();
      this.edges.push(edge);
      this.edges.push(symetricEdge);
    };
    Graph3.prototype.deleteDangles = function() {
      var _this = this;
      Object.keys(this.nodes).map(function(id) {
        return _this.nodes[id];
      }).forEach(function(node) {
        return _this._removeIfDangle(node);
      });
    };
    Graph3.prototype._removeIfDangle = function(node) {
      var _this = this;
      if (node.innerEdges.length <= 1) {
        var outerNodes = node.getOuterEdges().map(function(e) {
          return e.to;
        });
        this.removeNode(node);
        outerNodes.forEach(function(n) {
          return _this._removeIfDangle(n);
        });
      }
    };
    Graph3.prototype.deleteCutEdges = function() {
      var _this = this;
      this._computeNextCWEdges();
      this._findLabeledEdgeRings();
      this.edges.forEach(function(edge) {
        if (edge.label === edge.symetric.label) {
          _this.removeEdge(edge.symetric);
          _this.removeEdge(edge);
        }
      });
    };
    Graph3.prototype._computeNextCWEdges = function(node) {
      var _this = this;
      if (typeof node === "undefined") {
        Object.keys(this.nodes).forEach(function(id) {
          return _this._computeNextCWEdges(_this.nodes[id]);
        });
      } else {
        node.getOuterEdges().forEach(function(edge, i) {
          node.getOuterEdge((i === 0 ? node.getOuterEdges().length : i) - 1).symetric.next = edge;
        });
      }
    };
    Graph3.prototype._computeNextCCWEdges = function(node, label) {
      var edges2 = node.getOuterEdges();
      var firstOutDE, prevInDE;
      for (var i = edges2.length - 1; i >= 0; --i) {
        var de = edges2[i], sym = de.symetric, outDE = void 0, inDE = void 0;
        if (de.label === label)
          outDE = de;
        if (sym.label === label)
          inDE = sym;
        if (!outDE || !inDE)
          continue;
        if (inDE)
          prevInDE = inDE;
        if (outDE) {
          if (prevInDE) {
            prevInDE.next = outDE;
            prevInDE = void 0;
          }
          if (!firstOutDE)
            firstOutDE = outDE;
        }
      }
      if (prevInDE)
        prevInDE.next = firstOutDE;
    };
    Graph3.prototype._findLabeledEdgeRings = function() {
      var edgeRingStarts = [];
      var label = 0;
      this.edges.forEach(function(edge) {
        if (edge.label >= 0)
          return;
        edgeRingStarts.push(edge);
        var e = edge;
        do {
          e.label = label;
          e = e.next;
        } while (!edge.isEqual(e));
        label++;
      });
      return edgeRingStarts;
    };
    Graph3.prototype.getEdgeRings = function() {
      var _this = this;
      this._computeNextCWEdges();
      this.edges.forEach(function(edge) {
        edge.label = void 0;
      });
      this._findLabeledEdgeRings().forEach(function(edge) {
        _this._findIntersectionNodes(edge).forEach(function(node) {
          _this._computeNextCCWEdges(node, edge.label);
        });
      });
      var edgeRingList = [];
      this.edges.forEach(function(edge) {
        if (edge.ring)
          return;
        edgeRingList.push(_this._findEdgeRing(edge));
      });
      return edgeRingList;
    };
    Graph3.prototype._findIntersectionNodes = function(startEdge) {
      var intersectionNodes = [];
      var edge = startEdge;
      var _loop_1 = function() {
        var degree = 0;
        edge.from.getOuterEdges().forEach(function(e) {
          if (e.label === startEdge.label)
            ++degree;
        });
        if (degree > 1)
          intersectionNodes.push(edge.from);
        edge = edge.next;
      };
      do {
        _loop_1();
      } while (!startEdge.isEqual(edge));
      return intersectionNodes;
    };
    Graph3.prototype._findEdgeRing = function(startEdge) {
      var edge = startEdge;
      var edgeRing = new EdgeRing_default();
      do {
        edgeRing.push(edge);
        edge.ring = edgeRing;
        edge = edge.next;
      } while (!startEdge.isEqual(edge));
      return edgeRing;
    };
    Graph3.prototype.removeNode = function(node) {
      var _this = this;
      node.getOuterEdges().forEach(function(edge) {
        return _this.removeEdge(edge);
      });
      node.innerEdges.forEach(function(edge) {
        return _this.removeEdge(edge);
      });
      delete this.nodes[node.id];
    };
    Graph3.prototype.removeEdge = function(edge) {
      this.edges = this.edges.filter(function(e) {
        return !e.isEqual(edge);
      });
      edge.deleteEdge();
    };
    return Graph3;
  }();

  // node_modules/@turf/boolean-overlap/dist/es/index.js
  var import_geojson_equality = __toESM(require_geojson_equality(), 1);

  // node_modules/@turf/boolean-equal/dist/es/index.js
  var import_geojson_equality2 = __toESM(require_geojson_equality(), 1);

  // node_modules/@turf/clusters-dbscan/dist/es/index.js
  var import_density_clustering = __toESM(require_lib(), 1);

  // node_modules/@turf/clusters-kmeans/dist/es/index.js
  var import_skmeans = __toESM(require_main(), 1);

  // node_modules/@turf/shortest-path/dist/es/index.js
  function pathTo(node) {
    var curr = node, path = [];
    while (curr.parent) {
      path.unshift(curr);
      curr = curr.parent;
    }
    return path;
  }
  function getHeap() {
    return new BinaryHeap(function(node) {
      return node.f;
    });
  }
  var astar = {
    search: function(graph, start, end, options) {
      graph.cleanDirty();
      options = options || {};
      var heuristic = options.heuristic || astar.heuristics.manhattan, closest = options.closest || false;
      var openHeap = getHeap(), closestNode = start;
      start.h = heuristic(start, end);
      openHeap.push(start);
      while (openHeap.size() > 0) {
        var currentNode = openHeap.pop();
        if (currentNode === end) {
          return pathTo(currentNode);
        }
        currentNode.closed = true;
        var neighbors = graph.neighbors(currentNode);
        for (var i = 0, il = neighbors.length; i < il; ++i) {
          var neighbor = neighbors[i];
          if (neighbor.closed || neighbor.isWall()) {
            continue;
          }
          var gScore = currentNode.g + neighbor.getCost(currentNode), beenVisited = neighbor.visited;
          if (!beenVisited || gScore < neighbor.g) {
            neighbor.visited = true;
            neighbor.parent = currentNode;
            neighbor.h = neighbor.h || heuristic(neighbor, end);
            neighbor.g = gScore;
            neighbor.f = neighbor.g + neighbor.h;
            graph.markDirty(neighbor);
            if (closest) {
              if (neighbor.h < closestNode.h || neighbor.h === closestNode.h && neighbor.g < closestNode.g) {
                closestNode = neighbor;
              }
            }
            if (!beenVisited) {
              openHeap.push(neighbor);
            } else {
              openHeap.rescoreElement(neighbor);
            }
          }
        }
      }
      if (closest) {
        return pathTo(closestNode);
      }
      return [];
    },
    heuristics: {
      manhattan: function(pos0, pos1) {
        var d1 = Math.abs(pos1.x - pos0.x);
        var d2 = Math.abs(pos1.y - pos0.y);
        return d1 + d2;
      },
      diagonal: function(pos0, pos1) {
        var D = 1;
        var D2 = Math.sqrt(2);
        var d1 = Math.abs(pos1.x - pos0.x);
        var d2 = Math.abs(pos1.y - pos0.y);
        return D * (d1 + d2) + (D2 - 2 * D) * Math.min(d1, d2);
      }
    },
    cleanNode: function(node) {
      node.f = 0;
      node.g = 0;
      node.h = 0;
      node.visited = false;
      node.closed = false;
      node.parent = null;
    }
  };
  function Graph2(gridIn, options) {
    options = options || {};
    this.nodes = [];
    this.diagonal = !!options.diagonal;
    this.grid = [];
    for (var x2 = 0; x2 < gridIn.length; x2++) {
      this.grid[x2] = [];
      for (var y2 = 0, row = gridIn[x2]; y2 < row.length; y2++) {
        var node = new GridNode(x2, y2, row[y2]);
        this.grid[x2][y2] = node;
        this.nodes.push(node);
      }
    }
    this.init();
  }
  Graph2.prototype.init = function() {
    this.dirtyNodes = [];
    for (var i = 0; i < this.nodes.length; i++) {
      astar.cleanNode(this.nodes[i]);
    }
  };
  Graph2.prototype.cleanDirty = function() {
    for (var i = 0; i < this.dirtyNodes.length; i++) {
      astar.cleanNode(this.dirtyNodes[i]);
    }
    this.dirtyNodes = [];
  };
  Graph2.prototype.markDirty = function(node) {
    this.dirtyNodes.push(node);
  };
  Graph2.prototype.neighbors = function(node) {
    var ret = [], x2 = node.x, y2 = node.y, grid = this.grid;
    if (grid[x2 - 1] && grid[x2 - 1][y2]) {
      ret.push(grid[x2 - 1][y2]);
    }
    if (grid[x2 + 1] && grid[x2 + 1][y2]) {
      ret.push(grid[x2 + 1][y2]);
    }
    if (grid[x2] && grid[x2][y2 - 1]) {
      ret.push(grid[x2][y2 - 1]);
    }
    if (grid[x2] && grid[x2][y2 + 1]) {
      ret.push(grid[x2][y2 + 1]);
    }
    if (this.diagonal) {
      if (grid[x2 - 1] && grid[x2 - 1][y2 - 1]) {
        ret.push(grid[x2 - 1][y2 - 1]);
      }
      if (grid[x2 + 1] && grid[x2 + 1][y2 - 1]) {
        ret.push(grid[x2 + 1][y2 - 1]);
      }
      if (grid[x2 - 1] && grid[x2 - 1][y2 + 1]) {
        ret.push(grid[x2 - 1][y2 + 1]);
      }
      if (grid[x2 + 1] && grid[x2 + 1][y2 + 1]) {
        ret.push(grid[x2 + 1][y2 + 1]);
      }
    }
    return ret;
  };
  Graph2.prototype.toString = function() {
    var graphString = [], nodes = this.grid, rowDebug, row, y2, l;
    for (var x2 = 0, len = nodes.length; x2 < len; x2++) {
      rowDebug = [];
      row = nodes[x2];
      for (y2 = 0, l = row.length; y2 < l; y2++) {
        rowDebug.push(row[y2].weight);
      }
      graphString.push(rowDebug.join(" "));
    }
    return graphString.join("\n");
  };
  function GridNode(x2, y2, weight) {
    this.x = x2;
    this.y = y2;
    this.weight = weight;
  }
  GridNode.prototype.toString = function() {
    return "[" + this.x + " " + this.y + "]";
  };
  GridNode.prototype.getCost = function(fromNeighbor) {
    if (fromNeighbor && fromNeighbor.x !== this.x && fromNeighbor.y !== this.y) {
      return this.weight * 1.41421;
    }
    return this.weight;
  };
  GridNode.prototype.isWall = function() {
    return this.weight === 0;
  };
  function BinaryHeap(scoreFunction) {
    this.content = [];
    this.scoreFunction = scoreFunction;
  }
  BinaryHeap.prototype = {
    push: function(element) {
      this.content.push(element);
      this.sinkDown(this.content.length - 1);
    },
    pop: function() {
      var result = this.content[0];
      var end = this.content.pop();
      if (this.content.length > 0) {
        this.content[0] = end;
        this.bubbleUp(0);
      }
      return result;
    },
    remove: function(node) {
      var i = this.content.indexOf(node);
      var end = this.content.pop();
      if (i !== this.content.length - 1) {
        this.content[i] = end;
        if (this.scoreFunction(end) < this.scoreFunction(node)) {
          this.sinkDown(i);
        } else {
          this.bubbleUp(i);
        }
      }
    },
    size: function() {
      return this.content.length;
    },
    rescoreElement: function(node) {
      this.sinkDown(this.content.indexOf(node));
    },
    sinkDown: function(n) {
      var element = this.content[n];
      while (n > 0) {
        var parentN = (n + 1 >> 1) - 1, parent = this.content[parentN];
        if (this.scoreFunction(element) < this.scoreFunction(parent)) {
          this.content[parentN] = element;
          this.content[n] = parent;
          n = parentN;
        } else {
          break;
        }
      }
    },
    bubbleUp: function(n) {
      var length2 = this.content.length, element = this.content[n], elemScore = this.scoreFunction(element);
      while (true) {
        var child2N = n + 1 << 1, child1N = child2N - 1;
        var swap = null, child1Score;
        if (child1N < length2) {
          var child1 = this.content[child1N];
          child1Score = this.scoreFunction(child1);
          if (child1Score < elemScore) {
            swap = child1N;
          }
        }
        if (child2N < length2) {
          var child2 = this.content[child2N], child2Score = this.scoreFunction(child2);
          if (child2Score < (swap === null ? elemScore : child1Score)) {
            swap = child2N;
          }
        }
        if (swap !== null) {
          this.content[n] = this.content[swap];
          this.content[swap] = element;
          n = swap;
        } else {
          break;
        }
      }
    }
  };

  // node_modules/d3-voronoi/src/RedBlackTree.js
  function RedBlackTree() {
    this._ = null;
  }
  function RedBlackNode(node) {
    node.U = node.C = node.L = node.R = node.P = node.N = null;
  }
  RedBlackTree.prototype = {
    constructor: RedBlackTree,
    insert: function(after, node) {
      var parent, grandpa, uncle;
      if (after) {
        node.P = after;
        node.N = after.N;
        if (after.N)
          after.N.P = node;
        after.N = node;
        if (after.R) {
          after = after.R;
          while (after.L)
            after = after.L;
          after.L = node;
        } else {
          after.R = node;
        }
        parent = after;
      } else if (this._) {
        after = RedBlackFirst(this._);
        node.P = null;
        node.N = after;
        after.P = after.L = node;
        parent = after;
      } else {
        node.P = node.N = null;
        this._ = node;
        parent = null;
      }
      node.L = node.R = null;
      node.U = parent;
      node.C = true;
      after = node;
      while (parent && parent.C) {
        grandpa = parent.U;
        if (parent === grandpa.L) {
          uncle = grandpa.R;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.R) {
              RedBlackRotateLeft(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            RedBlackRotateRight(this, grandpa);
          }
        } else {
          uncle = grandpa.L;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.L) {
              RedBlackRotateRight(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            RedBlackRotateLeft(this, grandpa);
          }
        }
        parent = after.U;
      }
      this._.C = false;
    },
    remove: function(node) {
      if (node.N)
        node.N.P = node.P;
      if (node.P)
        node.P.N = node.N;
      node.N = node.P = null;
      var parent = node.U, sibling, left = node.L, right = node.R, next, red;
      if (!left)
        next = right;
      else if (!right)
        next = left;
      else
        next = RedBlackFirst(right);
      if (parent) {
        if (parent.L === node)
          parent.L = next;
        else
          parent.R = next;
      } else {
        this._ = next;
      }
      if (left && right) {
        red = next.C;
        next.C = node.C;
        next.L = left;
        left.U = next;
        if (next !== right) {
          parent = next.U;
          next.U = node.U;
          node = next.R;
          parent.L = node;
          next.R = right;
          right.U = next;
        } else {
          next.U = parent;
          parent = next;
          node = next.R;
        }
      } else {
        red = node.C;
        node = next;
      }
      if (node)
        node.U = parent;
      if (red)
        return;
      if (node && node.C) {
        node.C = false;
        return;
      }
      do {
        if (node === this._)
          break;
        if (node === parent.L) {
          sibling = parent.R;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            RedBlackRotateLeft(this, parent);
            sibling = parent.R;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.R || !sibling.R.C) {
              sibling.L.C = false;
              sibling.C = true;
              RedBlackRotateRight(this, sibling);
              sibling = parent.R;
            }
            sibling.C = parent.C;
            parent.C = sibling.R.C = false;
            RedBlackRotateLeft(this, parent);
            node = this._;
            break;
          }
        } else {
          sibling = parent.L;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            RedBlackRotateRight(this, parent);
            sibling = parent.L;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.L || !sibling.L.C) {
              sibling.R.C = false;
              sibling.C = true;
              RedBlackRotateLeft(this, sibling);
              sibling = parent.L;
            }
            sibling.C = parent.C;
            parent.C = sibling.L.C = false;
            RedBlackRotateRight(this, parent);
            node = this._;
            break;
          }
        }
        sibling.C = true;
        node = parent;
        parent = parent.U;
      } while (!node.C);
      if (node)
        node.C = false;
    }
  };
  function RedBlackRotateLeft(tree, node) {
    var p = node, q = node.R, parent = p.U;
    if (parent) {
      if (parent.L === p)
        parent.L = q;
      else
        parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.R = q.L;
    if (p.R)
      p.R.U = p;
    q.L = p;
  }
  function RedBlackRotateRight(tree, node) {
    var p = node, q = node.L, parent = p.U;
    if (parent) {
      if (parent.L === p)
        parent.L = q;
      else
        parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.L = q.R;
    if (p.L)
      p.L.U = p;
    q.R = p;
  }
  function RedBlackFirst(node) {
    while (node.L)
      node = node.L;
    return node;
  }
  var RedBlackTree_default = RedBlackTree;

  // node_modules/d3-voronoi/src/Edge.js
  function createEdge(left, right, v0, v1) {
    var edge = [null, null], index = edges.push(edge) - 1;
    edge.left = left;
    edge.right = right;
    if (v0)
      setEdgeEnd(edge, left, right, v0);
    if (v1)
      setEdgeEnd(edge, right, left, v1);
    cells[left.index].halfedges.push(index);
    cells[right.index].halfedges.push(index);
    return edge;
  }
  function createBorderEdge(left, v0, v1) {
    var edge = [v0, v1];
    edge.left = left;
    return edge;
  }
  function setEdgeEnd(edge, left, right, vertex) {
    if (!edge[0] && !edge[1]) {
      edge[0] = vertex;
      edge.left = left;
      edge.right = right;
    } else if (edge.left === right) {
      edge[1] = vertex;
    } else {
      edge[0] = vertex;
    }
  }
  function clipEdge(edge, x02, y0, x12, y1) {
    var a = edge[0], b = edge[1], ax = a[0], ay = a[1], bx = b[0], by = b[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
    r = x02 - ax;
    if (!dx && r > 0)
      return;
    r /= dx;
    if (dx < 0) {
      if (r < t0)
        return;
      if (r < t1)
        t1 = r;
    } else if (dx > 0) {
      if (r > t1)
        return;
      if (r > t0)
        t0 = r;
    }
    r = x12 - ax;
    if (!dx && r < 0)
      return;
    r /= dx;
    if (dx < 0) {
      if (r > t1)
        return;
      if (r > t0)
        t0 = r;
    } else if (dx > 0) {
      if (r < t0)
        return;
      if (r < t1)
        t1 = r;
    }
    r = y0 - ay;
    if (!dy && r > 0)
      return;
    r /= dy;
    if (dy < 0) {
      if (r < t0)
        return;
      if (r < t1)
        t1 = r;
    } else if (dy > 0) {
      if (r > t1)
        return;
      if (r > t0)
        t0 = r;
    }
    r = y1 - ay;
    if (!dy && r < 0)
      return;
    r /= dy;
    if (dy < 0) {
      if (r > t1)
        return;
      if (r > t0)
        t0 = r;
    } else if (dy > 0) {
      if (r < t0)
        return;
      if (r < t1)
        t1 = r;
    }
    if (!(t0 > 0) && !(t1 < 1))
      return true;
    if (t0 > 0)
      edge[0] = [ax + t0 * dx, ay + t0 * dy];
    if (t1 < 1)
      edge[1] = [ax + t1 * dx, ay + t1 * dy];
    return true;
  }
  function connectEdge(edge, x02, y0, x12, y1) {
    var v1 = edge[1];
    if (v1)
      return true;
    var v0 = edge[0], left = edge.left, right = edge.right, lx = left[0], ly = left[1], rx = right[0], ry = right[1], fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
    if (ry === ly) {
      if (fx < x02 || fx >= x12)
        return;
      if (lx > rx) {
        if (!v0)
          v0 = [fx, y0];
        else if (v0[1] >= y1)
          return;
        v1 = [fx, y1];
      } else {
        if (!v0)
          v0 = [fx, y1];
        else if (v0[1] < y0)
          return;
        v1 = [fx, y0];
      }
    } else {
      fm = (lx - rx) / (ry - ly);
      fb = fy - fm * fx;
      if (fm < -1 || fm > 1) {
        if (lx > rx) {
          if (!v0)
            v0 = [(y0 - fb) / fm, y0];
          else if (v0[1] >= y1)
            return;
          v1 = [(y1 - fb) / fm, y1];
        } else {
          if (!v0)
            v0 = [(y1 - fb) / fm, y1];
          else if (v0[1] < y0)
            return;
          v1 = [(y0 - fb) / fm, y0];
        }
      } else {
        if (ly < ry) {
          if (!v0)
            v0 = [x02, fm * x02 + fb];
          else if (v0[0] >= x12)
            return;
          v1 = [x12, fm * x12 + fb];
        } else {
          if (!v0)
            v0 = [x12, fm * x12 + fb];
          else if (v0[0] < x02)
            return;
          v1 = [x02, fm * x02 + fb];
        }
      }
    }
    edge[0] = v0;
    edge[1] = v1;
    return true;
  }
  function clipEdges(x02, y0, x12, y1) {
    var i = edges.length, edge;
    while (i--) {
      if (!connectEdge(edge = edges[i], x02, y0, x12, y1) || !clipEdge(edge, x02, y0, x12, y1) || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon || Math.abs(edge[0][1] - edge[1][1]) > epsilon)) {
        delete edges[i];
      }
    }
  }

  // node_modules/d3-voronoi/src/Cell.js
  function createCell(site) {
    return cells[site.index] = {
      site,
      halfedges: []
    };
  }
  function cellHalfedgeAngle(cell, edge) {
    var site = cell.site, va = edge.left, vb = edge.right;
    if (site === vb)
      vb = va, va = site;
    if (vb)
      return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
    if (site === va)
      va = edge[1], vb = edge[0];
    else
      va = edge[0], vb = edge[1];
    return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
  }
  function cellHalfedgeStart(cell, edge) {
    return edge[+(edge.left !== cell.site)];
  }
  function cellHalfedgeEnd(cell, edge) {
    return edge[+(edge.left === cell.site)];
  }
  function sortCellHalfedges() {
    for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {
      if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {
        var index = new Array(m), array2 = new Array(m);
        for (j = 0; j < m; ++j)
          index[j] = j, array2[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);
        index.sort(function(i2, j2) {
          return array2[j2] - array2[i2];
        });
        for (j = 0; j < m; ++j)
          array2[j] = halfedges[index[j]];
        for (j = 0; j < m; ++j)
          halfedges[j] = array2[j];
      }
    }
  }
  function clipCells(x02, y0, x12, y1) {
    var nCells = cells.length, iCell, cell, site, iHalfedge, halfedges, nHalfedges, start, startX, startY, end, endX, endY, cover = true;
    for (iCell = 0; iCell < nCells; ++iCell) {
      if (cell = cells[iCell]) {
        site = cell.site;
        halfedges = cell.halfedges;
        iHalfedge = halfedges.length;
        while (iHalfedge--) {
          if (!edges[halfedges[iHalfedge]]) {
            halfedges.splice(iHalfedge, 1);
          }
        }
        iHalfedge = 0, nHalfedges = halfedges.length;
        while (iHalfedge < nHalfedges) {
          end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];
          start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];
          if (Math.abs(endX - startX) > epsilon || Math.abs(endY - startY) > epsilon) {
            halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(
              site,
              end,
              Math.abs(endX - x02) < epsilon && y1 - endY > epsilon ? [x02, Math.abs(startX - x02) < epsilon ? startY : y1] : Math.abs(endY - y1) < epsilon && x12 - endX > epsilon ? [Math.abs(startY - y1) < epsilon ? startX : x12, y1] : Math.abs(endX - x12) < epsilon && endY - y0 > epsilon ? [x12, Math.abs(startX - x12) < epsilon ? startY : y0] : Math.abs(endY - y0) < epsilon && endX - x02 > epsilon ? [Math.abs(startY - y0) < epsilon ? startX : x02, y0] : null
            )) - 1);
            ++nHalfedges;
          }
        }
        if (nHalfedges)
          cover = false;
      }
    }
    if (cover) {
      var dx, dy, d2, dc = Infinity;
      for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
        if (cell = cells[iCell]) {
          site = cell.site;
          dx = site[0] - x02;
          dy = site[1] - y0;
          d2 = dx * dx + dy * dy;
          if (d2 < dc)
            dc = d2, cover = cell;
        }
      }
      if (cover) {
        var v00 = [x02, y0], v01 = [x02, y1], v11 = [x12, y1], v10 = [x12, y0];
        cover.halfedges.push(
          edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1,
          edges.push(createBorderEdge(site, v01, v11)) - 1,
          edges.push(createBorderEdge(site, v11, v10)) - 1,
          edges.push(createBorderEdge(site, v10, v00)) - 1
        );
      }
    }
    for (iCell = 0; iCell < nCells; ++iCell) {
      if (cell = cells[iCell]) {
        if (!cell.halfedges.length) {
          delete cells[iCell];
        }
      }
    }
  }

  // node_modules/d3-voronoi/src/Circle.js
  var circlePool = [];
  var firstCircle;
  function Circle() {
    RedBlackNode(this);
    this.x = this.y = this.arc = this.site = this.cy = null;
  }
  function attachCircle(arc) {
    var lArc = arc.P, rArc = arc.N;
    if (!lArc || !rArc)
      return;
    var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
    if (lSite === rSite)
      return;
    var bx = cSite[0], by = cSite[1], ax = lSite[0] - bx, ay = lSite[1] - by, cx = rSite[0] - bx, cy = rSite[1] - by;
    var d = 2 * (ax * cy - ay * cx);
    if (d >= -epsilon2)
      return;
    var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x2 = (cy * ha - ay * hc) / d, y2 = (ax * hc - cx * ha) / d;
    var circle3 = circlePool.pop() || new Circle();
    circle3.arc = arc;
    circle3.site = cSite;
    circle3.x = x2 + bx;
    circle3.y = (circle3.cy = y2 + by) + Math.sqrt(x2 * x2 + y2 * y2);
    arc.circle = circle3;
    var before = null, node = circles._;
    while (node) {
      if (circle3.y < node.y || circle3.y === node.y && circle3.x <= node.x) {
        if (node.L)
          node = node.L;
        else {
          before = node.P;
          break;
        }
      } else {
        if (node.R)
          node = node.R;
        else {
          before = node;
          break;
        }
      }
    }
    circles.insert(before, circle3);
    if (!before)
      firstCircle = circle3;
  }
  function detachCircle(arc) {
    var circle3 = arc.circle;
    if (circle3) {
      if (!circle3.P)
        firstCircle = circle3.N;
      circles.remove(circle3);
      circlePool.push(circle3);
      RedBlackNode(circle3);
      arc.circle = null;
    }
  }

  // node_modules/d3-voronoi/src/Beach.js
  var beachPool = [];
  function Beach() {
    RedBlackNode(this);
    this.edge = this.site = this.circle = null;
  }
  function createBeach(site) {
    var beach = beachPool.pop() || new Beach();
    beach.site = site;
    return beach;
  }
  function detachBeach(beach) {
    detachCircle(beach);
    beaches.remove(beach);
    beachPool.push(beach);
    RedBlackNode(beach);
  }
  function removeBeach(beach) {
    var circle3 = beach.circle, x2 = circle3.x, y2 = circle3.cy, vertex = [x2, y2], previous = beach.P, next = beach.N, disappearing = [beach];
    detachBeach(beach);
    var lArc = previous;
    while (lArc.circle && Math.abs(x2 - lArc.circle.x) < epsilon && Math.abs(y2 - lArc.circle.cy) < epsilon) {
      previous = lArc.P;
      disappearing.unshift(lArc);
      detachBeach(lArc);
      lArc = previous;
    }
    disappearing.unshift(lArc);
    detachCircle(lArc);
    var rArc = next;
    while (rArc.circle && Math.abs(x2 - rArc.circle.x) < epsilon && Math.abs(y2 - rArc.circle.cy) < epsilon) {
      next = rArc.N;
      disappearing.push(rArc);
      detachBeach(rArc);
      rArc = next;
    }
    disappearing.push(rArc);
    detachCircle(rArc);
    var nArcs = disappearing.length, iArc;
    for (iArc = 1; iArc < nArcs; ++iArc) {
      rArc = disappearing[iArc];
      lArc = disappearing[iArc - 1];
      setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
    }
    lArc = disappearing[0];
    rArc = disappearing[nArcs - 1];
    rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);
    attachCircle(lArc);
    attachCircle(rArc);
  }
  function addBeach(site) {
    var x2 = site[0], directrix = site[1], lArc, rArc, dxl, dxr, node = beaches._;
    while (node) {
      dxl = leftBreakPoint(node, directrix) - x2;
      if (dxl > epsilon)
        node = node.L;
      else {
        dxr = x2 - rightBreakPoint(node, directrix);
        if (dxr > epsilon) {
          if (!node.R) {
            lArc = node;
            break;
          }
          node = node.R;
        } else {
          if (dxl > -epsilon) {
            lArc = node.P;
            rArc = node;
          } else if (dxr > -epsilon) {
            lArc = node;
            rArc = node.N;
          } else {
            lArc = rArc = node;
          }
          break;
        }
      }
    }
    createCell(site);
    var newArc = createBeach(site);
    beaches.insert(lArc, newArc);
    if (!lArc && !rArc)
      return;
    if (lArc === rArc) {
      detachCircle(lArc);
      rArc = createBeach(lArc.site);
      beaches.insert(newArc, rArc);
      newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);
      attachCircle(lArc);
      attachCircle(rArc);
      return;
    }
    if (!rArc) {
      newArc.edge = createEdge(lArc.site, newArc.site);
      return;
    }
    detachCircle(lArc);
    detachCircle(rArc);
    var lSite = lArc.site, ax = lSite[0], ay = lSite[1], bx = site[0] - ax, by = site[1] - ay, rSite = rArc.site, cx = rSite[0] - ax, cy = rSite[1] - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];
    setEdgeEnd(rArc.edge, lSite, rSite, vertex);
    newArc.edge = createEdge(lSite, site, null, vertex);
    rArc.edge = createEdge(site, rSite, null, vertex);
    attachCircle(lArc);
    attachCircle(rArc);
  }
  function leftBreakPoint(arc, directrix) {
    var site = arc.site, rfocx = site[0], rfocy = site[1], pby2 = rfocy - directrix;
    if (!pby2)
      return rfocx;
    var lArc = arc.P;
    if (!lArc)
      return -Infinity;
    site = lArc.site;
    var lfocx = site[0], lfocy = site[1], plby2 = lfocy - directrix;
    if (!plby2)
      return lfocx;
    var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
    if (aby2)
      return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
    return (rfocx + lfocx) / 2;
  }
  function rightBreakPoint(arc, directrix) {
    var rArc = arc.N;
    if (rArc)
      return leftBreakPoint(rArc, directrix);
    var site = arc.site;
    return site[1] === directrix ? site[0] : Infinity;
  }

  // node_modules/d3-voronoi/src/Diagram.js
  var epsilon = 1e-6;
  var epsilon2 = 1e-12;
  var beaches;
  var cells;
  var circles;
  var edges;
  function triangleArea(a, b, c) {
    return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);
  }
  function lexicographic(a, b) {
    return b[1] - a[1] || b[0] - a[0];
  }
  function Diagram(sites, extent) {
    var site = sites.sort(lexicographic).pop(), x2, y2, circle3;
    edges = [];
    cells = new Array(sites.length);
    beaches = new RedBlackTree_default();
    circles = new RedBlackTree_default();
    while (true) {
      circle3 = firstCircle;
      if (site && (!circle3 || site[1] < circle3.y || site[1] === circle3.y && site[0] < circle3.x)) {
        if (site[0] !== x2 || site[1] !== y2) {
          addBeach(site);
          x2 = site[0], y2 = site[1];
        }
        site = sites.pop();
      } else if (circle3) {
        removeBeach(circle3.arc);
      } else {
        break;
      }
    }
    sortCellHalfedges();
    if (extent) {
      var x02 = +extent[0][0], y0 = +extent[0][1], x12 = +extent[1][0], y1 = +extent[1][1];
      clipEdges(x02, y0, x12, y1);
      clipCells(x02, y0, x12, y1);
    }
    this.edges = edges;
    this.cells = cells;
    beaches = circles = edges = cells = null;
  }
  Diagram.prototype = {
    constructor: Diagram,
    polygons: function() {
      var edges2 = this.edges;
      return this.cells.map(function(cell) {
        var polygon2 = cell.halfedges.map(function(i) {
          return cellHalfedgeStart(cell, edges2[i]);
        });
        polygon2.data = cell.site.data;
        return polygon2;
      });
    },
    triangles: function() {
      var triangles = [], edges2 = this.edges;
      this.cells.forEach(function(cell, i) {
        if (!(m = (halfedges = cell.halfedges).length))
          return;
        var site = cell.site, halfedges, j = -1, m, s0, e1 = edges2[halfedges[m - 1]], s1 = e1.left === site ? e1.right : e1.left;
        while (++j < m) {
          s0 = s1;
          e1 = edges2[halfedges[j]];
          s1 = e1.left === site ? e1.right : e1.left;
          if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
            triangles.push([site.data, s0.data, s1.data]);
          }
        }
      });
      return triangles;
    },
    links: function() {
      return this.edges.filter(function(edge) {
        return edge.right;
      }).map(function(edge) {
        return {
          source: edge.left.data,
          target: edge.right.data
        };
      });
    },
    find: function(x2, y2, radius) {
      var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;
      while (!(cell = that.cells[i1]))
        if (++i1 >= n)
          return null;
      var dx = x2 - cell.site[0], dy = y2 - cell.site[1], d2 = dx * dx + dy * dy;
      do {
        cell = that.cells[i0 = i1], i1 = null;
        cell.halfedges.forEach(function(e) {
          var edge = that.edges[e], v = edge.left;
          if ((v === cell.site || !v) && !(v = edge.right))
            return;
          var vx = x2 - v[0], vy = y2 - v[1], v2 = vx * vx + vy * vy;
          if (v2 < d2)
            d2 = v2, i1 = v.index;
        });
      } while (i1 !== null);
      that._found = i0;
      return radius == null || d2 <= radius * radius ? cell.site : null;
    }
  };

  // node_modules/@turf/difference/dist/es/index.js
  var import_polygon_clipping = __toESM(require_polygon_clipping_umd(), 1);

  // node_modules/@turf/buffer/dist/es/index.js
  var import_turf_jsts = __toESM(require_jsts_min(), 1);

  // node_modules/@turf/buffer/node_modules/d3-geo/src/adder.js
  function adder_default() {
    return new Adder();
  }
  function Adder() {
    this.reset();
  }
  Adder.prototype = {
    constructor: Adder,
    reset: function() {
      this.s = this.t = 0;
    },
    add: function(y2) {
      add(temp, y2, this.t);
      add(this, temp.s, this.s);
      if (this.s)
        this.t += temp.t;
      else
        this.s = temp.t;
    },
    valueOf: function() {
      return this.s;
    }
  };
  var temp = new Adder();
  function add(adder, a, b) {
    var x2 = adder.s = a + b, bv = x2 - a, av = x2 - bv;
    adder.t = a - av + (b - bv);
  }

  // node_modules/@turf/buffer/node_modules/d3-geo/src/math.js
  var epsilon3 = 1e-6;
  var pi = Math.PI;
  var halfPi = pi / 2;
  var quarterPi = pi / 4;
  var tau = pi * 2;
  var degrees = 180 / pi;
  var radians = pi / 180;
  var abs = Math.abs;
  var atan = Math.atan;
  var atan2 = Math.atan2;
  var cos = Math.cos;
  var exp = Math.exp;
  var log = Math.log;
  var sin = Math.sin;
  var sqrt = Math.sqrt;
  var tan = Math.tan;
  function acos(x2) {
    return x2 > 1 ? 0 : x2 < -1 ? pi : Math.acos(x2);
  }
  function asin(x2) {
    return x2 > 1 ? halfPi : x2 < -1 ? -halfPi : Math.asin(x2);
  }

  // node_modules/@turf/buffer/node_modules/d3-geo/src/noop.js
  function noop() {
  }

  // node_modules/@turf/buffer/node_modules/d3-geo/src/area.js
  var areaRingSum = adder_default();
  var areaSum = adder_default();

  // node_modules/@turf/buffer/node_modules/d3-geo/src/cartesian.js
  function cartesian(spherical3) {
    var lambda = spherical3[0], phi = spherical3[1], cosPhi = cos(phi);
    return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];
  }
  function cartesianCross(a, b) {
    return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
  }
  function cartesianNormalizeInPlace(d) {
    var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
    d[0] /= l, d[1] /= l, d[2] /= l;
  }

  // node_modules/@turf/buffer/node_modules/d3-geo/src/bounds.js
  var deltaSum = adder_default();

  // node_modules/@turf/buffer/node_modules/d3-geo/src/rotation.js
  function rotationIdentity(lambda, phi) {
    return [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
  }
  rotationIdentity.invert = rotationIdentity;

  // node_modules/@turf/buffer/node_modules/d3-geo/src/clip/buffer.js
  function buffer_default() {
    var lines = [], line;
    return {
      point: function(x2, y2) {
        line.push([x2, y2]);
      },
      lineStart: function() {
        lines.push(line = []);
      },
      lineEnd: noop,
      rejoin: function() {
        if (lines.length > 1)
          lines.push(lines.pop().concat(lines.shift()));
      },
      result: function() {
        var result = lines;
        lines = [];
        line = null;
        return result;
      }
    };
  }

  // node_modules/@turf/buffer/node_modules/d3-geo/src/pointEqual.js
  function pointEqual_default(a, b) {
    return abs(a[0] - b[0]) < epsilon3 && abs(a[1] - b[1]) < epsilon3;
  }

  // node_modules/@turf/buffer/node_modules/d3-geo/src/clip/polygon.js
  function Intersection(point2, points, other, entry) {
    this.x = point2;
    this.z = points;
    this.o = other;
    this.e = entry;
    this.v = false;
    this.n = this.p = null;
  }
  function polygon_default(segments, compareIntersection2, startInside, interpolate, stream) {
    var subject = [], clip = [], i, n;
    segments.forEach(function(segment) {
      if ((n2 = segment.length - 1) <= 0)
        return;
      var n2, p010 = segment[0], p1 = segment[n2], x2;
      if (pointEqual_default(p010, p1)) {
        stream.lineStart();
        for (i = 0; i < n2; ++i)
          stream.point((p010 = segment[i])[0], p010[1]);
        stream.lineEnd();
        return;
      }
      subject.push(x2 = new Intersection(p010, segment, null, true));
      clip.push(x2.o = new Intersection(p010, null, x2, false));
      subject.push(x2 = new Intersection(p1, segment, null, false));
      clip.push(x2.o = new Intersection(p1, null, x2, true));
    });
    if (!subject.length)
      return;
    clip.sort(compareIntersection2);
    link(subject);
    link(clip);
    for (i = 0, n = clip.length; i < n; ++i) {
      clip[i].e = startInside = !startInside;
    }
    var start = subject[0], points, point2;
    while (1) {
      var current = start, isSubject = true;
      while (current.v)
        if ((current = current.n) === start)
          return;
      points = current.z;
      stream.lineStart();
      do {
        current.v = current.o.v = true;
        if (current.e) {
          if (isSubject) {
            for (i = 0, n = points.length; i < n; ++i)
              stream.point((point2 = points[i])[0], point2[1]);
          } else {
            interpolate(current.x, current.n.x, 1, stream);
          }
          current = current.n;
        } else {
          if (isSubject) {
            points = current.p.z;
            for (i = points.length - 1; i >= 0; --i)
              stream.point((point2 = points[i])[0], point2[1]);
          } else {
            interpolate(current.x, current.p.x, -1, stream);
          }
          current = current.p;
        }
        current = current.o;
        points = current.z;
        isSubject = !isSubject;
      } while (!current.v);
      stream.lineEnd();
    }
  }
  function link(array2) {
    if (!(n = array2.length))
      return;
    var n, i = 0, a = array2[0], b;
    while (++i < n) {
      a.n = b = array2[i];
      b.p = a;
      a = b;
    }
    a.n = b = array2[0];
    b.p = a;
  }

  // node_modules/@turf/buffer/node_modules/d3-array/src/ascending.js
  function ascending_default(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  // node_modules/@turf/buffer/node_modules/d3-array/src/bisector.js
  function bisector_default(compare) {
    if (compare.length === 1)
      compare = ascendingComparator(compare);
    return {
      left: function(a, x2, lo, hi) {
        if (lo == null)
          lo = 0;
        if (hi == null)
          hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x2) < 0)
            lo = mid + 1;
          else
            hi = mid;
        }
        return lo;
      },
      right: function(a, x2, lo, hi) {
        if (lo == null)
          lo = 0;
        if (hi == null)
          hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x2) > 0)
            hi = mid;
          else
            lo = mid + 1;
        }
        return lo;
      }
    };
  }
  function ascendingComparator(f) {
    return function(d, x2) {
      return ascending_default(f(d), x2);
    };
  }

  // node_modules/@turf/buffer/node_modules/d3-array/src/bisect.js
  var ascendingBisect = bisector_default(ascending_default);
  var bisectRight = ascendingBisect.right;
  var bisectLeft = ascendingBisect.left;

  // node_modules/@turf/buffer/node_modules/d3-array/src/array.js
  var array = Array.prototype;
  var slice = array.slice;
  var map = array.map;

  // node_modules/@turf/buffer/node_modules/d3-array/src/ticks.js
  var e10 = Math.sqrt(50);
  var e5 = Math.sqrt(10);
  var e2 = Math.sqrt(2);

  // node_modules/@turf/buffer/node_modules/d3-array/src/merge.js
  function merge_default2(arrays) {
    var n = arrays.length, m, i = -1, j = 0, merged, array2;
    while (++i < n)
      j += arrays[i].length;
    merged = new Array(j);
    while (--n >= 0) {
      array2 = arrays[n];
      m = array2.length;
      while (--m >= 0) {
        merged[--j] = array2[m];
      }
    }
    return merged;
  }

  // node_modules/@turf/buffer/node_modules/d3-geo/src/clip/extent.js
  var clipMax = 1e9;
  var clipMin = -clipMax;

  // node_modules/@turf/buffer/node_modules/d3-geo/src/polygonContains.js
  var sum = adder_default();
  function polygonContains_default(polygon2, point2) {
    var lambda = point2[0], phi = point2[1], normal = [sin(lambda), -cos(lambda), 0], angle2 = 0, winding = 0;
    sum.reset();
    for (var i = 0, n = polygon2.length; i < n; ++i) {
      if (!(m = (ring = polygon2[i]).length))
        continue;
      var ring, m, point0 = ring[m - 1], lambda03 = point0[0], phi02 = point0[1] / 2 + quarterPi, sinPhi02 = sin(phi02), cosPhi02 = cos(phi02);
      for (var j = 0; j < m; ++j, lambda03 = lambda12, sinPhi02 = sinPhi1, cosPhi02 = cosPhi1, point0 = point1) {
        var point1 = ring[j], lambda12 = point1[0], phi12 = point1[1] / 2 + quarterPi, sinPhi1 = sin(phi12), cosPhi1 = cos(phi12), delta = lambda12 - lambda03, sign2 = delta >= 0 ? 1 : -1, absDelta = sign2 * delta, antimeridian = absDelta > pi, k = sinPhi02 * sinPhi1;
        sum.add(atan2(k * sign2 * sin(absDelta), cosPhi02 * cosPhi1 + k * cos(absDelta)));
        angle2 += antimeridian ? delta + sign2 * tau : delta;
        if (antimeridian ^ lambda03 >= lambda ^ lambda12 >= lambda) {
          var arc = cartesianCross(cartesian(point0), cartesian(point1));
          cartesianNormalizeInPlace(arc);
          var intersection = cartesianCross(normal, arc);
          cartesianNormalizeInPlace(intersection);
          var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);
          if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
            winding += antimeridian ^ delta >= 0 ? 1 : -1;
          }
        }
      }
    }
    return (angle2 < -epsilon3 || angle2 < epsilon3 && sum < -epsilon3) ^ winding & 1;
  }

  // node_modules/@turf/buffer/node_modules/d3-geo/src/length.js
  var lengthSum = adder_default();

  // node_modules/@turf/buffer/node_modules/d3-geo/src/path/area.js
  var areaSum2 = adder_default();
  var areaRingSum2 = adder_default();

  // node_modules/@turf/buffer/node_modules/d3-geo/src/path/bounds.js
  var x0 = Infinity;
  var x1 = -x0;

  // node_modules/@turf/buffer/node_modules/d3-geo/src/path/context.js
  function PathContext(context) {
    this._context = context;
  }
  PathContext.prototype = {
    _radius: 4.5,
    pointRadius: function(_) {
      return this._radius = _, this;
    },
    polygonStart: function() {
      this._line = 0;
    },
    polygonEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line === 0)
        this._context.closePath();
      this._point = NaN;
    },
    point: function(x2, y2) {
      switch (this._point) {
        case 0: {
          this._context.moveTo(x2, y2);
          this._point = 1;
          break;
        }
        case 1: {
          this._context.lineTo(x2, y2);
          break;
        }
        default: {
          this._context.moveTo(x2 + this._radius, y2);
          this._context.arc(x2, y2, this._radius, 0, tau);
          break;
        }
      }
    },
    result: noop
  };

  // node_modules/@turf/buffer/node_modules/d3-geo/src/path/measure.js
  var lengthSum2 = adder_default();

  // node_modules/@turf/buffer/node_modules/d3-geo/src/path/string.js
  function PathString() {
    this._string = [];
  }
  PathString.prototype = {
    _radius: 4.5,
    _circle: circle2(4.5),
    pointRadius: function(_) {
      if ((_ = +_) !== this._radius)
        this._radius = _, this._circle = null;
      return this;
    },
    polygonStart: function() {
      this._line = 0;
    },
    polygonEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line === 0)
        this._string.push("Z");
      this._point = NaN;
    },
    point: function(x2, y2) {
      switch (this._point) {
        case 0: {
          this._string.push("M", x2, ",", y2);
          this._point = 1;
          break;
        }
        case 1: {
          this._string.push("L", x2, ",", y2);
          break;
        }
        default: {
          if (this._circle == null)
            this._circle = circle2(this._radius);
          this._string.push("M", x2, ",", y2, this._circle);
          break;
        }
      }
    },
    result: function() {
      if (this._string.length) {
        var result = this._string.join("");
        this._string = [];
        return result;
      } else {
        return null;
      }
    }
  };
  function circle2(radius) {
    return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
  }

  // node_modules/@turf/buffer/node_modules/d3-geo/src/clip/index.js
  function clip_default(pointVisible, clipLine, interpolate, start) {
    return function(rotate, sink) {
      var line = clipLine(sink), rotatedStart = rotate.invert(start[0], start[1]), ringBuffer = buffer_default(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon2, segments, ring;
      var clip = {
        point: point2,
        lineStart,
        lineEnd,
        polygonStart: function() {
          clip.point = pointRing;
          clip.lineStart = ringStart;
          clip.lineEnd = ringEnd;
          segments = [];
          polygon2 = [];
        },
        polygonEnd: function() {
          clip.point = point2;
          clip.lineStart = lineStart;
          clip.lineEnd = lineEnd;
          segments = merge_default2(segments);
          var startInside = polygonContains_default(polygon2, rotatedStart);
          if (segments.length) {
            if (!polygonStarted)
              sink.polygonStart(), polygonStarted = true;
            polygon_default(segments, compareIntersection, startInside, interpolate, sink);
          } else if (startInside) {
            if (!polygonStarted)
              sink.polygonStart(), polygonStarted = true;
            sink.lineStart();
            interpolate(null, null, 1, sink);
            sink.lineEnd();
          }
          if (polygonStarted)
            sink.polygonEnd(), polygonStarted = false;
          segments = polygon2 = null;
        },
        sphere: function() {
          sink.polygonStart();
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
          sink.polygonEnd();
        }
      };
      function point2(lambda, phi) {
        var point3 = rotate(lambda, phi);
        if (pointVisible(lambda = point3[0], phi = point3[1]))
          sink.point(lambda, phi);
      }
      function pointLine(lambda, phi) {
        var point3 = rotate(lambda, phi);
        line.point(point3[0], point3[1]);
      }
      function lineStart() {
        clip.point = pointLine;
        line.lineStart();
      }
      function lineEnd() {
        clip.point = point2;
        line.lineEnd();
      }
      function pointRing(lambda, phi) {
        ring.push([lambda, phi]);
        var point3 = rotate(lambda, phi);
        ringSink.point(point3[0], point3[1]);
      }
      function ringStart() {
        ringSink.lineStart();
        ring = [];
      }
      function ringEnd() {
        pointRing(ring[0][0], ring[0][1]);
        ringSink.lineEnd();
        var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m, segment, point3;
        ring.pop();
        polygon2.push(ring);
        ring = null;
        if (!n)
          return;
        if (clean & 1) {
          segment = ringSegments[0];
          if ((m = segment.length - 1) > 0) {
            if (!polygonStarted)
              sink.polygonStart(), polygonStarted = true;
            sink.lineStart();
            for (i = 0; i < m; ++i)
              sink.point((point3 = segment[i])[0], point3[1]);
            sink.lineEnd();
          }
          return;
        }
        if (n > 1 && clean & 2)
          ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
        segments.push(ringSegments.filter(validSegment));
      }
      return clip;
    };
  }
  function validSegment(segment) {
    return segment.length > 1;
  }
  function compareIntersection(a, b) {
    return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon3 : halfPi - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon3 : halfPi - b[1]);
  }

  // node_modules/@turf/buffer/node_modules/d3-geo/src/clip/antimeridian.js
  var antimeridian_default = clip_default(
    function() {
      return true;
    },
    clipAntimeridianLine,
    clipAntimeridianInterpolate,
    [-pi, -halfPi]
  );
  function clipAntimeridianLine(stream) {
    var lambda03 = NaN, phi02 = NaN, sign0 = NaN, clean;
    return {
      lineStart: function() {
        stream.lineStart();
        clean = 1;
      },
      point: function(lambda12, phi12) {
        var sign1 = lambda12 > 0 ? pi : -pi, delta = abs(lambda12 - lambda03);
        if (abs(delta - pi) < epsilon3) {
          stream.point(lambda03, phi02 = (phi02 + phi12) / 2 > 0 ? halfPi : -halfPi);
          stream.point(sign0, phi02);
          stream.lineEnd();
          stream.lineStart();
          stream.point(sign1, phi02);
          stream.point(lambda12, phi02);
          clean = 0;
        } else if (sign0 !== sign1 && delta >= pi) {
          if (abs(lambda03 - sign0) < epsilon3)
            lambda03 -= sign0 * epsilon3;
          if (abs(lambda12 - sign1) < epsilon3)
            lambda12 -= sign1 * epsilon3;
          phi02 = clipAntimeridianIntersect(lambda03, phi02, lambda12, phi12);
          stream.point(sign0, phi02);
          stream.lineEnd();
          stream.lineStart();
          stream.point(sign1, phi02);
          clean = 0;
        }
        stream.point(lambda03 = lambda12, phi02 = phi12);
        sign0 = sign1;
      },
      lineEnd: function() {
        stream.lineEnd();
        lambda03 = phi02 = NaN;
      },
      clean: function() {
        return 2 - clean;
      }
    };
  }
  function clipAntimeridianIntersect(lambda03, phi02, lambda12, phi12) {
    var cosPhi02, cosPhi1, sinLambda0Lambda1 = sin(lambda03 - lambda12);
    return abs(sinLambda0Lambda1) > epsilon3 ? atan((sin(phi02) * (cosPhi1 = cos(phi12)) * sin(lambda12) - sin(phi12) * (cosPhi02 = cos(phi02)) * sin(lambda03)) / (cosPhi02 * cosPhi1 * sinLambda0Lambda1)) : (phi02 + phi12) / 2;
  }
  function clipAntimeridianInterpolate(from, to, direction, stream) {
    var phi;
    if (from == null) {
      phi = direction * halfPi;
      stream.point(-pi, phi);
      stream.point(0, phi);
      stream.point(pi, phi);
      stream.point(pi, 0);
      stream.point(pi, -phi);
      stream.point(0, -phi);
      stream.point(-pi, -phi);
      stream.point(-pi, 0);
      stream.point(-pi, phi);
    } else if (abs(from[0] - to[0]) > epsilon3) {
      var lambda = from[0] < to[0] ? pi : -pi;
      phi = direction * lambda / 2;
      stream.point(-lambda, phi);
      stream.point(0, phi);
      stream.point(lambda, phi);
    } else {
      stream.point(to[0], to[1]);
    }
  }

  // node_modules/@turf/buffer/node_modules/d3-geo/src/transform.js
  function transformer(methods) {
    return function(stream) {
      var s = new TransformStream();
      for (var key in methods)
        s[key] = methods[key];
      s.stream = stream;
      return s;
    };
  }
  function TransformStream() {
  }
  TransformStream.prototype = {
    constructor: TransformStream,
    point: function(x2, y2) {
      this.stream.point(x2, y2);
    },
    sphere: function() {
      this.stream.sphere();
    },
    lineStart: function() {
      this.stream.lineStart();
    },
    lineEnd: function() {
      this.stream.lineEnd();
    },
    polygonStart: function() {
      this.stream.polygonStart();
    },
    polygonEnd: function() {
      this.stream.polygonEnd();
    }
  };

  // node_modules/@turf/buffer/node_modules/d3-geo/src/projection/resample.js
  var cosMinDistance = cos(30 * radians);

  // node_modules/@turf/buffer/node_modules/d3-geo/src/projection/index.js
  var transformRadians = transformer({
    point: function(x2, y2) {
      this.stream.point(x2 * radians, y2 * radians);
    }
  });

  // node_modules/@turf/buffer/node_modules/d3-geo/src/projection/azimuthal.js
  function azimuthalRaw(scale) {
    return function(x2, y2) {
      var cx = cos(x2), cy = cos(y2), k = scale(cx * cy);
      return [
        k * cy * sin(x2),
        k * sin(y2)
      ];
    };
  }
  function azimuthalInvert(angle2) {
    return function(x2, y2) {
      var z = sqrt(x2 * x2 + y2 * y2), c = angle2(z), sc = sin(c), cc = cos(c);
      return [
        atan2(x2 * sc, z * cc),
        asin(z && y2 * sc / z)
      ];
    };
  }

  // node_modules/@turf/buffer/node_modules/d3-geo/src/projection/azimuthalEqualArea.js
  var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
    return sqrt(2 / (1 + cxcy));
  });
  azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
    return 2 * asin(z / 2);
  });

  // node_modules/@turf/buffer/node_modules/d3-geo/src/projection/azimuthalEquidistant.js
  var azimuthalEquidistantRaw = azimuthalRaw(function(c) {
    return (c = acos(c)) && c / sin(c);
  });
  azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
    return z;
  });

  // node_modules/@turf/buffer/node_modules/d3-geo/src/projection/mercator.js
  function mercatorRaw(lambda, phi) {
    return [lambda, log(tan((halfPi + phi) / 2))];
  }
  mercatorRaw.invert = function(x2, y2) {
    return [x2, 2 * atan(exp(y2)) - halfPi];
  };

  // node_modules/@turf/buffer/node_modules/d3-geo/src/projection/equirectangular.js
  function equirectangularRaw(lambda, phi) {
    return [lambda, phi];
  }
  equirectangularRaw.invert = equirectangularRaw;

  // node_modules/@turf/buffer/node_modules/d3-geo/src/projection/gnomonic.js
  function gnomonicRaw(x2, y2) {
    var cy = cos(y2), k = cos(x2) * cy;
    return [cy * sin(x2) / k, sin(y2) / k];
  }
  gnomonicRaw.invert = azimuthalInvert(atan);

  // node_modules/@turf/buffer/node_modules/d3-geo/src/projection/naturalEarth1.js
  function naturalEarth1Raw(lambda, phi) {
    var phi2 = phi * phi, phi4 = phi2 * phi2;
    return [
      lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi2 - 1529e-6 * phi4))),
      phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 5916e-6 * phi4)))
    ];
  }
  naturalEarth1Raw.invert = function(x2, y2) {
    var phi = y2, i = 25, delta;
    do {
      var phi2 = phi * phi, phi4 = phi2 * phi2;
      phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 5916e-6 * phi4))) - y2) / (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 5916e-6 * 11 * phi4)));
    } while (abs(delta) > epsilon3 && --i > 0);
    return [
      x2 / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (3971e-6 - 1529e-6 * phi2)))),
      phi
    ];
  };

  // node_modules/@turf/buffer/node_modules/d3-geo/src/projection/orthographic.js
  function orthographicRaw(x2, y2) {
    return [cos(y2) * sin(x2), sin(y2)];
  }
  orthographicRaw.invert = azimuthalInvert(asin);

  // node_modules/@turf/buffer/node_modules/d3-geo/src/projection/stereographic.js
  function stereographicRaw(x2, y2) {
    var cy = cos(y2), k = 1 + cos(x2) * cy;
    return [cy * sin(x2) / k, sin(y2) / k];
  }
  stereographicRaw.invert = azimuthalInvert(function(z) {
    return 2 * atan(z);
  });

  // node_modules/@turf/buffer/node_modules/d3-geo/src/projection/transverseMercator.js
  function transverseMercatorRaw(lambda, phi) {
    return [log(tan((halfPi + phi) / 2)), -lambda];
  }
  transverseMercatorRaw.invert = function(x2, y2) {
    return [-y2, 2 * atan(exp(x2)) - halfPi];
  };

  // node_modules/@turf/union/dist/es/index.js
  var import_polygon_clipping2 = __toESM(require_polygon_clipping_umd(), 1);

  // node_modules/@turf/intersect/dist/es/index.js
  var import_polygon_clipping3 = __toESM(require_polygon_clipping_umd(), 1);

  // node_modules/@turf/dissolve/dist/es/index.js
  var import_polygon_clipping4 = __toESM(require_polygon_clipping_umd(), 1);

  // node_modules/@turf/mask/dist/es/index.js
  var import_polygon_clipping5 = __toESM(require_polygon_clipping_umd(), 1);

  // node_modules/d3-array/src/fsum.js
  var Adder2 = class {
    constructor() {
      this._partials = new Float64Array(32);
      this._n = 0;
    }
    add(x2) {
      const p = this._partials;
      let i = 0;
      for (let j = 0; j < this._n && j < 32; j++) {
        const y2 = p[j], hi = x2 + y2, lo = Math.abs(x2) < Math.abs(y2) ? x2 - (hi - y2) : y2 - (hi - x2);
        if (lo)
          p[i++] = lo;
        x2 = hi;
      }
      p[i] = x2;
      this._n = i + 1;
      return this;
    }
    valueOf() {
      const p = this._partials;
      let n = this._n, x2, y2, lo, hi = 0;
      if (n > 0) {
        hi = p[--n];
        while (n > 0) {
          x2 = hi;
          y2 = p[--n];
          hi = x2 + y2;
          lo = y2 - (hi - x2);
          if (lo)
            break;
        }
        if (n > 0 && (lo < 0 && p[n - 1] < 0 || lo > 0 && p[n - 1] > 0)) {
          y2 = lo * 2;
          x2 = hi + y2;
          if (y2 == x2 - hi)
            hi = x2;
        }
      }
      return hi;
    }
  };

  // node_modules/d3-geo/src/math.js
  var epsilon4 = 1e-6;
  var pi2 = Math.PI;
  var halfPi2 = pi2 / 2;
  var quarterPi2 = pi2 / 4;
  var tau2 = pi2 * 2;
  var degrees2 = 180 / pi2;
  var radians2 = pi2 / 180;
  var abs2 = Math.abs;
  var atan22 = Math.atan2;
  var cos2 = Math.cos;
  var sin2 = Math.sin;
  var sqrt2 = Math.sqrt;
  function asin2(x2) {
    return x2 > 1 ? halfPi2 : x2 < -1 ? -halfPi2 : Math.asin(x2);
  }

  // node_modules/d3-geo/src/noop.js
  function noop2() {
  }

  // node_modules/d3-geo/src/stream.js
  function streamGeometry(geometry, stream) {
    if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
      streamGeometryType[geometry.type](geometry, stream);
    }
  }
  var streamObjectType = {
    Feature: function(object2, stream) {
      streamGeometry(object2.geometry, stream);
    },
    FeatureCollection: function(object2, stream) {
      var features = object2.features, i = -1, n = features.length;
      while (++i < n)
        streamGeometry(features[i].geometry, stream);
    }
  };
  var streamGeometryType = {
    Sphere: function(object2, stream) {
      stream.sphere();
    },
    Point: function(object2, stream) {
      object2 = object2.coordinates;
      stream.point(object2[0], object2[1], object2[2]);
    },
    MultiPoint: function(object2, stream) {
      var coordinates = object2.coordinates, i = -1, n = coordinates.length;
      while (++i < n)
        object2 = coordinates[i], stream.point(object2[0], object2[1], object2[2]);
    },
    LineString: function(object2, stream) {
      streamLine(object2.coordinates, stream, 0);
    },
    MultiLineString: function(object2, stream) {
      var coordinates = object2.coordinates, i = -1, n = coordinates.length;
      while (++i < n)
        streamLine(coordinates[i], stream, 0);
    },
    Polygon: function(object2, stream) {
      streamPolygon(object2.coordinates, stream);
    },
    MultiPolygon: function(object2, stream) {
      var coordinates = object2.coordinates, i = -1, n = coordinates.length;
      while (++i < n)
        streamPolygon(coordinates[i], stream);
    },
    GeometryCollection: function(object2, stream) {
      var geometries = object2.geometries, i = -1, n = geometries.length;
      while (++i < n)
        streamGeometry(geometries[i], stream);
    }
  };
  function streamLine(coordinates, stream, closed) {
    var i = -1, n = coordinates.length - closed, coordinate;
    stream.lineStart();
    while (++i < n)
      coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
    stream.lineEnd();
  }
  function streamPolygon(coordinates, stream) {
    var i = -1, n = coordinates.length;
    stream.polygonStart();
    while (++i < n)
      streamLine(coordinates[i], stream, 1);
    stream.polygonEnd();
  }
  function stream_default2(object2, stream) {
    if (object2 && streamObjectType.hasOwnProperty(object2.type)) {
      streamObjectType[object2.type](object2, stream);
    } else {
      streamGeometry(object2, stream);
    }
  }

  // node_modules/d3-geo/src/area.js
  var areaRingSum3 = new Adder2();
  var areaSum3 = new Adder2();
  var lambda00;
  var phi00;
  var lambda0;
  var cosPhi0;
  var sinPhi0;
  var areaStream2 = {
    point: noop2,
    lineStart: noop2,
    lineEnd: noop2,
    polygonStart: function() {
      areaRingSum3 = new Adder2();
      areaStream2.lineStart = areaRingStart;
      areaStream2.lineEnd = areaRingEnd;
    },
    polygonEnd: function() {
      var areaRing = +areaRingSum3;
      areaSum3.add(areaRing < 0 ? tau2 + areaRing : areaRing);
      this.lineStart = this.lineEnd = this.point = noop2;
    },
    sphere: function() {
      areaSum3.add(tau2);
    }
  };
  function areaRingStart() {
    areaStream2.point = areaPointFirst;
  }
  function areaRingEnd() {
    areaPoint(lambda00, phi00);
  }
  function areaPointFirst(lambda, phi) {
    areaStream2.point = areaPoint;
    lambda00 = lambda, phi00 = phi;
    lambda *= radians2, phi *= radians2;
    lambda0 = lambda, cosPhi0 = cos2(phi = phi / 2 + quarterPi2), sinPhi0 = sin2(phi);
  }
  function areaPoint(lambda, phi) {
    lambda *= radians2, phi *= radians2;
    phi = phi / 2 + quarterPi2;
    var dLambda = lambda - lambda0, sdLambda = dLambda >= 0 ? 1 : -1, adLambda = sdLambda * dLambda, cosPhi = cos2(phi), sinPhi = sin2(phi), k = sinPhi0 * sinPhi, u = cosPhi0 * cosPhi + k * cos2(adLambda), v = k * sdLambda * sin2(adLambda);
    areaRingSum3.add(atan22(v, u));
    lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
  }

  // node_modules/d3-geo/src/cartesian.js
  function spherical2(cartesian3) {
    return [atan22(cartesian3[1], cartesian3[0]), asin2(cartesian3[2])];
  }
  function cartesian2(spherical3) {
    var lambda = spherical3[0], phi = spherical3[1], cosPhi = cos2(phi);
    return [cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi)];
  }
  function cartesianCross2(a, b) {
    return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
  }
  function cartesianNormalizeInPlace2(d) {
    var l = sqrt2(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
    d[0] /= l, d[1] /= l, d[2] /= l;
  }

  // node_modules/d3-geo/src/bounds.js
  var lambda02;
  var phi0;
  var lambda1;
  var phi1;
  var lambda2;
  var lambda002;
  var phi002;
  var p0;
  var deltaSum2;
  var ranges;
  var range;
  var boundsStream = {
    point: boundsPoint,
    lineStart: boundsLineStart,
    lineEnd: boundsLineEnd,
    polygonStart: function() {
      boundsStream.point = boundsRingPoint;
      boundsStream.lineStart = boundsRingStart;
      boundsStream.lineEnd = boundsRingEnd;
      deltaSum2 = new Adder2();
      areaStream2.polygonStart();
    },
    polygonEnd: function() {
      areaStream2.polygonEnd();
      boundsStream.point = boundsPoint;
      boundsStream.lineStart = boundsLineStart;
      boundsStream.lineEnd = boundsLineEnd;
      if (areaRingSum3 < 0)
        lambda02 = -(lambda1 = 180), phi0 = -(phi1 = 90);
      else if (deltaSum2 > epsilon4)
        phi1 = 90;
      else if (deltaSum2 < -epsilon4)
        phi0 = -90;
      range[0] = lambda02, range[1] = lambda1;
    },
    sphere: function() {
      lambda02 = -(lambda1 = 180), phi0 = -(phi1 = 90);
    }
  };
  function boundsPoint(lambda, phi) {
    ranges.push(range = [lambda02 = lambda, lambda1 = lambda]);
    if (phi < phi0)
      phi0 = phi;
    if (phi > phi1)
      phi1 = phi;
  }
  function linePoint(lambda, phi) {
    var p = cartesian2([lambda * radians2, phi * radians2]);
    if (p0) {
      var normal = cartesianCross2(p0, p), equatorial = [normal[1], -normal[0], 0], inflection = cartesianCross2(equatorial, normal);
      cartesianNormalizeInPlace2(inflection);
      inflection = spherical2(inflection);
      var delta = lambda - lambda2, sign2 = delta > 0 ? 1 : -1, lambdai = inflection[0] * degrees2 * sign2, phii, antimeridian = abs2(delta) > 180;
      if (antimeridian ^ (sign2 * lambda2 < lambdai && lambdai < sign2 * lambda)) {
        phii = inflection[1] * degrees2;
        if (phii > phi1)
          phi1 = phii;
      } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign2 * lambda2 < lambdai && lambdai < sign2 * lambda)) {
        phii = -inflection[1] * degrees2;
        if (phii < phi0)
          phi0 = phii;
      } else {
        if (phi < phi0)
          phi0 = phi;
        if (phi > phi1)
          phi1 = phi;
      }
      if (antimeridian) {
        if (lambda < lambda2) {
          if (angle(lambda02, lambda) > angle(lambda02, lambda1))
            lambda1 = lambda;
        } else {
          if (angle(lambda, lambda1) > angle(lambda02, lambda1))
            lambda02 = lambda;
        }
      } else {
        if (lambda1 >= lambda02) {
          if (lambda < lambda02)
            lambda02 = lambda;
          if (lambda > lambda1)
            lambda1 = lambda;
        } else {
          if (lambda > lambda2) {
            if (angle(lambda02, lambda) > angle(lambda02, lambda1))
              lambda1 = lambda;
          } else {
            if (angle(lambda, lambda1) > angle(lambda02, lambda1))
              lambda02 = lambda;
          }
        }
      }
    } else {
      ranges.push(range = [lambda02 = lambda, lambda1 = lambda]);
    }
    if (phi < phi0)
      phi0 = phi;
    if (phi > phi1)
      phi1 = phi;
    p0 = p, lambda2 = lambda;
  }
  function boundsLineStart() {
    boundsStream.point = linePoint;
  }
  function boundsLineEnd() {
    range[0] = lambda02, range[1] = lambda1;
    boundsStream.point = boundsPoint;
    p0 = null;
  }
  function boundsRingPoint(lambda, phi) {
    if (p0) {
      var delta = lambda - lambda2;
      deltaSum2.add(abs2(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
    } else {
      lambda002 = lambda, phi002 = phi;
    }
    areaStream2.point(lambda, phi);
    linePoint(lambda, phi);
  }
  function boundsRingStart() {
    areaStream2.lineStart();
  }
  function boundsRingEnd() {
    boundsRingPoint(lambda002, phi002);
    areaStream2.lineEnd();
    if (abs2(deltaSum2) > epsilon4)
      lambda02 = -(lambda1 = 180);
    range[0] = lambda02, range[1] = lambda1;
    p0 = null;
  }
  function angle(lambda03, lambda12) {
    return (lambda12 -= lambda03) < 0 ? lambda12 + 360 : lambda12;
  }
  function rangeCompare(a, b) {
    return a[0] - b[0];
  }
  function rangeContains(range2, x2) {
    return range2[0] <= range2[1] ? range2[0] <= x2 && x2 <= range2[1] : x2 < range2[0] || range2[1] < x2;
  }
  function bounds_default4(feature2) {
    var i, n, a, b, merged, deltaMax, delta;
    phi1 = lambda1 = -(lambda02 = phi0 = Infinity);
    ranges = [];
    stream_default2(feature2, boundsStream);
    if (n = ranges.length) {
      ranges.sort(rangeCompare);
      for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
        b = ranges[i];
        if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
          if (angle(a[0], b[1]) > angle(a[0], a[1]))
            a[1] = b[1];
          if (angle(b[0], a[1]) > angle(a[0], a[1]))
            a[0] = b[0];
        } else {
          merged.push(a = b);
        }
      }
      for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
        b = merged[i];
        if ((delta = angle(a[1], b[0])) > deltaMax)
          deltaMax = delta, lambda02 = b[0], lambda1 = a[1];
      }
    }
    ranges = range = null;
    return lambda02 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda02, phi0], [lambda1, phi1]];
  }

  // libs/shared/utils/src/lib/geometry/line-calculations.ts
  var import_geojson_rewind = __toESM(require_geojson_rewind());
  var fp = __toESM(require_fp());

  // libs/shared/utils/src/lib/geometry/point-transformations.ts
  var import_Option = __toESM(require_Option());
  var import_function = __toESM(require_function());
  function convertPointToTurfPoint(point2) {
    return point([point2.lon, point2.lat]);
  }
  var convertGeojsonPositionToTurfPoint = (point2) => {
    return point(point2);
  };
  var convertGeojsonPointFeatureToPoint = (point2) => {
    return (0, import_function.pipe)(
      (0, import_Option.fromNullable)(point2.geometry),
      (0, import_Option.mapNullable)((geometry) => geometry.coordinates),
      (0, import_Option.map)((coordinates) => ({
        lat: coordinates[1],
        lon: coordinates[0],
        elevation: coordinates[2]
      }))
    );
  };

  // libs/shared/utils/src/lib/geometry/line-calculations.ts
  var import_Option2 = __toESM(require_Option());
  function distanceFromRoute(point2, path) {
    const tPoint = convertPointToTurfPoint(point2);
    const pointOnRoute = es_default4(path, tPoint);
    return Math.round(
      es_default(tPoint, pointOnRoute, { units: "kilometers" }) * 1e3
    );
  }
  function snappedLineSlice(start, end, path) {
    return es_default5(
      convertPointToTurfPoint(start),
      convertPointToTurfPoint(end),
      path
    );
  }
  function distanceOnLine(start, end, path) {
    const startDistanceFromPath = distanceFromRoute(start, path);
    const endDistanceFromPath = distanceFromRoute(end, path);
    const pathBetweenSnappedPoints = snappedLineSlice(start, end, path);
    const snappedPathLength = length(pathBetweenSnappedPoints, { units: "kilometers" }) * 1e3;
    return startDistanceFromPath + endDistanceFromPath + snappedPathLength;
  }
  var lineLengthInMeters = (lineCoordinates) => O.tryCatch(
    () => length(lineString(lineCoordinates), { units: "kilometers" }) * 1e3
  );
  var lineStringLengthInMeters = (line) => {
    var _a;
    return (0, import_function2.pipe)(
      O.fromNullable((_a = line == null ? void 0 : line.geometry) == null ? void 0 : _a.coordinates),
      O.chain(lineLengthInMeters)
    );
  };
  var distanceOnLineForFlutter = (start, end, path) => {
    return distanceOnLine(start, end, path).toString();
  };
  var getPaddedBoundingBoxOfFeature = (features, padding = 0) => {
    const d3Bounds = bounds_default4((0, import_geojson_rewind.default)(features, true));
    return {
      SouthWest: {
        lat: d3Bounds[0][1] + padding,
        lon: d3Bounds[0][0] + padding
      },
      NorthEast: {
        lat: d3Bounds[1][1] - padding,
        lon: d3Bounds[1][0] - padding
      }
    };
  };
  var getPaddedBoxOfTrack = (track) => getPaddedBoundingBoxOfFeature(track, 3e-3);
  var getBoundingBoxOfTrack = (features) => getPaddedBoundingBoxOfFeature(features);
  var getCenterRadiusOfBox = (bounds) => {
    const p1 = convertPointToTurfPoint(bounds.SouthWest);
    const p2 = convertPointToTurfPoint(bounds.NorthEast);
    return (0, import_function2.pipe)(
      es_default11(p1, p2),
      convertGeojsonPointFeatureToPoint,
      (0, import_Option2.chain)(
        (center) => (0, import_Option2.some)({
          radius: es_default(p1, p2, { units: "kilometers" }) * 500,
          center
        })
      )
    );
  };
  var fetchEnvelopeCoordinates = (featureCollection2) => {
    const env = es_default9(featureCollection2);
    if (env.geometry) {
      const coordinates = env.geometry.coordinates[0];
      return [
        [coordinates[0][1], coordinates[0][0]],
        [coordinates[2][1], coordinates[2][0]]
      ];
    } else {
      return null;
    }
  };
  var envelopeOfPoints = (points) => {
    const features = points.map(
      (point2) => convertGeojsonPositionToTurfPoint(point2)
    );
    const featureCollection2 = featureCollection(features);
    return fetchEnvelopeCoordinates(featureCollection2);
  };
  var envelopeOfPaths = (paths) => {
    return (0, import_function2.pipe)(
      paths,
      fp.map((path) => path.coordinates),
      fp.map((x2) => lineString(x2)),
      featureCollection,
      fetchEnvelopeCoordinates,
      O.fromNullable
    );
  };
  var boundingBoxOfPaths = (paths) => {
    return fp.flow(
      envelopeOfPaths,
      O.map((bounds) => ({
        SouthWest: { lat: bounds[0][0], lon: bounds[0][1] },
        NorthEast: { lat: bounds[1][0], lon: bounds[1][1] }
      })),
      O.getOrElse(() => null)
    )(paths);
  };
  var envelopeOfCircle = (center, radius) => {
    const centerPoint = convertGeojsonPositionToTurfPoint(center);
    const crcl = es_default10(centerPoint, Math.ceil(radius / 1e3));
    return (0, import_function2.pipe)([crcl], featureCollection, fetchEnvelopeCoordinates);
  };
  var splitBoundingBox = (bounds, maxRadius, boundsArr) => {
    const center = getCenterRadiusOfBox(bounds);
    if ((0, import_Option2.isSome)(center)) {
      if (center.value.radius < maxRadius) {
        boundsArr.push(bounds);
      } else {
        const geo = center.value;
        splitBoundingBox(
          {
            SouthWest: { lat: bounds.SouthWest.lat, lon: bounds.SouthWest.lon },
            NorthEast: geo.center
          },
          maxRadius,
          boundsArr
        );
        splitBoundingBox(
          {
            SouthWest: { lat: geo.center.lat, lon: bounds.SouthWest.lon },
            NorthEast: { lat: bounds.NorthEast.lat, lon: geo.center.lon }
          },
          maxRadius,
          boundsArr
        );
        splitBoundingBox(
          {
            SouthWest: { lat: bounds.SouthWest.lat, lon: geo.center.lon },
            NorthEast: { lat: geo.center.lat, lon: bounds.NorthEast.lon }
          },
          maxRadius,
          boundsArr
        );
        splitBoundingBox(
          {
            SouthWest: geo.center,
            NorthEast: { lat: bounds.NorthEast.lat, lon: bounds.NorthEast.lon }
          },
          maxRadius,
          boundsArr
        );
      }
    }
  };
  global.distanceOnLineForFlutter = distanceOnLineForFlutter;
  global.boundingBoxOfPaths = (paths) => {
    return JSON.stringify(boundingBoxOfPaths(paths));
  };
})();
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/*!
 * @license GNU Affero General Public License.
 * Copyright (c) 2015, 2015 Ronny Lorenz <ronny@tbi.univie.ac.at>
 * v. 1.2.0
 * https://github.com/RaumZeit/MarchingSquares.js
 *
 * MarchingSquaresJS is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MarchingSquaresJS is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * As additional permission under GNU Affero General Public License version 3
 * section 7, third-party projects (personal or commercial) may distribute,
 * include, or link against UNMODIFIED VERSIONS of MarchingSquaresJS without the
 * requirement that said third-party project for that reason alone becomes
 * subject to any requirement of the GNU Affero General Public License version 3.
 * Any modifications to MarchingSquaresJS, however, must be shared with the public
 * and made available.
 *
 * In summary this:
 * - allows you to use MarchingSquaresJS at no cost
 * - allows you to use MarchingSquaresJS for both personal and commercial purposes
 * - allows you to distribute UNMODIFIED VERSIONS of MarchingSquaresJS under any
 *   license as long as this license notice is included
 * - enables you to keep the source code of your program that uses MarchingSquaresJS
 *   undisclosed
 * - forces you to share any modifications you have made to MarchingSquaresJS,
 *   e.g. bug-fixes
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with MarchingSquaresJS.  If not, see <http://www.gnu.org/licenses/>.
 */
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
/**
 * @license GNU Affero General Public License.
 * Copyright (c) 2015, 2015 Ronny Lorenz <ronny@tbi.univie.ac.at>
 * v. 1.2.0
 * https://github.com/RaumZeit/MarchingSquares.js
 *
 * MarchingSquaresJS is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MarchingSquaresJS is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * As additional permission under GNU Affero General Public License version 3
 * section 7, third-party projects (personal or commercial) may distribute,
 * include, or link against UNMODIFIED VERSIONS of MarchingSquaresJS without the
 * requirement that said third-party project for that reason alone becomes
 * subject to any requirement of the GNU Affero General Public License version 3.
 * Any modifications to MarchingSquaresJS, however, must be shared with the public
 * and made available.
 *
 * In summary this:
 * - allows you to use MarchingSquaresJS at no cost
 * - allows you to use MarchingSquaresJS for both personal and commercial purposes
 * - allows you to distribute UNMODIFIED VERSIONS of MarchingSquaresJS under any
 *   license as long as this license notice is included
 * - enables you to keep the source code of your program that uses MarchingSquaresJS
 *   undisclosed
 * - forces you to share any modifications you have made to MarchingSquaresJS,
 *   e.g. bug-fixes
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with MarchingSquaresJS.  If not, see <http://www.gnu.org/licenses/>.
 */
/**
 * splaytree v3.1.0
 * Fast Splay tree for Node and browser
 *
 * @author Alexander Milevski <info@w8r.name>
 * @license MIT
 * @preserve
 */
